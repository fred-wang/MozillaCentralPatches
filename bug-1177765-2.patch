# HG changeset patch
# Parent b1c7b59e1d7c0fc86144e888c187e4c0879273e3
# User Frédéric Wang <fred.wang@free.fr>
Bug 1177765 - Add xmlroles for MathML. r=surkov

diff --git a/accessible/generic/HyperTextAccessible.cpp b/accessible/generic/HyperTextAccessible.cpp
--- a/accessible/generic/HyperTextAccessible.cpp
+++ b/accessible/generic/HyperTextAccessible.cpp
@@ -25,16 +25,17 @@
 #include "nsContainerFrame.h"
 #include "nsFrameSelection.h"
 #include "nsILineIterator.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIPersistentProperties2.h"
 #include "nsIScrollableFrame.h"
 #include "nsIServiceManager.h"
 #include "nsITextControlElement.h"
+#include "nsIMathMLFrame.h"
 #include "nsTextFragment.h"
 #include "mozilla/BinarySearch.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/EventStates.h"
 #include "mozilla/dom/Selection.h"
 #include "mozilla/MathAlgorithms.h"
 #include "gfxSkipChars.h"
 #include <algorithm>
@@ -947,16 +948,161 @@ HyperTextAccessible::GetLevelInternal()
   if (mContent->IsHTMLElement(nsGkAtoms::h5))
     return 5;
   if (mContent->IsHTMLElement(nsGkAtoms::h6))
     return 6;
 
   return AccessibleWrap::GetLevelInternal();
 }
 
+void
+HyperTextAccessible::SetMathMLXMLRoles(nsIPersistentProperties* aAttributes)
+{
+  // Add MathML xmlroles based on the position inside the parent.
+  Accessible* parent = Parent();
+  if (parent) {
+    switch (parent->Role()) {
+    case roles::MATHML_CELL:
+    case roles::MATHML_ENCLOSED:
+    case roles::MATHML_ERROR:
+    case roles::MATHML_MATH:
+    case roles::MATHML_ROW:
+    case roles::MATHML_SQUARE_ROOT:
+    case roles::MATHML_STYLE:
+      if (Role() == roles::MATHML_OPERATOR) {
+        // This is an operator inside an <mrow> (or an inferred <mrow>).
+        // See http://www.w3.org/TR/MathML3/chapter3.html#presm.inferredmrow
+        // XXX We should probably do something similar for MATHML_FENCED, but
+        // operators do not appear in the accessible tree. See bug 1175747.
+        nsIMathMLFrame* mathMLFrame = do_QueryFrame(GetFrame());
+        if (mathMLFrame) {
+          nsEmbellishData embellishData;
+          mathMLFrame->GetEmbellishData(embellishData);
+          if (NS_MATHML_EMBELLISH_IS_FENCE(embellishData.flags)) {
+            if (!PrevSibling()) {
+              nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                                     nsGkAtoms::open_fence);
+            } else if (!NextSibling()) {
+              nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                                     nsGkAtoms::close_fence);
+            }
+          }
+          if (NS_MATHML_EMBELLISH_IS_SEPARATOR(embellishData.flags)) {
+            nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                                   nsGkAtoms::separator_);
+          }
+        }
+      }
+    break;
+    case roles::MATHML_FRACTION:
+      nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                             IndexInParent() == 0 ?
+                             nsGkAtoms::numerator :
+                             nsGkAtoms::denominator);
+      break;
+    case roles::MATHML_ROOT:
+      if (IndexInParent() == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::root_index);
+      }
+      break;
+    case roles::MATHML_SUB:
+      if (IndexInParent() == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::subscript);
+      }
+      break;
+    case roles::MATHML_SUP:
+      if (IndexInParent() == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::superscript);
+      }
+      break;
+    case roles::MATHML_SUB_SUP: {
+      int32_t index = IndexInParent();
+      if (index == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::subscript);
+      } else if (index == 2) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::superscript);
+      }
+    } break;
+    case roles::MATHML_UNDER:
+      if (IndexInParent() == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::underscript);
+      }
+      break;
+    case roles::MATHML_OVER:
+      if (IndexInParent() == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::overscript);
+      }
+      break;
+    case roles::MATHML_UNDER_OVER: {
+      int32_t index = IndexInParent();
+      if (index == 1) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::underscript);
+      } else if (index == 2) {
+        nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                               nsGkAtoms::overscript);
+      }
+    } break;
+    case roles::MATHML_MULTISCRIPTS: {
+      // Get the <multiscripts> base.
+      nsIContent* child;
+      bool baseFound = false;
+      for (child = parent->GetContent()->GetFirstChild(); child;
+           child = child->GetNextSibling()) {
+        if (child->IsMathMLElement()) {
+          baseFound = true;
+          break;
+        }
+      }
+      if (baseFound) {
+        // Browse the list of scripts to find us and determine our type.
+        nsIContent* script = GetContent();
+        bool postscript = true;
+        bool subscript = true;
+        for (child = child->GetNextSibling(); child;
+             child = child->GetNextSibling()) {
+          if (!child->IsMathMLElement())
+            continue;
+          if (child->IsMathMLElement(nsGkAtoms::mprescripts_)) {
+            postscript = false;
+            subscript = true;
+            continue;
+          }
+          if (child == script) {
+            if (postscript) {
+              nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                                     subscript ?
+                                     nsGkAtoms::subscript :
+                                     nsGkAtoms::superscript);
+            } else {
+              nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
+                                     subscript ?
+                                     nsGkAtoms::presubscript :
+                                     nsGkAtoms::presuperscript);
+            }
+            break;
+          }
+          subscript = !subscript;
+        }
+      }
+      break;
+    }
+    default:
+      break;
+    }
+  }
+}
+
 already_AddRefed<nsIPersistentProperties>
 HyperTextAccessible::NativeAttributes()
 {
   nsCOMPtr<nsIPersistentProperties> attributes =
     AccessibleWrap::NativeAttributes();
 
   // 'formatting' attribute is deprecated, 'display' attribute should be
   // instead.
@@ -974,16 +1120,19 @@ HyperTextAccessible::NativeAttributes()
       strLineNumber.AppendInt(lineNumber);
       nsAccUtils::SetAccAttr(attributes, nsGkAtoms::lineNumber, strLineNumber);
     }
   }
 
   if (HasOwnContent())
     GetAccService()->MarkupAttributes(mContent, attributes);
 
+  if (mContent->IsMathMLElement())
+      SetMathMLXMLRoles(attributes);
+
   return attributes.forget();
 }
 
 nsIAtom*
 HyperTextAccessible::LandmarkRole() const
 {
   if (!HasOwnContent())
     return nullptr;
diff --git a/accessible/generic/HyperTextAccessible.h b/accessible/generic/HyperTextAccessible.h
--- a/accessible/generic/HyperTextAccessible.h
+++ b/accessible/generic/HyperTextAccessible.h
@@ -556,16 +556,22 @@ protected:
    * @param aStartOffset      [in, out] the start offset
    * @param aEndOffset        [in, out] the end offset
    * @param aAttributes       [out, optional] result attributes
    */
   void GetSpellTextAttr(nsINode* aNode, int32_t aNodeOffset,
                         uint32_t* aStartOffset, uint32_t* aEndOffset,
                         nsIPersistentProperties* aAttributes);
 
+  /**
+   * Set xml-roles attributes for MathML elements.
+   * @param aAttributes 
+   */
+  void SetMathMLXMLRoles(nsIPersistentProperties* aAttributes);
+
 private:
   /**
    * End text offsets array.
    */
   mutable nsTArray<uint32_t> mOffsets;
 };
 
 
diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -2334,16 +2334,29 @@ GK_ATOM(textUnderlineStyle, "text-underl
 GK_ATOM(timer, "timer")
 GK_ATOM(toolbarname, "toolbarname")
 GK_ATOM(toolbarseparator, "toolbarseparator")
 GK_ATOM(toolbarspacer, "toolbarspacer")
 GK_ATOM(toolbarspring, "toolbarspring")
 GK_ATOM(treegrid, "treegrid")
 GK_ATOM(_undefined, "undefined")
 GK_ATOM(xmlroles, "xml-roles")
+
+// MathML xml roles
+GK_ATOM(close_fence, "close-fence")
+GK_ATOM(denominator, "denominator")
+GK_ATOM(numerator, "numerator")
+GK_ATOM(open_fence, "open-fence")
+GK_ATOM(overscript, "overscript")
+GK_ATOM(presubscript, "presubscript")
+GK_ATOM(presuperscript, "presuperscript")
+GK_ATOM(root_index, "root-index")
+GK_ATOM(subscript, "subscript")
+GK_ATOM(superscript, "superscript")
+GK_ATOM(underscript, "underscript")
 #endif
 
 #ifdef MOZ_WEBSPEECH
 GK_ATOM(onaudiostart, "onaudiostart")
 GK_ATOM(onaudioend, "onaudioend")
 GK_ATOM(onsoundstart, "onsoundstart")
 GK_ATOM(onsoundend, "onsoundend")
 GK_ATOM(onspeechstart, "onspeechstart")
