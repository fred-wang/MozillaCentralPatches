# HG changeset patch
# Parent d0dd90ccf46332edc139ecfe86e0da70c6968977
# User Frédéric Wang <fred.wang@free.fr>
Part 3 - Use MATH constants for fractions and stacks. r=jfkthame, b=961365

diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -214,17 +214,25 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
   nsPresContext* presContext = PresContext();
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord defaultRuleThickness, axisHeight;
-  GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
+  nscoord oneDevPixel = fm->AppUnitsPerDevPixel();
+  gfxFont* mathFont = fm->GetThebesFontGroup()->GetFirstMathFont();
+  if (mathFont) {
+      mathFont->GetMathConstant(gfxFontEntry::FractionRuleThickness,
+                                oneDevPixel,
+                                defaultRuleThickness);
+  } else {
+    GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
+  }
   GetAxisHeight(aRenderingContext, fm, axisHeight);
 
   bool outermostEmbellished = false;
   if (mEmbellishData.coreFrame) {
     nsEmbellishData parentData;
     GetEmbellishDataFrom(mParent, parentData);
     outermostEmbellished = parentData.coreFrame != mEmbellishData.coreFrame;
   }
@@ -234,16 +242,18 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::linethickness_, value);
   mLineThickness = CalcLineThickness(presContext, mStyleContext, value,
                                      onePixel, defaultRuleThickness);
 
   // bevelled attribute
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::bevelled_, value);
   mIsBevelled = value.EqualsLiteral("true");
 
+  bool displayStyle = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK;
+
   if (!mIsBevelled) {
     mLineRect.height = mLineThickness;
 
     // by default, leave at least one-pixel padding at either end, and add
     // lspace & rspace that may come from <mo> if we are an outermost
     // embellished container (we fetch values from the core since they may use
     // units that depend on style data, and style changes could have occurred
     // in the core since our last visit there)
@@ -253,85 +263,122 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
       nsEmbellishData coreData;
       GetEmbellishDataFrom(mEmbellishData.coreFrame, coreData);
       leftSpace += StyleVisibility()->mDirection ?
                      coreData.trailingSpace : coreData.leadingSpace;
       rightSpace += StyleVisibility()->mDirection ?
                       coreData.leadingSpace : coreData.trailingSpace;
     }
 
+    nscoord actualRuleThickness =  mLineThickness;
+
     //////////////////
     // Get shifts
     nscoord numShift = 0;
     nscoord denShift = 0;
 
     // Rule 15b, App. G, TeXbook
     nscoord numShift1, numShift2, numShift3;
     nscoord denShift1, denShift2;
 
     GetNumeratorShifts(fm, numShift1, numShift2, numShift3);
     GetDenominatorShifts(fm, denShift1, denShift2);
-    if (StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK) {
-      // C > T
-      numShift = numShift1;
-      denShift = denShift1;
+
+    if (0 == actualRuleThickness) {
+      numShift = displayStyle ? numShift1 : numShift3;
+      denShift = displayStyle ? numShift1 : numShift2;
+      if (mathFont) {
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::StackTopDisplayStyleShiftUp :
+                                  gfxFontEntry::StackTopShiftUp,
+                                  oneDevPixel, numShift);
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::
+                                  StackBottomDisplayStyleShiftDown :
+                                  gfxFontEntry::StackBottomShiftDown,
+                                  oneDevPixel, denShift);
+      }
+    } else {
+      numShift = displayStyle ? denShift1 : denShift2;
+      denShift = displayStyle ? denShift1 : denShift2;
+      if (mathFont) {
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::
+                                  FractionNumeratorDisplayStyleShiftUp :
+                                  gfxFontEntry::FractionNumeratorShiftUp,
+                                  oneDevPixel, numShift);
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::
+                                  FractionDenominatorDisplayStyleShiftDown :
+                                  gfxFontEntry::FractionDenominatorShiftDown,
+                                  oneDevPixel, denShift);
+      }
     }
-    else {
-      numShift = (0 < mLineRect.height) ? numShift2 : numShift3;
-      denShift = denShift2;
-    }
-
-    nscoord minClearance = 0;
-    nscoord actualClearance = 0;
-
-    nscoord actualRuleThickness =  mLineThickness;
 
     if (0 == actualRuleThickness) {
       // Rule 15c, App. G, TeXbook
 
       // min clearance between numerator and denominator
-      minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
+      nscoord minClearance = displayStyle ?
         7 * defaultRuleThickness : 3 * defaultRuleThickness;
-      actualClearance =
+      if (mathFont) {
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::StackDisplayStyleGapMin :
+                                  gfxFontEntry::StackGapMin,
+                                  oneDevPixel, minClearance);
+      }
+      nscoord actualClearance =
         (numShift - bmNum.descent) - (bmDen.ascent - denShift);
       // actualClearance should be >= minClearance
       if (actualClearance < minClearance) {
         nscoord halfGap = (minClearance - actualClearance)/2;
         numShift += halfGap;
         denShift += halfGap;
       }
     }
     else {
     // Rule 15d, App. G, TeXbook
 
     // min clearance between numerator or denominator and middle of bar
 
     // TeX has a different interpretation of the thickness.
     // Try $a \above10pt b$ to see. Here is what TeX does:
-    // minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK
-    // ? 3 * actualRuleThickness : actualRuleThickness;
+    // minClearance = displayStyle ?
+    //   3 * actualRuleThickness : actualRuleThickness;
  
     // we slightly depart from TeX here. We use the defaultRuleThickness instead
     // of the value coming from the linethickness attribute, i.e., we recover what
     // TeX does if the user hasn't set linethickness. But when the linethickness
     // is set, we avoid the wide gap problem.
-     minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
-      3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      nscoord minClearanceNum = displayStyle ?
+        3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      nscoord minClearanceDen = minClearanceNum;
+      if (mathFont) {
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::FractionNumDisplayStyleGapMin :
+                                  gfxFontEntry::FractionNumeratorGapMin,
+                                  oneDevPixel, minClearanceNum);
+        mathFont->GetMathConstant(displayStyle ?
+                                  gfxFontEntry::
+                                  FractionDenomDisplayStyleGapMin :
+                                  gfxFontEntry::FractionDenominatorGapMin,
+                                  oneDevPixel, minClearanceDen);
+      }
 
-      // adjust numShift to maintain minClearance if needed
-      actualClearance =
+      // adjust numShift to maintain minClearanceNum if needed
+      nscoord actualClearanceNum =
         (numShift - bmNum.descent) - (axisHeight + actualRuleThickness/2);
-      if (actualClearance < minClearance) {
-        numShift += (minClearance - actualClearance);
+      if (actualClearanceNum < minClearanceNum) {
+        numShift += (minClearanceNum - actualClearanceNum);
       }
-      // adjust denShift to maintain minClearance if needed
-      actualClearance =
+      // adjust denShift to maintain minClearanceDen if needed
+      nscoord actualClearanceDen =
         (axisHeight - actualRuleThickness/2) - (bmDen.ascent - denShift);
-      if (actualClearance < minClearance) {
-        denShift += (minClearance - actualClearance);
+      if (actualClearanceDen < minClearanceDen) {
+        denShift += (minClearanceDen - actualClearanceDen);
       }
     }
 
     //////////////////
     // Place Children
 
     // XXX Need revisiting the width. TeX uses the exact width
     // e.g. in $$\huge\frac{\displaystyle\int}{i}$$
