# HG changeset patch
# Parent 965d117abeb443ee5d01242e5adc4b020ce641ee
# User Frédéric Wang <fred.wang@free.fr>
Part 3 - Use MATH constants for fractions and stacks. r=karl, b=961365

diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -215,16 +215,18 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord defaultRuleThickness, axisHeight;
   GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
+  GetMathConstantEm(fm, gfxFontEntry::FractionRuleThickness,
+                    defaultRuleThickness);
   GetAxisHeight(aRenderingContext, fm, axisHeight);
 
   bool outermostEmbellished = false;
   if (mEmbellishData.coreFrame) {
     nsEmbellishData parentData;
     GetEmbellishDataFrom(GetParent(), parentData);
     outermostEmbellished = parentData.coreFrame != mEmbellishData.coreFrame;
   }
@@ -234,16 +236,18 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::linethickness_, value);
   mLineThickness = CalcLineThickness(presContext, mStyleContext, value,
                                      onePixel, defaultRuleThickness);
 
   // bevelled attribute
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::bevelled_, value);
   mIsBevelled = value.EqualsLiteral("true");
 
+  bool displayStyle = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK;
+
   if (!mIsBevelled) {
     mLineRect.height = mLineThickness;
 
     // by default, leave at least one-pixel padding at either end, and add
     // lspace & rspace that may come from <mo> if we are an outermost
     // embellished container (we fetch values from the core since they may use
     // units that depend on style data, and style changes could have occurred
     // in the core since our last visit there)
@@ -253,85 +257,104 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
       nsEmbellishData coreData;
       GetEmbellishDataFrom(mEmbellishData.coreFrame, coreData);
       leftSpace += StyleVisibility()->mDirection ?
                      coreData.trailingSpace : coreData.leadingSpace;
       rightSpace += StyleVisibility()->mDirection ?
                       coreData.leadingSpace : coreData.trailingSpace;
     }
 
+    nscoord actualRuleThickness =  mLineThickness;
+
     //////////////////
     // Get shifts
     nscoord numShift = 0;
     nscoord denShift = 0;
 
     // Rule 15b, App. G, TeXbook
     nscoord numShift1, numShift2, numShift3;
     nscoord denShift1, denShift2;
 
     GetNumeratorShifts(fm, numShift1, numShift2, numShift3);
     GetDenominatorShifts(fm, denShift1, denShift2);
-    if (StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK) {
-      // C > T
-      numShift = numShift1;
-      denShift = denShift1;
+
+    if (0 == actualRuleThickness) {
+      numShift = displayStyle ? numShift1 : numShift3;
+      denShift = displayStyle ? numShift1 : numShift2;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::StackTopDisplayStyleShiftUp :
+                        gfxFontEntry::StackTopShiftUp, numShift);
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::StackBottomDisplayStyleShiftDown :
+                        gfxFontEntry::StackBottomShiftDown, denShift);
+    } else {
+      numShift = displayStyle ? denShift1 : denShift2;
+      denShift = displayStyle ? denShift1 : denShift2;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionNumeratorDisplayStyleShiftUp :
+                        gfxFontEntry::FractionNumeratorShiftUp, numShift);
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionDenominatorDisplayStyleShiftDown :
+                        gfxFontEntry::FractionDenominatorShiftDown, denShift);
     }
-    else {
-      numShift = (0 < mLineRect.height) ? numShift2 : numShift3;
-      denShift = denShift2;
-    }
-
-    nscoord minClearance = 0;
-    nscoord actualClearance = 0;
-
-    nscoord actualRuleThickness =  mLineThickness;
 
     if (0 == actualRuleThickness) {
       // Rule 15c, App. G, TeXbook
 
       // min clearance between numerator and denominator
-      minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
+      nscoord minClearance = displayStyle ?
         7 * defaultRuleThickness : 3 * defaultRuleThickness;
-      actualClearance =
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::StackDisplayStyleGapMin :
+                        gfxFontEntry::StackGapMin, minClearance);
+      nscoord actualClearance =
         (numShift - bmNum.descent) - (bmDen.ascent - denShift);
       // actualClearance should be >= minClearance
       if (actualClearance < minClearance) {
         nscoord halfGap = (minClearance - actualClearance)/2;
         numShift += halfGap;
         denShift += halfGap;
       }
     }
     else {
     // Rule 15d, App. G, TeXbook
 
     // min clearance between numerator or denominator and middle of bar
 
     // TeX has a different interpretation of the thickness.
     // Try $a \above10pt b$ to see. Here is what TeX does:
-    // minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK
-    // ? 3 * actualRuleThickness : actualRuleThickness;
+    // minClearance = displayStyle ?
+    //   3 * actualRuleThickness : actualRuleThickness;
  
     // we slightly depart from TeX here. We use the defaultRuleThickness instead
     // of the value coming from the linethickness attribute, i.e., we recover what
     // TeX does if the user hasn't set linethickness. But when the linethickness
     // is set, we avoid the wide gap problem.
-     minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
-      3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      nscoord minClearanceNum = displayStyle ?
+        3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionNumDisplayStyleGapMin :
+                        gfxFontEntry::FractionNumeratorGapMin, minClearanceNum);
+      nscoord minClearanceDen = minClearanceNum;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionDenomDisplayStyleGapMin :
+                        gfxFontEntry::FractionDenominatorGapMin,
+                        minClearanceDen);
 
-      // adjust numShift to maintain minClearance if needed
-      actualClearance =
+      // adjust numShift to maintain minClearanceNum if needed
+      nscoord actualClearanceNum =
         (numShift - bmNum.descent) - (axisHeight + actualRuleThickness/2);
-      if (actualClearance < minClearance) {
-        numShift += (minClearance - actualClearance);
+      if (actualClearanceNum < minClearanceNum) {
+        numShift += (minClearanceNum - actualClearanceNum);
       }
-      // adjust denShift to maintain minClearance if needed
-      actualClearance =
+      // adjust denShift to maintain minClearanceDen if needed
+      nscoord actualClearanceDen =
         (axisHeight - actualRuleThickness/2) - (bmDen.ascent - denShift);
-      if (actualClearance < minClearance) {
-        denShift += (minClearance - actualClearance);
+      if (actualClearanceDen < minClearanceDen) {
+        denShift += (minClearanceDen - actualClearanceDen);
       }
     }
 
     //////////////////
     // Place Children
 
     // XXX Need revisiting the width. TeX uses the exact width
     // e.g. in $$\huge\frac{\displaystyle\int}{i}$$
