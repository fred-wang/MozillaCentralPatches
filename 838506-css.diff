# HG changeset patch
# Parent 768367ccf49785b4d65ce4ac5820ba5b42ed0870
# User Frédéric Wang <fred.wang@free.fr>
Refactor implementation of displaystyle - part 1: add a -moz-display-style property. b=838506, r=heycam

diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -6701,18 +6701,21 @@ CSSParserImpl::ParseSingleValueProperty(
   uint32_t variant = nsCSSProps::ParserVariant(aPropID);
   if (variant == 0) {
     NS_ABORT_IF_FALSE(false, "not a single value property");
     return false;
   }
 
   // We only allow 'script-level' when unsafe rules are enabled, because
   // otherwise it could interfere with rulenode optimizations if used in
-  // a non-MathML-enabled document.
-  if (aPropID == eCSSProperty_script_level && !mUnsafeRulesEnabled)
+  // a non-MathML-enabled document. We also only allow display-style when
+  // unsafe rules are enabled.
+  if (!mUnsafeRulesEnabled &&
+      (aPropID == eCSSProperty_script_level ||
+       aPropID == eCSSProperty_display_style))
     return false;
 
   const int32_t *kwtable = nsCSSProps::kKeywordTableTable[aPropID];
   switch (nsCSSProps::ValueRestrictions(aPropID)) {
     default:
       NS_ABORT_IF_FALSE(false, "should not be reached");
     case 0:
       return ParseVariant(aValue, variant, kwtable);
diff --git a/layout/style/nsCSSPropList.h b/layout/style/nsCSSPropList.h
--- a/layout/style/nsCSSPropList.h
+++ b/layout/style/nsCSSPropList.h
@@ -3320,19 +3320,20 @@ CSS_PROP_FONT(
     -moz-script-level,
     script_level,
     ScriptLevel,
     // REVIEW: no range restriction?
     // NOTE: CSSParserImpl::ParseSingleValueProperty only accepts this
     // property when mUnsafeRulesEnabled is set.
     CSS_PROPERTY_PARSE_VALUE,
     "",
-    // script-level can take Integer or Number values, but only Integer
+    // script-level can take Auto, Integer and Number values, but only Auto
+    // ("increment if parent is not in displaystyle") and Integer
     // ("relative") values can be specified in a style sheet.
-    VARIANT_HI,
+    VARIANT_AHI,
     nullptr,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
 CSS_PROP_FONT(
     -moz-script-size-multiplier,
     script_size_multiplier,
     ScriptSizeMultiplier,
     // REVIEW: no range restriction?
@@ -3358,16 +3359,28 @@ CSS_PROP_FONT(
     math_variant,
     MathVariant,
     CSS_PROPERTY_PARSE_INACCESSIBLE,
     "",
     VARIANT_HK,
     kMathVariantKTable,
     CSS_PROP_NO_OFFSET,
     eStyleAnimType_None)
+CSS_PROP_FONT(
+    -moz-display-style,
+    display_style,
+    DisplayStyle,
+    // NOTE: CSSParserImpl::ParseSingleValueProperty only accepts this
+    // property when mUnsafeRulesEnabled is set.
+    CSS_PROPERTY_PARSE_VALUE,
+    "",
+    VARIANT_HK,
+    kDisplayStyleKTable,
+    CSS_PROP_NO_OFFSET,
+    eStyleAnimType_None)
 #endif // !defined(CSS_PROP_LIST_EXCLUDE_INTERNAL)
 #endif // !defined(CSS_PROP_LIST_ONLY_COMPONENTS_OF_ALL_SHORTHAND)
 
 CSS_PROP_SVGRESET(
     clip-path,
     clip_path,
     ClipPath,
     CSS_PROPERTY_PARSE_VALUE,
diff --git a/layout/style/nsCSSProps.cpp b/layout/style/nsCSSProps.cpp
--- a/layout/style/nsCSSProps.cpp
+++ b/layout/style/nsCSSProps.cpp
@@ -1288,16 +1288,22 @@ const int32_t nsCSSProps::kMathVariantKT
   eCSSKeyword_monospace, NS_MATHML_MATHVARIANT_MONOSPACE,
   eCSSKeyword_initial, NS_MATHML_MATHVARIANT_INITIAL,
   eCSSKeyword_tailed, NS_MATHML_MATHVARIANT_TAILED,
   eCSSKeyword_looped, NS_MATHML_MATHVARIANT_LOOPED,
   eCSSKeyword_stretched, NS_MATHML_MATHVARIANT_STRETCHED,
   eCSSKeyword_UNKNOWN,-1
 };
 
+const int32_t nsCSSProps::kDisplayStyleKTable[] = {
+  eCSSKeyword_none, NS_MATHML_DISPLAYSTYLE_NONE,
+  eCSSKeyword_true, NS_MATHML_DISPLAYSTYLE_TRUE,
+  eCSSKeyword_UNKNOWN,-1
+};
+
 const int32_t nsCSSProps::kContextOpacityKTable[] = {
   eCSSKeyword_context_fill_opacity, NS_STYLE_CONTEXT_FILL_OPACITY,
   eCSSKeyword_context_stroke_opacity, NS_STYLE_CONTEXT_STROKE_OPACITY,
   eCSSKeyword_UNKNOWN,-1
 };
 
 const int32_t nsCSSProps::kContextPatternKTable[] = {
   eCSSKeyword_context_fill, NS_COLOR_CONTEXT_FILL,
diff --git a/layout/style/nsCSSProps.h b/layout/style/nsCSSProps.h
--- a/layout/style/nsCSSProps.h
+++ b/layout/style/nsCSSProps.h
@@ -504,16 +504,17 @@ public:
   static const int32_t kImageOrientationKTable[];
   static const int32_t kImageOrientationFlipKTable[];
   static const int32_t kIMEModeKTable[];
   static const int32_t kLineHeightKTable[];
   static const int32_t kListStylePositionKTable[];
   static const int32_t kListStyleKTable[];
   static const int32_t kMaskTypeKTable[];
   static const int32_t kMathVariantKTable[];
+  static const int32_t kDisplayStyleKTable[];
   static const int32_t kContextOpacityKTable[];
   static const int32_t kContextPatternKTable[];
   static const int32_t kOrientKTable[];
   static const int32_t kOutlineStyleKTable[];
   static const int32_t kOutlineColorKTable[];
   static const int32_t kOverflowKTable[];
   static const int32_t kOverflowSubKTable[];
   static const int32_t kPageBreakKTable[];
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -1830,17 +1830,18 @@ static const CheckCallbackFn gCheckCallb
 #ifdef DEBUG
 static bool
 AreAllMathMLPropertiesUndefined(const nsRuleData* aRuleData)
 {
   return
     aRuleData->ValueForScriptLevel()->GetUnit() == eCSSUnit_Null &&
     aRuleData->ValueForScriptSizeMultiplier()->GetUnit() == eCSSUnit_Null &&
     aRuleData->ValueForScriptMinSize()->GetUnit() == eCSSUnit_Null &&
-    aRuleData->ValueForMathVariant()->GetUnit() == eCSSUnit_Null;
+    aRuleData->ValueForMathVariant()->GetUnit() == eCSSUnit_Null &&
+    aRuleData->ValueForDisplayStyle()->GetUnit() == eCSSUnit_Null;
 }
 #endif
 
 inline nsRuleNode::RuleDetail
 nsRuleNode::CheckSpecifiedProperties(const nsStyleStructID aSID,
                                      const nsRuleData* aRuleData)
 {
   // Build a count of the:
@@ -1880,23 +1881,23 @@ nsRuleNode::CheckSpecifiedProperties(con
    * Return the most specific information we can: prefer None or Full
    * over Partial, and Reset or Inherited over Mixed, since we can
    * optimize based on the edge cases and not the in-between cases.
    */
   nsRuleNode::RuleDetail result;
   if (inherited == total)
     result = eRuleFullInherited;
   else if (specified == total
-           // MathML defines 4 properties in Font that will never be set when
+           // MathML defines 5 properties in Font that will never be set when
            // MathML is not in use. Therefore if all but four
            // properties have been set, and MathML is not enabled, we can treat
            // this as fully specified. Code in nsMathMLElementFactory will
            // rebuild the rule tree and style data when MathML is first enabled
            // (see nsMathMLElement::BindToTree).
-           || (aSID == eStyleStruct_Font && specified + 4 == total &&
+           || (aSID == eStyleStruct_Font && specified + 5 == total &&
                !mPresContext->Document()->GetMathMLEnabled())
           ) {
     if (inherited == 0)
       result = eRuleFullReset;
     else
       result = eRuleFullMixed;
   } else if (specified == 0)
     result = eRuleNone;
@@ -3250,16 +3251,23 @@ nsRuleNode::SetFont(nsPresContext* aPres
 
   // -moz-math-variant: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForMathVariant(), aFont->mMathVariant,
               aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               aParentFont->mMathVariant, NS_MATHML_MATHVARIANT_NONE,
               0, 0, 0, 0);
 
+  // -moz-display-style: enum, inherit, initial
+  SetDiscrete(*aRuleData->ValueForDisplayStyle(), aFont->mDisplayStyle,
+              aCanStoreInRuleTree,
+              SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
+              aParentFont->mDisplayStyle, NS_MATHML_DISPLAYSTYLE_NONE,
+              0, 0, 0, 0);
+
   // font-smoothing: enum, inherit, initial
   SetDiscrete(*aRuleData->ValueForOSXFontSmoothing(),
               aFont->mFont.smoothing, aCanStoreInRuleTree,
               SETDSC_ENUMERATED | SETDSC_UNSET_INHERIT,
               aParentFont->mFont.smoothing,
               defaultVariableFont->smoothing,
               0, 0, 0, 0);
 
@@ -3365,16 +3373,22 @@ nsRuleNode::SetFont(nsPresContext* aPres
   if (eCSSUnit_Integer == scriptLevelValue->GetUnit()) {
     // "relative"
     aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel + scriptLevelValue->GetIntValue());
   }
   else if (eCSSUnit_Number == scriptLevelValue->GetUnit()) {
     // "absolute"
     aFont->mScriptLevel = ClampTo8Bit(int32_t(scriptLevelValue->GetFloatValue()));
   }
+  else if (eCSSUnit_Auto == scriptLevelValue->GetUnit()) {
+    // auto
+    aFont->mScriptLevel = ClampTo8Bit(aParentFont->mScriptLevel +
+                                      (aParentFont->mDisplayStyle ==
+                                       NS_MATHML_DISPLAYSTYLE_NONE ? 1 : 0));
+  }
   else if (eCSSUnit_Inherit == scriptLevelValue->GetUnit() ||
            eCSSUnit_Unset == scriptLevelValue->GetUnit()) {
     aCanStoreInRuleTree = false;
     aFont->mScriptLevel = aParentFont->mScriptLevel;
   }
   else if (eCSSUnit_Initial == scriptLevelValue->GetUnit()) {
     aFont->mScriptLevel = 0;
   }
diff --git a/layout/style/nsStyleConsts.h b/layout/style/nsStyleConsts.h
--- a/layout/style/nsStyleConsts.h
+++ b/layout/style/nsStyleConsts.h
@@ -536,16 +536,20 @@ static inline mozilla::css::Side operato
 #define NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC       12
 #define NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC  13
 #define NS_MATHML_MATHVARIANT_MONOSPACE               14
 #define NS_MATHML_MATHVARIANT_INITIAL                 15
 #define NS_MATHML_MATHVARIANT_TAILED                  16
 #define NS_MATHML_MATHVARIANT_LOOPED                  17
 #define NS_MATHML_MATHVARIANT_STRETCHED               18
 
+// See nsStyleFont
+#define NS_MATHML_DISPLAYSTYLE_NONE             0
+#define NS_MATHML_DISPLAYSTYLE_TRUE             1
+
 // See nsStylePosition::mWidth, mMinWidth, mMaxWidth
 #define NS_STYLE_WIDTH_MAX_CONTENT              0
 #define NS_STYLE_WIDTH_MIN_CONTENT              1
 #define NS_STYLE_WIDTH_FIT_CONTENT              2
 #define NS_STYLE_WIDTH_AVAILABLE                3
 
 // See nsStylePosition.mPosition
 #define NS_STYLE_POSITION_STATIC                0
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -76,17 +76,19 @@ nsInitialStyleRule::MapRuleInfoInto(nsRu
           size_t index = value - value_start;
           if (index == nsCSSProps::PropertyIndexInStruct(
                           eCSSProperty_script_level) ||
               index == nsCSSProps::PropertyIndexInStruct(
                           eCSSProperty_script_size_multiplier) ||
               index == nsCSSProps::PropertyIndexInStruct(
                           eCSSProperty_script_min_size) ||
               index == nsCSSProps::PropertyIndexInStruct(
-                          eCSSProperty_math_variant)) {
+                          eCSSProperty_math_variant) ||
+              index == nsCSSProps::PropertyIndexInStruct(
+                          eCSSProperty_display_style)) {
             continue;
           }
         }
         if (value->GetUnit() == eCSSUnit_Null) {
           value->SetInitialValue();
         }
       }
     }
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -97,16 +97,17 @@ nsStyleFont::nsStyleFont(const nsFont& a
 }
 
 nsStyleFont::nsStyleFont(const nsStyleFont& aSrc)
   : mFont(aSrc.mFont)
   , mSize(aSrc.mSize)
   , mGenericID(aSrc.mGenericID)
   , mScriptLevel(aSrc.mScriptLevel)
   , mMathVariant(aSrc.mMathVariant)
+  , mDisplayStyle(aSrc.mDisplayStyle)
   , mExplicitLanguage(aSrc.mExplicitLanguage)
   , mAllowZoom(aSrc.mAllowZoom)
   , mScriptUnconstrainedSize(aSrc.mScriptUnconstrainedSize)
   , mScriptMinSize(aSrc.mScriptMinSize)
   , mScriptSizeMultiplier(aSrc.mScriptSizeMultiplier)
   , mLanguage(aSrc.mLanguage)
 {
   MOZ_COUNT_CTOR(nsStyleFont);
@@ -128,16 +129,17 @@ nsStyleFont::Init(nsPresContext* aPresCo
 {
   mSize = mFont.size = nsStyleFont::ZoomText(aPresContext, mFont.size);
   mScriptUnconstrainedSize = mSize;
   mScriptMinSize = aPresContext->CSSTwipsToAppUnits(
       NS_POINTS_TO_TWIPS(NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT));
   mScriptLevel = 0;
   mScriptSizeMultiplier = NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER;
   mMathVariant = NS_MATHML_MATHVARIANT_NONE;
+  mDisplayStyle = NS_MATHML_DISPLAYSTYLE_NONE;
   mAllowZoom = true;
 
   nsAutoString language;
   aPresContext->Document()->GetContentLanguage(language);
   language.StripWhitespace();
 
   // Content-Language may be a comma-separated list of language codes,
   // in which case the HTML5 spec says to treat it as unknown
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -98,16 +98,18 @@ public:
                         // getComputedStyle() for example.
   uint8_t mGenericID;   // [inherited] generic CSS font family, if any;
                         // value is a kGenericFont_* constant, see nsFont.h.
 
   // MathML scriptlevel support
   int8_t  mScriptLevel;          // [inherited]
   // MathML  mathvariant support
   uint8_t mMathVariant;          // [inherited]
+  // MathML displaystyle support
+  uint8_t mDisplayStyle;         // [inherited]
 
   // was mLanguage set based on a lang attribute in the document?
   bool mExplicitLanguage;        // [inherited]
 
   // should calls to ZoomText() and UnZoomText() be made to the font
   // size on this nsStyleFont?
   bool mAllowZoom;               // [inherited]
 
diff --git a/layout/style/test/ListCSSProperties.cpp b/layout/style/test/ListCSSProperties.cpp
--- a/layout/style/test/ListCSSProperties.cpp
+++ b/layout/style/test/ListCSSProperties.cpp
@@ -142,17 +142,18 @@ const char *gInaccessibleProperties[] = 
     "padding-start-value",
     "padding-left-ltr-source",
     "padding-left-rtl-source",
     "padding-right-ltr-source",
     "padding-right-rtl-source",
     "-moz-script-level", // parsed by UA sheets only
     "-moz-script-size-multiplier",
     "-moz-script-min-size",
-    "-moz-math-variant"
+    "-moz-math-variant",
+    "-moz-display-style" // parsed by UA sheets only
 };
 
 inline int
 is_inaccessible(const char* aPropName)
 {
     for (unsigned j = 0; j < ARRAY_LENGTH(gInaccessibleProperties); ++j) {
         if (strcmp(aPropName, gInaccessibleProperties[j]) == 0)
             return 1;
