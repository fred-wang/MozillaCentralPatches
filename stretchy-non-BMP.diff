# HG changeset patch
# Parent b4853955fc754787bf400a6a2f24689f7647895f
# User Frédéric Wang <fred.wang@free.fr>
Support for non-BMP stretchy operators (bug 407439). r=karlt

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -69,17 +69,17 @@
 #include "nsMathMLOperators.h"
 #include "nsMathMLChar.h"
 
 //#define SHOW_BORDERS 1
 //#define NOISY_SEARCH 1
 
 // -----------------------------------------------------------------------------------
 static const PRUnichar   kSpaceCh   = PRUnichar(' ');
-static const nsGlyphCode kNullGlyph = {0, 0};
+static const nsGlyphCode kNullGlyph = {{0, 0}, 0};
 typedef enum {eExtension_base, eExtension_variants, eExtension_parts}
   nsMathfontPrefExtension;
 
 // -----------------------------------------------------------------------------------
 // nsGlyphTable is a class that provides an interface for accessing glyphs
 // of stretchy chars. It acts like a table that stores the variants of bigger
 // sizes (if any) and the partial glyphs needed to build extensible symbols.
 // An instance of nsGlyphTable is associated to one primary font. Extra glyphs
@@ -243,18 +243,18 @@ private:
   // that char. For a property line 'key = value' in the MathFont Property File,
   // mCharCache will retain the 'key' -- which is a Unicode point, while mGlyphCache
   // will retain the 'value', which is a consecutive list of nsGlyphCodes, i.e.,
   // the pairs of 'code@font' needed by the char -- in which 'code@0' can be specified
   // without the optional '@0'. However, to ease subsequent processing, mGlyphCache
   // excludes the '@' symbol and explicitly inserts all optional '0' that indicates
   // the primary font identifier. Specifically therefore, the k-th glyph is
   // characterized by :
-  // 1) mGlyphCache[2*k] : its Unicode point (or glyph index -- depending on mType),
-  // 2) mGlyphCache[2*k+1] : the numeric identifier of the font where it comes from.
+  // 1) mGlyphCache[3*k],mGlyphCache[3*k+1] : its Unicode point (or glyph index -- depending on mType),
+  // 2) mGlyphCache[3*k+2] : the numeric identifier of the font where it comes from.
   // A font identifier of '0' means the default primary font associated to this
   // table. Other digits map to the "external" fonts that may have been specified
   // in the MathFont Property File.
   nsString  mGlyphCache;
   PRUnichar mCharCache;
 };
 
 nsGlyphCode
@@ -306,26 +306,26 @@ nsGlyphTable::ElementAt(nsPresContext* a
     nsAutoString value;
     nsresult rv = mGlyphProperties->GetStringProperty(nsDependentCString(key), value);
     if (NS_FAILED(rv)) return kNullGlyph;
     Clean(value);
     // See if this char uses external fonts; e.g., if the 2nd glyph is taken from the
     // external font '1', the property line looks like \uNNNN = \uNNNN\uNNNN@1\uNNNN.
     // This is where mGlyphCache is pre-processed to explicitly store all glyph codes
     // as combined pairs of 'code@font', excluding the '@' separator. This means that
-    // mGlyphCache[2*k] will later be rendered with mFontName[mGlyphCache[2*k+1]]
+    // mGlyphCache[3*k],mGlyphCache[3*k+1] will later be rendered with mFontName[mGlyphCache[3*k+2]]
     // Note: font identifier is internally an ASCII digit to avoid the null char issue
     nsAutoString buffer;
     PRInt32 length = value.Length();
     PRInt32 i = 0; // index in value
     PRInt32 j = 0; // part/variant index
     while (i < length) {
       PRUnichar code = value[i];
       ++i;
-      PRUnichar font = 0;
+      buffer.Append(code);
       // see if we are at the beginning of a child char
       if (code == kSpaceCh) {
         // reset the annotation indicator to be 0 for the next code point
         j = -1;
       }
 #if 0 // If we want this then the nsGlyphTableList must be declared
       // or the UnicodeTable could be made a global.
       // See if this code point is an *indirect reference* to the Unicode
@@ -341,33 +341,43 @@ nsGlyphTable::ElementAt(nsPresContext* a
         ++i;
         // Need to implement this if we want it:
         // Set (new) code from the value[i] position for (current) code.
         if (1)
           return kNullGlyph;
         ++i;
       }
 #endif
+      // Read the next word, if we have a non-BMP character.
+      if (i < length &&
+          PRUnichar(0xD800) <= code && code <= PRUnichar(0xDBFF)) {
+        code = value[i];
+        ++i;
+      } else {
+        code = PRUnichar('\0');
+      }
+      buffer.Append(code);
+
       // See if an external font is needed for the code point.
       // Limit of 9 external fonts
+      PRUnichar font = 0;
       if (i+1 < length && value[i] == PRUnichar('@') &&
           value[i+1] >= PRUnichar('0') && value[i+1] <= PRUnichar('9')) {
         ++i;
         font = value[i] - '0';
         ++i;
         if (font >= mFontName.Length()) {
           NS_ERROR("Nonexistent font referenced in glyph table");
           return kNullGlyph;
         }
         // The char cannot be handled if this font is not installed
         if (!mFontName[font].Length()) {
           return kNullGlyph;
         }
       }
-      buffer.Append(code);
       buffer.Append(font);
       ++j;
     }
     // update our cache with the new settings
     mGlyphCache.Assign(buffer);
     mCharCache = uchar;
   }
 
@@ -385,38 +395,40 @@ nsGlyphTable::ElementAt(nsPresContext* a
   PRUint32 length = mGlyphCache.Length();
   if (aChar->mParent) {
     nsMathMLChar* child = aChar->mParent->mSibling;
     // XXXkt composite chars can't have size variants
     while (child && (child != aChar)) {
       offset += 5; // skip the 4 partial glyphs + the whitespace separator
       child = child->mSibling;
     }
-    length = 2*(offset + 4); // stay confined in the 4 partial glyphs of this child
+    length = 3*(offset + 4); // stay confined in the 4 partial glyphs of this child
   }
-  PRUint32 index = 2*(offset + aPosition); // 2* is to account for the code@font pairs
-  if (index+1 >= length) return kNullGlyph;
+  PRUint32 index = 3*(offset + aPosition); // 3* is to account for the code@font pairs
+  if (index+2 >= length) return kNullGlyph;
   nsGlyphCode ch;
-  ch.code = mGlyphCache.CharAt(index);
-  ch.font = mGlyphCache.CharAt(index + 1);
-  return (ch.code == PRUnichar(0xFFFD)) ? kNullGlyph : ch;
+  ch.code[0] = mGlyphCache.CharAt(index);
+  ch.code[1] = mGlyphCache.CharAt(index + 1);
+  ch.font = mGlyphCache.CharAt(index + 2);
+  return (ch.code[0] == PRUnichar(0xFFFD) &&
+          ch.Length() == 1) ? kNullGlyph : ch;
 }
 
 PRBool
 nsGlyphTable::IsComposite(nsPresContext* aPresContext, nsMathMLChar* aChar)
 {
   // there is only one level of recursion in our model. a child
   // cannot be composite because it cannot have its own children
   if (aChar->mParent) return PR_FALSE;
   // shortcut to sync the cache with this char...
   mCharCache = 0; mGlyphCache.Truncate(); ElementAt(aPresContext, aChar, 0);
   // the cache remained empty if the char wasn't found in this table
-  if (8 >= mGlyphCache.Length()) return PR_FALSE;
+  if (4*3 >= mGlyphCache.Length()) return PR_FALSE;
   // the lists of glyphs of a composite char are space-separated
-  return (kSpaceCh == mGlyphCache.CharAt(8));
+  return (kSpaceCh == mGlyphCache.CharAt(4*3));
 }
 
 PRInt32
 nsGlyphTable::ChildCountOf(nsPresContext* aPresContext, nsMathMLChar* aChar)
 {
   // this will sync the cache as well ...
   if (!IsComposite(aPresContext, aChar)) return 0;
   // the lists of glyphs of a composite char are space-separated
@@ -1147,21 +1159,23 @@ nsMathMLChar::StretchEnumContext::TryVar
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
     SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
                   font, aGlyphTable, ch, aFamily);
 
-    NS_ASSERTION(maxWidth || ch.code != mChar->mGlyph.code ||
+    NS_ASSERTION(maxWidth || ch.code[0] != mChar->mGlyph.code[0] ||
+                 ch.code[1] != mChar->mGlyph.code[1] ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
-    nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(&ch.code, 1);
+    nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
+                                                                ch.Length());
     nscoord charSize =
       isVertical ? bm.ascent + bm.descent
       : bm.rightBearing - bm.leftBearing;
 
     if (largeopOnly ||
         IsSizeBetter(charSize, bestSize, mTargetSize, mStretchHint)) {
       mGlyphFound = PR_TRUE;
       if (maxWidth) {
@@ -1269,17 +1283,18 @@ nsMathMLChar::StretchEnumContext::TryPar
     if (!ch.Exists()) {
       // Null glue indicates that a rule will be drawn, which can stretch to
       // fill any space.  Leave bounding metrics at 0.
       sizedata[i] = mTargetSize;
     }
     else {
       SetFontFamily(mChar->mStyleContext->PresContext(), mRenderingContext,
                     font, aGlyphTable, ch, aFamily);
-      nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(&ch.code, 1);
+      nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
+                                                                  ch.Length());
 
       // TODO: For the generic Unicode table, ideally we should check that the
       // glyphs are actually found and that they each come from the same
       // font.
       bmdata[i] = bm;
       sizedata[i] = isVertical ? bm.ascent + bm.descent
                                : bm.rightBearing - bm.leftBearing;
     }
@@ -2081,17 +2096,18 @@ nsMathMLChar::PaintForeground(nsPresCont
     aRenderingContext.DrawString(mData.get(), len, 0, mUnscaledAscent);
   }
   else {
     // Grab some metrics to adjust the placements ...
     // if there is a glyph of appropriate size, paint that glyph
     if (mGlyph.Exists()) {
 //printf("Painting %04X with a glyph of appropriate size\n", mData[0]);
 //aRenderingContext.SetColor(NS_RGB(0,0,255));
-      aRenderingContext.DrawString(&mGlyph.code, 1, 0, mUnscaledAscent);
+      aRenderingContext.DrawString(mGlyph.code, mGlyph.Length(),
+                                   0, mUnscaledAscent);
     }
     else { // paint by parts
 //aRenderingContext.SetColor(NS_RGB(0,255,0));
       if (NS_STRETCH_DIRECTION_VERTICAL == mDirection)
         PaintVertically(aPresContext, aRenderingContext, theFont, styleContext,
                         mGlyphTable, r);
       else if (NS_STRETCH_DIRECTION_HORIZONTAL == mDirection)
         PaintHorizontally(aPresContext, aRenderingContext, theFont, styleContext,
@@ -2171,17 +2187,17 @@ nsMathMLChar::PaintVertically(nsPresCont
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0
     if (ch.Exists()) {
       SetFontFamily(aPresContext, aRenderingContext,
                     aFont, aGlyphTable, ch, mFamily);
-      bmdata[i] = aRenderingContext.GetBoundingMetrics(&ch.code, 1);
+      bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
     }
     chdata[i] = ch;
     ++i;
   }
   nscoord dx = aRect.x;
   nscoord offset[3], start[3], end[3];
   nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
   for (i = 0; i <= bottom; ++i) {
@@ -2256,17 +2272,17 @@ nsMathMLChar::PaintVertically(nsPresCont
           clipRect.y = start[i];
           clipRect.height = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
         SetFontFamily(aPresContext, aRenderingContext,
                       aFont, aGlyphTable, ch, mFamily);
-        aRenderingContext.DrawString(&ch.code, 1, dx, dy);
+        aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
       }
     }
   }
 
   ///////////////
   // fill the gap between top and middle, and between middle and bottom.
   if (!chGlue.Exists()) { // null glue : draw a rule
     // figure out the dimensions of the rule to be drawn :
@@ -2332,17 +2348,17 @@ nsMathMLChar::PaintVertically(nsPresCont
       aRenderingContext.DrawRect(clipRect);
       {
 #endif
       while (dy < fillEnd) {
         clipRect.y = dy;
         clipRect.height = NS_MIN(bm.ascent + bm.descent, fillEnd - dy);
         AutoPushClipRect clip(aRenderingContext, clipRect);
         dy += bm.ascent;
-        aRenderingContext.DrawString(&chGlue.code, 1, dx, dy);
+        aRenderingContext.DrawString(chGlue.code, chGlue.Length(), dx, dy);
         dy += bm.descent;
       }
 #ifdef SHOW_BORDERS
       }
       // last glyph that may cross past its boundary and collide with the next
       nscoord height = bm.ascent + bm.descent;
       aRenderingContext.SetColor(NS_RGB(0,255,0));
       aRenderingContext.DrawRect(nsRect(dx, dy-bm.ascent, aRect.width, height));
@@ -2399,17 +2415,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
     // if (!ch.Exists()) glue is null, leave bounding metrics at 0.
     if (ch.Exists()) {
       SetFontFamily(aPresContext, aRenderingContext,
                     aFont, aGlyphTable, ch, mFamily);
-      bmdata[i] = aRenderingContext.GetBoundingMetrics(&ch.code, 1);
+      bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
     }
     chdata[i] = ch;
     ++i;
   }
   nscoord dy = aRect.y + mBoundingMetrics.ascent;
   nscoord offset[3], start[3], end[3];
   nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
   for (i = 0; i <= right; ++i) {
@@ -2479,17 +2495,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
           clipRect.x = start[i];
           clipRect.width = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
         AutoPushClipRect clip(aRenderingContext, clipRect);
         SetFontFamily(aPresContext, aRenderingContext,
                       aFont, aGlyphTable, ch, mFamily);
-        aRenderingContext.DrawString(&ch.code, 1, dx, dy);
+        aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
       }
     }
   }
 
   ////////////////
   // fill the gap between left and middle, and between middle and right.
   if (!chGlue.Exists()) { // null glue : draw a rule
     // figure out the dimensions of the rule to be drawn :
@@ -2554,17 +2570,17 @@ nsMathMLChar::PaintHorizontally(nsPresCo
       aRenderingContext.DrawRect(clipRect);
       {
 #endif
       while (dx < fillEnd) {
         clipRect.x = dx;
         clipRect.width = NS_MIN(bm.rightBearing - bm.leftBearing, fillEnd - dx);
         AutoPushClipRect clip(aRenderingContext, clipRect);
         dx -= bm.leftBearing;
-        aRenderingContext.DrawString(&chGlue.code, 1, dx, dy);
+        aRenderingContext.DrawString(chGlue.code, chGlue.Length(), dx, dy);
         dx += bm.rightBearing;
       }
 #ifdef SHOW_BORDERS
       }
       // last glyph that may cross past its boundary and collide with the next
       nscoord width = bm.rightBearing - bm.leftBearing;
       aRenderingContext.SetColor(NS_RGB(0,255,0));
       aRenderingContext.DrawRect(nsRect(dx + bm.leftBearing, aRect.y, width, aRect.height));
diff --git a/layout/mathml/nsMathMLChar.h b/layout/mathml/nsMathMLChar.h
--- a/layout/mathml/nsMathMLChar.h
+++ b/layout/mathml/nsMathMLChar.h
@@ -66,26 +66,28 @@ enum {
   NS_STRETCH_MAXWIDTH = 0x40
 };
 
 // A single glyph in our internal representation is characterized by a 'code@font' 
 // pair. The 'code' is interpreted as a Unicode point or as the direct glyph index
 // (depending on the type of nsGlyphTable where this comes from). The 'font' is a
 // numeric identifier given to the font to which the glyph belongs.
 struct nsGlyphCode {
-  PRUnichar code; 
+  PRUnichar code[2]; 
   PRInt32   font;
 
+  PRInt32 Length() { return (code[1] == PRUnichar('\0') ? 1 : 2); }
   PRBool Exists() const
   {
-    return (code != 0);
+    return (code[0] != 0);
   }
   PRBool operator==(const nsGlyphCode& other) const
   {
-    return other.code == code && other.font == font;
+    return (other.code[0] == code[0] && other.code[1] == code[1] && 
+            other.font == font);
   }
   PRBool operator!=(const nsGlyphCode& other) const
   {
     return ! operator==(other);
   }
 };
 
 // Class used to handle stretchy symbols (accent, delimiter and boundary symbols).
