# User Quentin Headen <qheaden@phaseshiftsoftware.com>
Bug 731667 - Rewrite mtable implementation to avoid use of _moz-* attributes. r=karlt

diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -13,122 +13,176 @@
 
 #include "nsTArray.h"
 #include "nsTableFrame.h"
 #include "celldata.h"
 
 #include "RestyleManager.h"
 #include <algorithm>
 
+#include "nsIScriptError.h"
+#include "nsContentUtils.h"
+
 using namespace mozilla;
 
 //
 // <mtable> -- table or matrix - implementation
 //
 
-// helper function to perform an in-place split of a space-delimited string,
-// and return an array of pointers for the beginning of each segment, i.e.,
-// aOffset[0] is the first string, aOffset[1] is the second string, etc.
-// Used to parse attributes like columnalign='left right', rowalign='top bottom'
-static void
-SplitString(nsString&             aString, // [IN/OUT]
-            nsTArray<PRUnichar*>& aOffset) // [OUT]
+static int8_t
+ParseStyleValue(nsIAtom* aAttribute, const nsAString& aAttributeValue)
 {
-  static const PRUnichar kNullCh = PRUnichar('\0');
+  if (aAttribute == nsGkAtoms::rowalign_) {
+    if (aAttributeValue.EqualsLiteral("top"))
+      return NS_STYLE_VERTICAL_ALIGN_TOP;
+    else if (aAttributeValue.EqualsLiteral("bottom"))
+      return NS_STYLE_VERTICAL_ALIGN_BOTTOM;
+    else if (aAttributeValue.EqualsLiteral("center"))
+      return NS_STYLE_VERTICAL_ALIGN_MIDDLE;
+    else
+      return NS_STYLE_VERTICAL_ALIGN_BASELINE;
+  } else if (aAttribute == nsGkAtoms::columnalign_) {
+    if (aAttributeValue.EqualsLiteral("left"))
+      return NS_STYLE_TEXT_ALIGN_LEFT;
+    else if (aAttributeValue.EqualsLiteral("right"))
+      return NS_STYLE_TEXT_ALIGN_RIGHT;
+    else
+      return NS_STYLE_TEXT_ALIGN_CENTER;
+  } else if (aAttribute == nsGkAtoms::rowlines_ ||
+             aAttribute == nsGkAtoms::columnlines_) {
+    if (aAttributeValue.EqualsLiteral("solid"))
+      return NS_STYLE_BORDER_STYLE_SOLID;
+    else if (aAttributeValue.EqualsLiteral("dashed"))
+      return NS_STYLE_BORDER_STYLE_DASHED;
+    else
+      return NS_STYLE_BORDER_STYLE_NONE;
+  } else {
+    PR_NOT_REACHED("Unrecognized attribute.");
+  }
 
-  aString.Append(kNullCh);  // put an extra null at the end
+  return -1;
+}
 
-  PRUnichar* start = aString.BeginWriting();
-  PRUnichar* end   = start;
+static nsTArray<int8_t>*
+ExtractStyleValues(const nsAString& aString, nsIAtom* aAttribute,
+                   bool aAllowMultiValues)
+{
+  nsTArray<int8_t>* styleArray = nullptr;
 
-  while (kNullCh != *start) {
-    while ((kNullCh != *start) && nsCRT::IsAsciiSpace(*start)) {  // skip leading space
+  const PRUnichar* start = aString.BeginReading();
+  const PRUnichar* end = aString.EndReading();
+
+  int32_t startIndex = 0;
+  int32_t count = 0;
+
+  while (start < end) {
+    // Skip leading spaces.
+    while ((start < end) && nsCRT::IsAsciiSpace(*start)) {
       start++;
-    }
-    end = start;
-
-    while ((kNullCh != *end) && (false == nsCRT::IsAsciiSpace(*end))) { // look for space or end
-      end++;
-    }
-    *end = kNullCh; // end string here
-
-    if (start < end) {
-      aOffset.AppendElement(start); // record the beginning of this segment
+      startIndex++;
     }
 
-    start = ++end;
+    // Look for the end of the string, or another space.
+    while ((start < end) && !nsCRT::IsAsciiSpace(*start)) {
+      start++;
+      count++;
+    }
+
+    // Grab the value found and process it.
+    if (count > 0) {
+      if (styleArray == nullptr)
+        styleArray = new nsTArray<int8_t>();
+
+      // We want to return a null array if an attribute gives multiple values,
+      // but multiple values aren't allowed.
+      if (styleArray->Length() > 1 && !aAllowMultiValues) {
+        delete styleArray;
+        return nullptr;
+      }
+
+      nsDependentSubstring valueString(aString, startIndex, count);
+      int8_t styleValue = ParseStyleValue(aAttribute, valueString);
+      styleArray->AppendElement(styleValue);
+
+      startIndex += count;
+      count = 0;
+    }
   }
+  return styleArray;
 }
 
-struct nsValueList
+static nsresult ReportParseError(nsIFrame* aFrame, const PRUnichar* aAttribute,
+                                 const PRUnichar* aValue)
 {
-  nsString             mData;
-  nsTArray<PRUnichar*> mArray;
+  nsIContent* content = aFrame->GetContent();
 
-  nsValueList(nsString& aData) {
-    mData.Assign(aData);
-    SplitString(mData, mArray);
-  }
-};
+  const PRUnichar* params[] =
+    { aValue, aAttribute, content->Tag()->GetUTF16String() };
+
+  return nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
+                                         NS_LITERAL_CSTRING("MathML"),
+                                         content->OwnerDoc(),
+                                         nsContentUtils::eMATHML_PROPERTIES,
+                                         "AttributeParsingError", params, 3);
+}
 
 // Each rowalign='top bottom' or columnalign='left right center' (from
-// <mtable> or <mtr>) is split once (lazily) into a nsValueList which is
+// <mtable> or <mtr>) is split once into an nsTArray<int8_t> which is
 // stored in the property table. Row/Cell frames query the property table
 // to see what values apply to them.
 
-// XXX See bug 69409 - MathML attributes are not mapped to style.
-
 static void
-DestroyValueList(void* aPropertyValue)
+DestroyStylePropertyList(void* aPropertyValue)
 {
-  delete static_cast<nsValueList*>(aPropertyValue);
+  delete static_cast<nsTArray<int8_t>*>(aPropertyValue);
 }
 
-NS_DECLARE_FRAME_PROPERTY(RowAlignProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(RowLinesProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(ColumnAlignProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(ColumnLinesProperty, DestroyValueList)
+NS_DECLARE_FRAME_PROPERTY(RowAlignProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(RowLinesProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(ColumnAlignProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(ColumnLinesProperty, DestroyStylePropertyList)
 
 static const FramePropertyDescriptor*
 AttributeToProperty(nsIAtom* aAttribute)
 {
   if (aAttribute == nsGkAtoms::rowalign_)
     return RowAlignProperty();
   if (aAttribute == nsGkAtoms::rowlines_)
     return RowLinesProperty();
   if (aAttribute == nsGkAtoms::columnalign_)
     return ColumnAlignProperty();
   NS_ASSERTION(aAttribute == nsGkAtoms::columnlines_, "Invalid attribute");
   return ColumnLinesProperty();
 }
 
-static PRUnichar*
-GetValueAt(nsIFrame*                      aTableOrRowFrame,
-           const FramePropertyDescriptor* aProperty,
-           nsIAtom*                       aAttribute,
-           int32_t                        aRowOrColIndex)
+/* This method looks for a property that applies to a cell, but it looks
+ * recursively because some cell properties can come from the cell, a row,
+ * a table, etc. This function searches through the heirarchy for a property
+ * and returns its value. The function stops searching after checking a <mtable>
+ * frame.
+ */
+static nsTArray<int8_t>*
+FindCellProperty(const nsIFrame* aCellFrame,
+                 const FramePropertyDescriptor* aFrameProperty)
 {
-  FrameProperties props = aTableOrRowFrame->Properties();
-  nsValueList* valueList = static_cast<nsValueList*>(props.Get(aProperty));
-  if (!valueList) {
-    // The property isn't there yet, so set it
-    nsAutoString values;
-    aTableOrRowFrame->GetContent()->GetAttr(kNameSpaceID_None, aAttribute, values);
-    if (!values.IsEmpty())
-      valueList = new nsValueList(values);
-    if (!valueList || !valueList->mArray.Length()) {
-      delete valueList; // ok either way, delete is null safe
-      return nullptr;
-    }
-    props.Set(aProperty, valueList);
+  const nsIFrame* currentFrame = aCellFrame;
+  nsTArray<int8_t>* propertyData = nullptr;
+
+  while (currentFrame) {
+    FrameProperties props = currentFrame->Properties();
+    propertyData = static_cast<nsTArray<int8_t>*>(props.Get(aFrameProperty));
+    bool frameIsTable = (currentFrame->GetType() == nsGkAtoms::tableFrame);
+
+    if (propertyData || frameIsTable)
+      currentFrame = nullptr; // A null frame pointer exits the loop
+    else
+      currentFrame = currentFrame->GetParent(); // Go to the parent frame
   }
-  int32_t count = valueList->mArray.Length();
-  return (aRowOrColIndex < count)
-         ? valueList->mArray[aRowOrColIndex]
-         : valueList->mArray[count-1];
+
+  return propertyData;
 }
 
 /*
  * A variant of the nsDisplayBorder contains special code to render a border
  * around a nsMathMLmtdFrame based on the rowline and columnline properties
  * set on the cell frame.
  */
 class nsDisplaymtdBorder : public nsDisplayBorder {
@@ -192,148 +246,83 @@ public:
                                                       mFrame->GetSize()),
                                                styleBorder,
                                                mFrame->StyleContext(),
                                                mFrame->GetSkipSides());
   }
 };
 
 #ifdef DEBUG
-static bool
-IsTable(uint8_t aDisplay)
-{
-  if ((aDisplay == NS_STYLE_DISPLAY_TABLE) ||
-      (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE))
-    return true;
-  return false;
-}
-
 #define DEBUG_VERIFY_THAT_FRAME_IS(_frame, _expected) \
   NS_ASSERTION(NS_STYLE_DISPLAY_##_expected == _frame->StyleDisplay()->mDisplay, "internal error");
-#define DEBUG_VERIFY_THAT_FRAME_IS_TABLE(_frame) \
-  NS_ASSERTION(IsTable(_frame->StyleDisplay()->mDisplay), "internal error");
 #else
 #define DEBUG_VERIFY_THAT_FRAME_IS(_frame, _expected)
-#define DEBUG_VERIFY_THAT_FRAME_IS_TABLE(_frame)
 #endif
 
-// map attributes that depend on the index of the row:
-// rowalign, rowlines, XXX need rowspacing too
 static void
-MapRowAttributesIntoCSS(nsIFrame* aTableFrame,
-                        nsIFrame* aRowFrame)
+ParseFrameAttribute(nsIFrame* aFrame, nsIAtom* aAttribute,
+                    bool aAllowMultiValues)
 {
-  DEBUG_VERIFY_THAT_FRAME_IS_TABLE(aTableFrame);
-  DEBUG_VERIFY_THAT_FRAME_IS(aRowFrame, TABLE_ROW);
-  int32_t rowIndex = ((nsTableRowFrame*)aRowFrame)->GetRowIndex();
-  nsIContent* rowContent = aRowFrame->GetContent();
-  PRUnichar* attr;
+  nsAutoString attrValue;
 
-  // see if the rowalign attribute is not already set
-  if (!rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::rowalign_) &&
-      !rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowalign_)) {
-    // see if the rowalign attribute was specified on the table
-    attr = GetValueAt(aTableFrame, RowAlignProperty(),
-                      nsGkAtoms::rowalign_, rowIndex);
-    if (attr) {
-      // set our special _moz attribute on the row without notifying a reflow
-      rowContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowalign_,
-                          nsDependentString(attr), false);
-    }
-  }
+  nsIContent* frameContent = aFrame->GetContent();
+  frameContent->GetAttr(kNameSpaceID_None, aAttribute, attrValue);
 
-  // if we are not on the first row, see if |rowlines| was specified on the table.
-  // Note that we pass 'rowIndex-1' because the CSS rule in mathml.css is associated
-  // to 'border-top', and it is as if we draw the line on behalf of the previous cell.
-  // This way of doing so allows us to handle selective lines, [row]\hline[row][row]',
-  // and cases of spanning cells without further complications.
-  if (rowIndex > 0 &&
-      !rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowline_)) {
-    attr = GetValueAt(aTableFrame, RowLinesProperty(),
-                      nsGkAtoms::rowlines_, rowIndex-1);
-    if (attr) {
-      // set our special _moz attribute on the row without notifying a reflow
-      rowContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowline_,
-                          nsDependentString(attr), false);
-    }
-  }
-}
+  if (!attrValue.IsEmpty()) {
+    nsTArray<int8_t>* valueList =
+      ExtractStyleValues(attrValue, aAttribute, aAllowMultiValues);
 
-// map attributes that depend on the index of the column:
-// columnalign, columnlines, XXX need columnwidth and columnspacing too
-static void
-MapColAttributesIntoCSS(nsIFrame* aTableFrame,
-                        nsIFrame* aRowFrame,
-                        nsIFrame* aCellFrame)
-{
-  DEBUG_VERIFY_THAT_FRAME_IS_TABLE(aTableFrame);
-  DEBUG_VERIFY_THAT_FRAME_IS(aRowFrame, TABLE_ROW);
-  DEBUG_VERIFY_THAT_FRAME_IS(aCellFrame, TABLE_CELL);
-  int32_t rowIndex, colIndex;
-  ((nsTableCellFrame*)aCellFrame)->GetCellIndexes(rowIndex, colIndex);
-  nsIContent* cellContent = aCellFrame->GetContent();
-  PRUnichar* attr;
-
-  // see if the columnalign attribute is not already set
-  if (!cellContent->HasAttr(kNameSpaceID_None, nsGkAtoms::columnalign_) &&
-      !cellContent->HasAttr(kNameSpaceID_None,
-                            nsGkAtoms::_moz_math_columnalign_)) {
-    // see if the columnalign attribute was specified on the row
-    attr = GetValueAt(aRowFrame, ColumnAlignProperty(),
-                      nsGkAtoms::columnalign_, colIndex);
-    if (!attr) {
-      // see if the columnalign attribute was specified on the table
-      attr = GetValueAt(aTableFrame, ColumnAlignProperty(),
-                        nsGkAtoms::columnalign_, colIndex);
-    }
-    if (attr) {
-      // set our special _moz attribute without notifying a reflow
-      cellContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnalign_,
-                           nsDependentString(attr), false);
-    }
-  }
-
-  // if we are not on the first column, see if |columnlines| was specified on
-  // the table. Note that we pass 'colIndex-1' because the CSS rule in mathml.css
-  // is associated to 'border-left', and it is as if we draw the line on behalf
-  // of the previous cell. This way of doing so allows us to handle selective lines,
-  // e.g., 'r|cl', and cases of spanning cells without further complications.
-  if (colIndex > 0 &&
-      !cellContent->HasAttr(kNameSpaceID_None,
-                            nsGkAtoms::_moz_math_columnline_)) {
-    attr = GetValueAt(aTableFrame, ColumnLinesProperty(),
-                      nsGkAtoms::columnlines_, colIndex-1);
-    if (attr) {
-      // set our special _moz attribute without notifying a reflow
-      cellContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnline_,
-                           nsDependentString(attr), false);
+    // If valueList is null, that indicates a problem with the attribute value.
+    // Only set properties on a valid attribute value.
+    if (valueList) {
+      // The code reading the property assumes that this list is nonempty.
+      NS_ASSERTION(valueList->Length() >= 1, "valueList should not be empty!");
+      FrameProperties props = aFrame->Properties();
+      props.Set(AttributeToProperty(aAttribute), valueList);
+    } else {
+      ReportParseError(aFrame, aAttribute->GetUTF16String(), attrValue.get());
     }
   }
 }
 
 // map all attribues within a table -- requires the indices of rows and cells.
 // so it can only happen after they are made ready by the table base class.
 static void
 MapAllAttributesIntoCSS(nsIFrame* aTableFrame)
 {
+  // Map mtable rowalign & rowlines.
+  ParseFrameAttribute(aTableFrame, nsGkAtoms::rowalign_, true);
+  ParseFrameAttribute(aTableFrame, nsGkAtoms::rowlines_, true);
+
+  // Map mtable columnalign & columnlines.
+  ParseFrameAttribute(aTableFrame, nsGkAtoms::columnalign_, true);
+  ParseFrameAttribute(aTableFrame, nsGkAtoms::columnlines_, true);
+
   // mtable is simple and only has one (pseudo) row-group
   nsIFrame* rgFrame = aTableFrame->GetFirstPrincipalChild();
   if (!rgFrame || rgFrame->GetType() != nsGkAtoms::tableRowGroupFrame)
     return;
 
   nsIFrame* rowFrame = rgFrame->GetFirstPrincipalChild();
   for ( ; rowFrame; rowFrame = rowFrame->GetNextSibling()) {
     DEBUG_VERIFY_THAT_FRAME_IS(rowFrame, TABLE_ROW);
     if (rowFrame->GetType() == nsGkAtoms::tableRowFrame) {
-      MapRowAttributesIntoCSS(aTableFrame, rowFrame);
+      // Map row rowalign.
+      ParseFrameAttribute(rowFrame, nsGkAtoms::rowalign_, false);
+      // Map row columnalign.
+      ParseFrameAttribute(rowFrame, nsGkAtoms::columnalign_, true);
+
       nsIFrame* cellFrame = rowFrame->GetFirstPrincipalChild();
       for ( ; cellFrame; cellFrame = cellFrame->GetNextSibling()) {
         DEBUG_VERIFY_THAT_FRAME_IS(cellFrame, TABLE_CELL);
         if (IS_TABLE_CELL(cellFrame->GetType())) {
-          MapColAttributesIntoCSS(aTableFrame, rowFrame, cellFrame);
+          // Map cell rowalign.
+          ParseFrameAttribute(cellFrame, nsGkAtoms::rowalign_, false);
+          // Map row columnalign.
+          ParseFrameAttribute(cellFrame, nsGkAtoms::columnalign_, false);
         }
       }
     }
   }
 }
 
 // the align attribute of mtable can have a row number which indicates
 // from where to anchor the table, e.g., top 5 means anchor the table at
@@ -523,58 +512,38 @@ nsMathMLmtableOuterFrame::AttributeChang
     // Need to reflow the parent, not us, because this can actually
     // affect siblings.
     PresContext()->PresShell()->
       FrameNeedsReflow(mParent, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
     return NS_OK;
   }
 
   // ...and the other attributes affect rows or columns in one way or another
-  nsIAtom* MOZrowAtom = nullptr;
-  nsIAtom* MOZcolAtom = nullptr;
-  if (aAttribute == nsGkAtoms::rowalign_)
-    MOZrowAtom = nsGkAtoms::_moz_math_rowalign_;
-  else if (aAttribute == nsGkAtoms::rowlines_)
-    MOZrowAtom = nsGkAtoms::_moz_math_rowline_;
-  else if (aAttribute == nsGkAtoms::columnalign_)
-    MOZcolAtom = nsGkAtoms::_moz_math_columnalign_;
-  else if (aAttribute == nsGkAtoms::columnlines_)
-    MOZcolAtom = nsGkAtoms::_moz_math_columnline_;
 
-  if (!MOZrowAtom && !MOZcolAtom)
+  // Only allow attributes that this function is allowed to handle (which is
+  // specified in the comment at the beginning of the function.)
+  if (aAttribute != nsGkAtoms::rowalign_ &&
+      aAttribute != nsGkAtoms::rowlines_ &&
+      aAttribute != nsGkAtoms::columnalign_ &&
+      aAttribute != nsGkAtoms::columnlines_) {
     return NS_OK;
+  }
 
   nsPresContext* presContext = tableFrame->PresContext();
-  // clear any cached nsValueList for this table
+
+  // clear any cached property list for this table
   presContext->PropertyTable()->
     Delete(tableFrame, AttributeToProperty(aAttribute));
 
-  // unset any _moz attribute that we may have set earlier, and re-sync
-  nsIFrame* rowFrame = rgFrame->GetFirstPrincipalChild();
-  for ( ; rowFrame; rowFrame = rowFrame->GetNextSibling()) {
-    if (rowFrame->GetType() == nsGkAtoms::tableRowFrame) {
-      if (MOZrowAtom) { // let rows do the work
-        rowFrame->GetContent()->UnsetAttr(kNameSpaceID_None, MOZrowAtom, false);
-        MapRowAttributesIntoCSS(tableFrame, rowFrame);    
-      } else { // let cells do the work
-        nsIFrame* cellFrame = rowFrame->GetFirstPrincipalChild();
-        for ( ; cellFrame; cellFrame = cellFrame->GetNextSibling()) {
-          if (IS_TABLE_CELL(cellFrame->GetType())) {
-            cellFrame->GetContent()->UnsetAttr(kNameSpaceID_None, MOZcolAtom, false);
-            MapColAttributesIntoCSS(tableFrame, rowFrame, cellFrame);
-          }
-        }
-      }
-    }
-  }
+  // Reparse the new attribute on the table.
+  ParseFrameAttribute(tableFrame, aAttribute, true);
 
-  // Explicitly request a re-resolve and reflow in our subtree to pick up any changes
-  presContext->RestyleManager()->
-    PostRestyleEvent(mContent->AsElement(), eRestyle_Subtree,
-                     nsChangeHint_AllReflowHints);
+  // Explicitly request a reflow in our subtree to pick up any changes
+  presContext->PresShell()->
+      FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
 
   return NS_OK;
 }
 
 nsIFrame*
 nsMathMLmtableOuterFrame::GetRowFrameAt(nsPresContext* aPresContext,
                                         int32_t         aRowIndex)
 {
@@ -770,53 +739,36 @@ nsMathMLmtrFrame::~nsMathMLmtrFrame()
 
 NS_IMETHODIMP
 nsMathMLmtrFrame::AttributeChanged(int32_t  aNameSpaceID,
                                    nsIAtom* aAttribute,
                                    int32_t  aModType)
 {
   // Attributes specific to <mtr>:
   // groupalign  : Not yet supported.
-  // rowalign    : Fully specified in mathml.css, and so HasAttributeDependentStyle() will
-  //               pick it up and RestyleManager will issue a PostRestyleEvent().
-  // columnalign : Need an explicit re-style call.
+  // rowalign    : Here
+  // columnalign : Here
 
-  if (aAttribute == nsGkAtoms::rowalign_) {
-    // unset any _moz attribute that we may have set earlier, and re-sync
-    mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowalign_,
-                        false);
-    MapRowAttributesIntoCSS(nsTableFrame::GetTableFrame(this), this);
-    // That's all - see comment above.
+  nsPresContext* presContext = PresContext();
+
+  if (aAttribute != nsGkAtoms::rowalign_ &&
+      aAttribute != nsGkAtoms::columnalign_) {
     return NS_OK;
   }
 
-  if (aAttribute != nsGkAtoms::columnalign_)
-    return NS_OK;
-
-  nsPresContext* presContext = PresContext();
-  // Clear any cached columnalign's nsValueList for this row
   presContext->PropertyTable()->Delete(this, AttributeToProperty(aAttribute));
 
-  // Clear any internal _moz attribute that we may have set earlier
-  // in our cells and re-sync their columnalign attribute
-  nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
-  nsIFrame* cellFrame = GetFirstPrincipalChild();
-  for ( ; cellFrame; cellFrame = cellFrame->GetNextSibling()) {
-    if (IS_TABLE_CELL(cellFrame->GetType())) {
-      cellFrame->GetContent()->
-        UnsetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnalign_,
-                  false);
-      MapColAttributesIntoCSS(tableFrame, this, cellFrame);
-    }
-  }
+  bool allowMultiValues = (aAttribute == nsGkAtoms::columnalign_);
 
-  // Explicitly request a re-resolve and reflow in our subtree to pick up any changes
-  presContext->RestyleManager()->
-    PostRestyleEvent(mContent->AsElement(), eRestyle_Subtree,
-                     nsChangeHint_AllReflowHints);
+  // Reparse the new attribute.
+  ParseFrameAttribute(this, aAttribute, allowMultiValues);
+
+  // Explicitly request a reflow in our subtree to pick up any changes
+  presContext->PresShell()->
+      FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
 
   return NS_OK;
 }
 
 // --------
 // implementation of nsMathMLmtdFrame
 
 nsIFrame*
@@ -872,26 +824,29 @@ nsMathMLmtdFrame::GetColSpan()
 
 NS_IMETHODIMP
 nsMathMLmtdFrame::AttributeChanged(int32_t  aNameSpaceID,
                                    nsIAtom* aAttribute,
                                    int32_t  aModType)
 {
   // Attributes specific to <mtd>:
   // groupalign  : Not yet supported
-  // rowalign    : in mathml.css
+  // rowalign    : here
   // columnalign : here
   // rowspan     : here
   // columnspan  : here
 
-  if (aAttribute == nsGkAtoms::columnalign_) {
-    // unset any _moz attribute that we may have set earlier, and re-sync
-    mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnalign_,
-                        false);
-    MapColAttributesIntoCSS(nsTableFrame::GetTableFrame(this), mParent, this);
+  if (aAttribute == nsGkAtoms::rowalign_ ||
+      aAttribute == nsGkAtoms::columnalign_) {
+
+    nsPresContext* presContext = PresContext();
+    presContext->PropertyTable()->Delete(this, AttributeToProperty(aAttribute));
+
+    // Reparse the attribute.
+    ParseFrameAttribute(this, aAttribute, false);
     return NS_OK;
   }
 
   if (aAttribute == nsGkAtoms::rowspan ||
       aAttribute == nsGkAtoms::columnspan_) {
     // use the naming expected by the base class 
     if (aAttribute == nsGkAtoms::columnspan_)
       aAttribute = nsGkAtoms::colspan;
