# HG changeset patch
# Parent 0204febd31467c1cd357728a45c0e3e508487fd8
# User Frédéric Wang <fred.wang@free.fr>
Bug 663740 - migrate nsMathMLChar measuring and drawing from nsRenderingContext to gfx/thebes classes. r=karlt.

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -28,17 +28,17 @@
 #include "nsMathMLOperators.h"
 #include <algorithm>
 
 using namespace mozilla;
 
 //#define NOISY_SEARCH 1
 
 // -----------------------------------------------------------------------------
-static const nsGlyphCode kNullGlyph = {{0, 0}, 0};
+static const nsGlyphCode kNullGlyph = {{{0, 0}}, 0};
 typedef enum {eExtension_base, eExtension_variants, eExtension_parts}
   nsMathfontPrefExtension;
 
 // -----------------------------------------------------------------------------
 // nsGlyphTable is a class that provides an interface for accessing glyphs
 // of stretchy chars. It acts like a table that stores the variants of bigger
 // sizes (if any) and the partial glyphs needed to build extensible symbols.
 // An instance of nsGlyphTable is associated to one primary font. Extra glyphs
@@ -121,16 +121,18 @@ public:
 
   const nsAString& PrimaryFontName() const
   {
     return mFontName[0];
   }
 
   const nsAString& FontNameFor(const nsGlyphCode& aGlyphCode) const
   {
+    NS_ASSERTION(!aGlyphCode.IsGlyphID(),
+                 "nsGlyphTable can only access glyphs by Unicode code point");
     return mFontName[aGlyphCode.font];
   }
 
   // True if this table contains some glyphs (variants and/or parts)
   // or contains child chars that can be used to render this char
   bool Has(nsPresContext* aPresContext, nsMathMLChar* aChar);
 
   // True if this table contains variants of larger sizes to render this char
@@ -902,63 +904,135 @@ insert:
                      p_name - p_begin);
   }
   else { // whitespace or empty
     aFontName = aFallbackFamilies;
   }
 }
 
 // Update the font and rendering context if there is a family change
-static bool
-SetFontFamily(nsStyleContext*      aStyleContext,
-              nsRenderingContext&  aRenderingContext,
-              nsFont&              aFont,
-              const nsGlyphTable*  aGlyphTable,
-              const nsGlyphCode&   aGlyphCode,
-              const nsAString&     aDefaultFamily)
+bool
+nsMathMLChar::SetFontFamily(nsPresContext*      aPresContext,
+                            const nsGlyphTable* aGlyphTable,
+                            const nsGlyphCode&  aGlyphCode,
+                            const nsAString&    aDefaultFamily,
+                            nsFont&             aFont)
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
     nsFont font = aFont;
     font.name = family;
     nsRefPtr<nsFontMetrics> fm;
-    aRenderingContext.DeviceContext()->GetMetricsFor(font,
-      aStyleContext->StyleFont()->mLanguage,
-      aStyleContext->PresContext()->GetUserFontSet(),
-      aStyleContext->PresContext()->GetTextPerfMetrics(),
-      *getter_AddRefs(fm));
+    aPresContext->DeviceContext()->GetMetricsFor(font,
+                                                 mStyleContext->StyleFont()->
+                                                 mLanguage,
+                                                 mStyleContext->PresContext()->
+                                                 GetUserFontSet(),
+                                                 mStyleContext->PresContext()->
+                                                 GetTextPerfMetrics(),
+                                                 *getter_AddRefs(fm));
     // Set the font if it is an unicode table
     // or if the same family name has been found
     if (aGlyphTable == &gGlyphTableList->mUnicodeTable ||
         fm->GetThebesFontGroup()->GetFontAt(0)->GetFontEntry()->
         FamilyName() == family) {
       aFont.name = family;
-      aRenderingContext.SetFont(fm);
+      mFontMetrics = fm;
     } else {
       return false; // We did not set the font
     }
   }
   return true;
 }
 
+class StubPropertyProvider : public gfxTextRun::PropertyProvider {
+public:
+    virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
+                                      bool* aBreakBefore) {
+        NS_ERROR("This shouldn't be called because we never call BreakAndMeasureText");
+    }
+    virtual PRInt8 GetHyphensOption() {
+        NS_ERROR("This shouldn't be called because we never call BreakAndMeasureText");
+        return NS_STYLE_HYPHENS_NONE;
+    }
+    virtual gfxFloat GetHyphenWidth() {
+        NS_ERROR("This shouldn't be called because we never enable hyphens");
+        return 0;
+    }
+    virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength,
+                            Spacing* aSpacing) {
+        NS_ERROR("This shouldn't be called because we never enable spacing");
+    }
+};
+
+gfxTextRun*
+nsMathMLChar::MakeTextRun(gfxContext*        aThebesContext,
+                          const nsGlyphCode& aGlyph)
+{
+  NS_ASSERTION(!aGlyph.IsGlyphID(), "not yet implemented");
+  return mFontMetrics->GetThebesFontGroup()->
+    MakeTextRun(aGlyph.code, aGlyph.Length(), aThebesContext,
+                mFontMetrics->AppUnitsPerDevPixel(), 0);
+}
+
+nsBoundingMetrics
+nsMathMLChar::MeasureGlyph(gfxContext*        aThebesContext,
+                           const nsGlyphCode& aGlyph)
+{
+  nsAutoPtr<gfxTextRun> textRun;
+  textRun = MakeTextRun(aThebesContext, aGlyph);
+
+  StubPropertyProvider provider;
+  gfxTextRun::Metrics metrics =
+    textRun->MeasureText(0, aGlyph.Length(),
+                         gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
+                         aThebesContext, &provider);
+
+  nsBoundingMetrics bm;
+  bm.leftBearing = NSToCoordFloor(metrics.mBoundingBox.X());
+  bm.rightBearing = NSToCoordCeil(metrics.mBoundingBox.XMost());
+  bm.ascent = NSToCoordCeil(-metrics.mBoundingBox.Y());
+  bm.descent = NSToCoordCeil(metrics.mBoundingBox.YMost());
+  bm.width = NSToCoordRound(metrics.mAdvanceWidth);
+
+  return bm;
+}
+
+void
+nsMathMLChar::DrawGlyph(gfxContext*         aThebesContext,
+                        const nsGlyphCode&  aGlyph,
+                        nscoord             dx,
+                        nscoord             dy)
+{
+  NS_ASSERTION(!aGlyph.IsGlyphID(), "not yet implemented");
+
+  nsAutoPtr<gfxTextRun> textRun;
+  textRun = MakeTextRun(aThebesContext, aGlyph);
+
+  StubPropertyProvider provider;
+  gfxPoint pt(dx, dy);
+  textRun->Draw(aThebesContext, pt, DrawMode::GLYPH_FILL, 0, aGlyph.Length(),
+                &provider, nullptr, nullptr);
+}
+
 class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
-                     nsRenderingContext& aRenderingContext,
+                     gfxContext*          aThebesContext,
                      nsStretchDirection   aStretchDirection,
                      nscoord              aTargetSize,
                      uint32_t             aStretchHint,
                      nsBoundingMetrics&   aStretchedMetrics,
                      const nsAString&     aFamilies,
                      bool&              aGlyphFound)
     : mChar(aChar),
       mPresContext(aPresContext),
-      mRenderingContext(aRenderingContext),
+      mThebesContext(aThebesContext),
       mDirection(aStretchDirection),
       mTargetSize(aTargetSize),
       mStretchHint(aStretchHint),
       mBoundingMetrics(aStretchedMetrics),
       mFamilies(aFamilies),
       mTryVariants(true),
       mTryParts(true),
       mGlyphFound(aGlyphFound) {}
@@ -967,17 +1041,17 @@ public:
   EnumCallback(const nsString& aFamily, bool aGeneric, void *aData);
 
 private:
   bool TryVariants(nsGlyphTable* aGlyphTable, const nsAString& aFamily);
   bool TryParts(nsGlyphTable* aGlyphTable, const nsAString& aFamily);
 
   nsMathMLChar* mChar;
   nsPresContext* mPresContext;
-  nsRenderingContext& mRenderingContext;
+  gfxContext* mThebesContext;
   const nsStretchDirection mDirection;
   const nscoord mTargetSize;
   const uint32_t mStretchHint;
   nsBoundingMetrics& mBoundingMetrics;
   // Font families to search
   const nsAString& mFamilies;
 
 public:
@@ -996,17 +1070,17 @@ private:
 // Always updates the char if a better match is found.
 bool
 nsMathMLChar::StretchEnumContext::TryVariants(nsGlyphTable*    aGlyphTable,
                                               const nsAString& aFamily)
 {
   // Use our stretchy style context now that stretching is in progress
   nsStyleContext *sc = mChar->mStyleContext;
   nsFont font = sc->StyleFont()->mFont;
-  // Ensure mRenderingContext.SetFont will be called:
+  // Ensure SetFontFamily will set the font
   font.name.Truncate();
 
   bool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   bool largeop = (NS_STRETCH_LARGEOP & mStretchHint) != 0;
   bool largeopOnly =
     largeop && (NS_STRETCH_VARIABLE_MASK & mStretchHint) == 0;
   bool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
 
@@ -1020,30 +1094,29 @@ nsMathMLChar::StretchEnumContext::TryVar
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
-    if(!SetFontFamily(sc, mRenderingContext, font, aGlyphTable, ch, aFamily)) {
+    if (!mChar->SetFontFamily(mPresContext, aGlyphTable, ch, aFamily, font)) {
       // if largeopOnly is set, break now
       if (largeopOnly) break;
       ++size;
       continue;
     }
 
-    NS_ASSERTION(maxWidth || ch.code[0] != mChar->mGlyph.code[0] ||
-                 ch.code[1] != mChar->mGlyph.code[1] ||
+    NS_ASSERTION(maxWidth || ch != mChar->mGlyphs[0] ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
-    nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
-                                                                ch.Length());
+    nsBoundingMetrics bm = mChar->MeasureGlyph(mThebesContext, ch);
+
     nscoord charSize =
       isVertical ? bm.ascent + bm.descent
       : bm.rightBearing - bm.leftBearing;
 
     if (largeopOnly ||
         IsSizeBetter(charSize, bestSize, mTargetSize, mStretchHint)) {
       mGlyphFound = true;
       if (maxWidth) {
@@ -1058,18 +1131,20 @@ nsMathMLChar::StretchEnumContext::TryVar
         // Continue to check other sizes unless largeopOnly
         haveBetter = largeopOnly;
       }
       else {
         mBoundingMetrics = bm;
         haveBetter = true;
         bestSize = charSize;
         mChar->mGlyphTable = aGlyphTable;
-        mChar->mGlyph = ch;
         mChar->mFamily = font.name;
+        mChar->mGlyphs[0] = ch;
+        mChar->mBmData[0] = bm;
+        mChar->mDraw = DRAW_VARIANT;
       }
 #ifdef NOISY_SEARCH
       printf("    size:%d Current best\n", size);
 #endif
     }
     else {
 #ifdef NOISY_SEARCH
       printf("    size:%d Rejected!\n", size);
@@ -1097,61 +1172,67 @@ nsMathMLChar::StretchEnumContext::TryPar
 {
   if (!aGlyphTable->HasPartsOf(mPresContext, mChar))
     return false; // to next table
 
   // See if the parts of this table fit in the desired space //////////////////
 
   // Use our stretchy style context now that stretching is in progress
   nsFont font = mChar->mStyleContext->StyleFont()->mFont;
-  // Ensure mRenderingContext.SetFont will be called:
+  // Ensure SetFontFamily will set the font
   font.name.Truncate();
 
   // Compute the bounding metrics of all partial glyphs
   nsGlyphCode chdata[4];
   nsBoundingMetrics bmdata[4];
   nscoord sizedata[4];
-  nsGlyphCode glue = aGlyphTable->GlueOf(mPresContext, mChar);
 
   bool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   bool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
 
   for (int32_t i = 0; i < 4; i++) {
     nsGlyphCode ch;
     switch (i) {
     case 0: ch = aGlyphTable->TopOf(mPresContext, mChar);    break;
     case 1: ch = aGlyphTable->MiddleOf(mPresContext, mChar); break;
     case 2: ch = aGlyphTable->BottomOf(mPresContext, mChar); break;
-    case 3: ch = glue;                                       break;
+    case 3: ch = aGlyphTable->GlueOf(mPresContext, mChar);   break;
     }
-    // empty slots are filled with the glue if it is not null
-    if (!ch.Exists()) ch = glue;
     chdata[i] = ch;
-    if (!ch.Exists()) {
-      // Null glue indicates that a rule will be drawn, which can stretch to
-      // fill any space.  Leave bounding metrics at 0.
-      sizedata[i] = mTargetSize;
-    }
-    else {
-      if (!SetFontFamily(mChar->mStyleContext, mRenderingContext,
-                         font, aGlyphTable, ch, aFamily))
+    if (ch.Exists()) {
+      if (!mChar->SetFontFamily(mPresContext, aGlyphTable, ch, aFamily, font))
         return false;
 
-      nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
-                                                                  ch.Length());
+      nsBoundingMetrics bm = mChar->MeasureGlyph(mThebesContext, chdata[i]);
 
       // TODO: For the generic Unicode table, ideally we should check that the
       // glyphs are actually found and that they each come from the same
       // font.
       bmdata[i] = bm;
       sizedata[i] = isVertical ? bm.ascent + bm.descent
                                : bm.rightBearing - bm.leftBearing;
     }
   }
 
+  nsGlyphCode glue = chdata[3];
+  // Empty slots are filled with the glue if it is not null
+  for (int32_t i = 0; i < 4; i++) {
+    if (chdata[i].Exists()) continue;
+    if (!glue.Exists()) {
+      // Null glue indicates that a rule will be drawn, which can stretch to
+      // fill any space. Leave bounding metrics at 0.
+      sizedata[i] = mTargetSize;
+      bmdata[i] = nsBoundingMetrics();
+    } else {
+      chdata[i] = glue;
+      sizedata[i] = sizedata[3];
+      bmdata[i] = bmdata[3];
+    }
+  }
+
   // Build by parts if we have successfully computed the
   // bounding metrics of all parts.
   nscoord computedSize = ComputeSizeFromParts(mPresContext, chdata, sizedata,
                                               mTargetSize);
 
   nscoord currentSize =
     isVertical ? mBoundingMetrics.ascent + mBoundingMetrics.descent
                : mBoundingMetrics.rightBearing - mBoundingMetrics.leftBearing;
@@ -1218,19 +1299,23 @@ nsMathMLChar::StretchEnumContext::TryPar
     mBoundingMetrics.leftBearing = 0;
     mBoundingMetrics.rightBearing = computedSize;
   }
   mGlyphFound = true;
   if (maxWidth)
     return false; // Continue to check other sizes
 
   // reset
-  mChar->mGlyph = kNullGlyph; // this will tell paint to build by parts
+  mChar->mDraw = DRAW_PARTS;
   mChar->mGlyphTable = aGlyphTable;
   mChar->mFamily = aFamily;
+  for (int32_t i = 0; i < 4; i++) {
+    mChar->mGlyphs[i] = chdata[i];
+    mChar->mBmData[i] = bmdata[i];
+  }
 
   return IsSizeOK(mPresContext, computedSize, mTargetSize, mStretchHint);
 }
 
 // This is called for each family, whether it exists or not
 bool
 nsMathMLChar::StretchEnumContext::EnumCallback(const nsString& aFamily,
                                                bool aGeneric, void *aData)
@@ -1245,18 +1330,19 @@ nsMathMLChar::StretchEnumContext::EnumCa
 
   if (context->mTablesTried.Contains(glyphTable))
     return true; // already tried this one
 
   // Check font family if it is not a generic one
   // We test with the kNullGlyph
   nsStyleContext *sc = context->mChar->mStyleContext;
   nsFont font = sc->StyleFont()->mFont;
-  if (!aGeneric && !SetFontFamily(sc, context->mRenderingContext,
-                                  font, nullptr, kNullGlyph, aFamily))
+  if (!aGeneric && !context->mChar->SetFontFamily(context->mPresContext,
+                                                  nullptr, kNullGlyph, aFamily,
+                                                  font))
      return true; // Could not set the family
 
   context->mGlyphTable = glyphTable;
 
   // Now see if the table has a glyph that matches the container
 
   // Only try this table once.
   context->mTablesTried.AppendElement(glyphTable);
@@ -1271,17 +1357,17 @@ nsMathMLChar::StretchEnumContext::EnumCa
      (context->mTryParts && context->TryParts(glyphTable, family)))
     return false; // no need to continue
 
   return true; // true means continue
 }
 
 nsresult
 nsMathMLChar::StretchInternal(nsPresContext*           aPresContext,
-                              nsRenderingContext&     aRenderingContext,
+                              gfxContext*              aThebesContext,
                               nsStretchDirection&      aStretchDirection,
                               const nsBoundingMetrics& aContainerSize,
                               nsBoundingMetrics&       aDesiredStretchSize,
                               uint32_t                 aStretchHint,
                               // These are currently only used when
                               // aStretchHint & NS_STRETCH_MAXWIDTH:
                               float                    aMaxSize,
                               bool                     aMaxSizeIsAbsolute)
@@ -1305,24 +1391,41 @@ nsMathMLChar::StretchInternal(nsPresCont
   // Don't modify this nsMathMLChar when doing GetMaxWidth()
   bool maxWidth = (NS_STRETCH_MAXWIDTH & aStretchHint) != 0;
   if (!maxWidth) {
     // Record the families in case there is no stretch.  But don't bother
     // storing families when they are just those from the StyleContext.
     mFamily = families;
   }
 
-  nsRefPtr<nsFontMetrics> fm;
-  aRenderingContext.DeviceContext()->GetMetricsFor(font,
-    mStyleContext->StyleFont()->mLanguage,
-    aPresContext->GetUserFontSet(),
-    aPresContext->GetTextPerfMetrics(), *getter_AddRefs(fm));
-  aRenderingContext.SetFont(fm);
-  aDesiredStretchSize =
-    aRenderingContext.GetBoundingMetrics(mData.get(), uint32_t(mData.Length()));
+  aPresContext->DeviceContext()->GetMetricsFor(font,
+                                               mStyleContext->StyleFont()->
+                                               mLanguage,
+                                               mStyleContext->PresContext()->
+                                               GetUserFontSet(),
+                                               mStyleContext->PresContext()->
+                                               GetTextPerfMetrics(),
+                                               *getter_AddRefs(mFontMetrics));
+  uint32_t len = uint32_t(mData.Length());
+  nsAutoPtr<gfxTextRun> textRun;
+  textRun = mFontMetrics->GetThebesFontGroup()->
+    MakeTextRun(mData.get(), len, aThebesContext,
+                mFontMetrics->AppUnitsPerDevPixel(), 0);
+  StubPropertyProvider provider;
+  gfxTextRun::Metrics metrics =
+    textRun->MeasureText(0, len,
+                         gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
+                         aThebesContext, &provider);
+  aDesiredStretchSize.leftBearing = NSToCoordFloor(metrics.mBoundingBox.X());
+  aDesiredStretchSize.rightBearing = NSToCoordCeil(metrics.
+                                                   mBoundingBox.XMost());
+  aDesiredStretchSize.ascent = NSToCoordCeil(-metrics.mBoundingBox.Y());
+  aDesiredStretchSize.descent = NSToCoordCeil(metrics.mBoundingBox.YMost());
+  aDesiredStretchSize.width = NSToCoordRound(metrics.mAdvanceWidth);
+
 
   if (!maxWidth) {
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
 
   //////////////////////////////////////////////////////////////////////////////
   // 1. Check the common situations where stretching is not actually needed
   //////////////////////////////////////////////////////////////////////////////
@@ -1416,30 +1519,30 @@ nsMathMLChar::StretchInternal(nsPresCont
     font = mStyleContext->StyleFont()->mFont;
     cssFamilies = font.name;
   }
 
   // See if there are preferred fonts for the variants of this char
   if (!done && GetFontExtensionPref(mData[0], eExtension_variants, families)) {
     font.name = families;
 
-    StretchEnumContext enumData(this, aPresContext, aRenderingContext,
+    StretchEnumContext enumData(this, aPresContext, aThebesContext,
                                 aStretchDirection, targetSize, aStretchHint,
                                 aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryParts = false;
 
     done = !font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   // See if there are preferred fonts for the parts of this char
   if (!done && !largeopOnly
       && GetFontExtensionPref(mData[0], eExtension_parts, families)) {
     font.name = families;
 
-    StretchEnumContext enumData(this, aPresContext, aRenderingContext,
+    StretchEnumContext enumData(this, aPresContext, aThebesContext,
                                 aStretchDirection, targetSize, aStretchHint,
                                 aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryVariants = false;
 
     done = !font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   if (!done) { // normal case
@@ -1450,28 +1553,28 @@ nsMathMLChar::StretchInternal(nsPresCont
     if (!fallbackFonts.IsEmpty()) {
       AddFallbackFonts(font.name, fallbackFonts);
     }
 
 #ifdef NOISY_SEARCH
     printf("Searching in "%s" for a glyph of appropriate size for: 0x%04X:%c\n",
            font.name, mData[0], mData[0]&0x00FF);
 #endif
-    StretchEnumContext enumData(this, aPresContext, aRenderingContext,
+    StretchEnumContext enumData(this, aPresContext, aThebesContext,
                                 aStretchDirection, targetSize, aStretchHint,
                                 aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryParts = !largeopOnly;
 
     font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   if (!maxWidth) {
     // Now, we know how we are going to draw the char. Update the member
     // variables accordingly.
-    mDrawNormal = !glyphFound;
+    if (!glyphFound) mDraw = DRAW_NORMAL;
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
     
   // stretchy character
   if (stretchy) {
     if (isVertical) {
       float scale =
         float(aContainerSize.ascent + aContainerSize.descent) /
@@ -1552,24 +1655,26 @@ nsMathMLChar::Stretch(nsPresContext*    
                       uint32_t                 aStretchHint,
                       bool                     aRTL)
 {
   NS_ASSERTION(!(aStretchHint &
                  ~(NS_STRETCH_VARIABLE_MASK | NS_STRETCH_LARGEOP |
                    NS_STRETCH_INTEGRAL)),
                "Unexpected stretch flags");
 
-  mDrawNormal = true;
+  mDraw = DRAW_NORMAL;
   mMirrored = aRTL && nsMathMLOperators::IsMirrorableOperator(mData);
   mScaleY = mScaleX = 1.0;
   mDirection = aStretchDirection;
   nsresult rv =
-    StretchInternal(aPresContext, aRenderingContext, mDirection,
+    StretchInternal(aPresContext, aRenderingContext.ThebesContext(), mDirection,
                     aContainerSize, aDesiredStretchSize, aStretchHint);
 
+  aRenderingContext.SetFont(mFontMetrics);
+
   // Record the metrics
   mBoundingMetrics = aDesiredStretchSize;
 
   return rv;
 }
 
 // What happens here is that the StretchInternal algorithm is used but
 // modified by passing the NS_STRETCH_MAXWIDTH stretch hint.  That causes
@@ -1588,18 +1693,20 @@ nsMathMLChar::GetMaxWidth(nsPresContext*
                           nsRenderingContext& aRenderingContext,
                           uint32_t aStretchHint,
                           float aMaxSize, bool aMaxSizeIsAbsolute)
 {
   nsBoundingMetrics bm;
   nsStretchDirection direction = NS_STRETCH_DIRECTION_VERTICAL;
   const nsBoundingMetrics container; // zero target size
 
-  StretchInternal(aPresContext, aRenderingContext, direction, container,
-                  bm, aStretchHint | NS_STRETCH_MAXWIDTH);
+  StretchInternal(aPresContext, aRenderingContext.ThebesContext(), direction,
+                  container, bm, aStretchHint | NS_STRETCH_MAXWIDTH);
+
+  aRenderingContext.SetFont(mFontMetrics);
 
   return std::max(bm.width, bm.rightBearing) - std::min(0, bm.leftBearing);
 }
 
 class nsDisplayMathMLSelectionRect : public nsDisplayItem {
 public:
   nsDisplayMathMLSelectionRect(nsDisplayListBuilder* aBuilder,
                                nsIFrame* aFrame, const nsRect& aRect)
@@ -1775,17 +1882,17 @@ nsMathMLChar::Display(nsDisplayListBuild
                       nsIFrame*               aForFrame,
                       const nsDisplayListSet& aLists,
                       uint32_t                aIndex,
                       const nsRect*           aSelectedRect)
 {
   nsStyleContext* parentContext = mStyleContext->GetParent();
   nsStyleContext* styleContext = mStyleContext;
 
-  if (mDrawNormal) {
+  if (mDraw == DRAW_NORMAL) {
     // normal drawing if there is nothing special about this char
     // Set default context to the parent context
     styleContext = parentContext;
   }
 
   if (!styleContext->StyleVisibility()->IsVisible())
     return;
 
@@ -1817,25 +1924,33 @@ nsMathMLChar::Display(nsDisplayListBuild
   aLists.Content()->AppendNewToTop(new (aBuilder)
     nsDisplayMathMLCharForeground(aBuilder, aForFrame, this,
                                   aIndex,
                                   aSelectedRect &&
                                   !aSelectedRect->IsEmpty()));
 }
 
 void
-nsMathMLChar::ApplyTransforms(nsRenderingContext& aRenderingContext, nsRect &r)
+nsMathMLChar::ApplyTransforms(gfxContext* aThebesContext,
+                              int32_t aAppUnitsPerGfxUnit,
+                              nsRect &r)
 {
   // apply the transforms
   if (mMirrored) {
-    aRenderingContext.Translate(r.TopRight());
-    aRenderingContext.Scale(-mScaleX, mScaleY);
+    nsPoint pt = r.TopRight();
+    aThebesContext->
+      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
+                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
+    aThebesContext->Scale(-mScaleX, mScaleY);
   } else {
-    aRenderingContext.Translate(r.TopLeft());
-    aRenderingContext.Scale(mScaleX, mScaleY);
+    nsPoint pt = r.TopLeft();
+    aThebesContext->
+      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
+                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
+    aThebesContext->Scale(mScaleX, mScaleY);
   }
 
   // update the bounding rectangle.
   r.x = r.y = 0;
   r.width /= mScaleX;
   r.height /= mScaleY;
 }
 
@@ -1843,172 +1958,194 @@ void
 nsMathMLChar::PaintForeground(nsPresContext* aPresContext,
                               nsRenderingContext& aRenderingContext,
                               nsPoint aPt,
                               bool aIsSelected)
 {
   nsStyleContext* parentContext = mStyleContext->GetParent();
   nsStyleContext* styleContext = mStyleContext;
 
-  if (mDrawNormal) {
+  if (mDraw == DRAW_NORMAL) {
     // normal drawing if there is nothing special about this char
     // Set default context to the parent context
     styleContext = parentContext;
   }
 
+  nsRefPtr<gfxContext> thebesContext = aRenderingContext.ThebesContext();
+
   // Set color ...
   nscolor fgColor = styleContext->GetVisitedDependentColor(eCSSProperty_color);
   if (aIsSelected) {
     // get color to use for selection from the look&feel object
     fgColor = LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectForeground,
                                     fgColor);
   }
-  aRenderingContext.SetColor(fgColor);
+  thebesContext->SetColor(fgColor);
 
   nsFont theFont(styleContext->StyleFont()->mFont);
   if (! mFamily.IsEmpty()) {
     theFont.name = mFamily;
   }
-  nsRefPtr<nsFontMetrics> fm;
-  aRenderingContext.DeviceContext()->GetMetricsFor(theFont,
-    styleContext->StyleFont()->mLanguage,
-    aPresContext->GetUserFontSet(), aPresContext->GetTextPerfMetrics(),
-    *getter_AddRefs(fm));
-  aRenderingContext.SetFont(fm);
+  aPresContext->DeviceContext()->GetMetricsFor(theFont,
+                                               mStyleContext->StyleFont()->
+                                               mLanguage,
+                                               aPresContext->GetUserFontSet(),
+                                               aPresContext->GetTextPerfMetrics(),
+                                               *getter_AddRefs(mFontMetrics));
 
-  aRenderingContext.PushState();
+  thebesContext->Save();
   nsRect r = mRect + aPt;
-  ApplyTransforms(aRenderingContext, r);
+  ApplyTransforms(thebesContext, aPresContext->AppUnitsPerDevPixel(), r);
 
-  if (mDrawNormal) {
-    // normal drawing if there is nothing special about this char ...
-    // Grab some metrics to adjust the placements ...
-    uint32_t len = uint32_t(mData.Length());
-    aRenderingContext.DrawString(mData.get(), len, 0, mUnscaledAscent);
-  }
-  else {
-    // Grab some metrics to adjust the placements ...
-    // if there is a glyph of appropriate size, paint that glyph
-    if (mGlyph.Exists()) {
-      aRenderingContext.DrawString(mGlyph.code, mGlyph.Length(),
-                                   0, mUnscaledAscent);
-    }
-    else { // paint by parts
+  switch(mDraw)
+  {
+    case DRAW_NORMAL:
+      {
+        // normal drawing if there is nothing special about this char...
+        uint32_t len = uint32_t(mData.Length());
+        nsAutoPtr<gfxTextRun> textRun;
+        textRun = mFontMetrics->GetThebesFontGroup()->
+          MakeTextRun(mData.get(), len, thebesContext,
+                      mFontMetrics->AppUnitsPerDevPixel(), 0);
+        StubPropertyProvider provider;
+        gfxPoint pt(0, mUnscaledAscent);
+        textRun->Draw(thebesContext, pt, DrawMode::GLYPH_FILL, 0, len,
+                      &provider, nullptr, nullptr);
+      }
+      break;
+    case DRAW_VARIANT:
+      // if there is a glyph of appropriate size, paint that glyph
+      DrawGlyph(thebesContext, mGlyphs[0], r.x, r.y + mUnscaledAscent);
+      break;
+    case DRAW_PARTS:
+      // paint by parts
       if (NS_STRETCH_DIRECTION_VERTICAL == mDirection)
-        PaintVertically(aPresContext, aRenderingContext, theFont, styleContext,
-                        mGlyphTable, r);
+        PaintVertically(aPresContext, thebesContext, theFont, mGlyphTable, r);
       else if (NS_STRETCH_DIRECTION_HORIZONTAL == mDirection)
-        PaintHorizontally(aPresContext, aRenderingContext, theFont,
-                          styleContext, mGlyphTable, r);
-    }
+        PaintHorizontally(aPresContext, thebesContext, theFont, mGlyphTable, r);
+      break;
+    default:
+      NS_NOTREACHED("Unknown drawing method");
+      break;
   }
 
-  aRenderingContext.PopState();
+  thebesContext->Restore();
 }
 
 /* =============================================================================
   Helper routines that actually do the job of painting the char by parts
  */
 
 class AutoPushClipRect {
-  nsRenderingContext& mCtx;
+  gfxContext* mThebesContext;
 public:
-  AutoPushClipRect(nsRenderingContext& aCtx, const nsRect& aRect)
-    : mCtx(aCtx) {
-    mCtx.PushState();
-    mCtx.IntersectClip(aRect);
+  AutoPushClipRect(gfxContext* aThebesContext, int32_t aAppUnitsPerGfxUnit,
+                   const nsRect& aRect)
+    : mThebesContext(aThebesContext) {
+    mThebesContext->Save();
+    mThebesContext->NewPath();
+    gfxRect clip(NSAppUnitsToFloatPixels(aRect.x, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.y, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.width, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.height, aAppUnitsPerGfxUnit));
+    mThebesContext->Rectangle(clip);
+    mThebesContext->Clip();
   }
   ~AutoPushClipRect() {
-    mCtx.PopState();
+    mThebesContext->Restore();
   }
 };
 
 static nsPoint
 SnapToDevPixels(const gfxContext* aThebesContext, int32_t aAppUnitsPerGfxUnit,
                 const nsPoint& aPt)
 {
   gfxPoint pt(NSAppUnitsToFloatPixels(aPt.x, aAppUnitsPerGfxUnit),
               NSAppUnitsToFloatPixels(aPt.y, aAppUnitsPerGfxUnit));
   pt = aThebesContext->UserToDevice(pt);
   pt.Round();
   pt = aThebesContext->DeviceToUser(pt);
   return nsPoint(NSFloatPixelsToAppUnits(pt.x, aAppUnitsPerGfxUnit),
                  NSFloatPixelsToAppUnits(pt.y, aAppUnitsPerGfxUnit));
 }
 
+static void
+PaintRule(gfxContext* aThebesContext,
+          int32_t     aAppUnitsPerGfxUnit,
+          nsRect&     aRect)
+{
+  if (!aRect.IsEmpty()) {
+    aThebesContext->NewPath();
+    gfxRect rect(NSAppUnitsToFloatPixels(aRect.x, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.y, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.width, aAppUnitsPerGfxUnit),
+                 NSAppUnitsToFloatPixels(aRect.height, aAppUnitsPerGfxUnit));
+    aThebesContext->Rectangle(rect, true);
+    aThebesContext->Fill();
+  }
+}
+
 // paint a stretchy char by assembling glyphs vertically
 nsresult
-nsMathMLChar::PaintVertically(nsPresContext*      aPresContext,
-                              nsRenderingContext& aRenderingContext,
-                              nsFont&              aFont,
-                              nsStyleContext*      aStyleContext,
-                              nsGlyphTable*        aGlyphTable,
-                              nsRect&              aRect)
+nsMathMLChar::PaintVertically(nsPresContext* aPresContext,
+                              gfxContext*    aThebesContext,
+                              nsFont&        aFont,
+                              nsGlyphTable*  aGlyphTable,
+                              nsRect&        aRect)
 {
   // Get the device pixel size in the vertical direction.
   // (This makes no effort to optimize for non-translation transformations.)
   nscoord oneDevPixel = aPresContext->AppUnitsPerDevPixel();
 
   // get metrics data to be re-used later
   int32_t i = 0;
   nsGlyphCode ch, chdata[4];
-  nsBoundingMetrics bmdata[4];
   int32_t glue, bottom;
   nsGlyphCode chGlue = aGlyphTable->GlueOf(aPresContext, this);
-  for (int32_t j = 0; j < 4; ++j) {
-    switch (j) {
+  for (i = 0; i < 4; ++i) {
+    switch (i) {
       case 0:
         ch = aGlyphTable->TopOf(aPresContext, this);
         break;
       case 1:
         ch = aGlyphTable->MiddleOf(aPresContext, this);
-        if (!ch.Exists())
-          continue; // no middle
         break;
       case 2:
         ch = aGlyphTable->BottomOf(aPresContext, this);
         bottom = i;
         break;
       case 3:
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
-    // if (!ch.Exists()) glue is null, leave bounding metrics at 0
-    if (ch.Exists()) {
-      SetFontFamily(aStyleContext, aRenderingContext,
-                    aFont, aGlyphTable, ch, mFamily);
-      bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
-    }
     chdata[i] = ch;
-    ++i;
   }
   nscoord dx = aRect.x;
   nscoord offset[3], start[3], end[3];
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
   for (i = 0; i <= bottom; ++i) {
     ch = chdata[i];
-    const nsBoundingMetrics& bm = bmdata[i];
+    const nsBoundingMetrics& bm = mBmData[i];
     nscoord dy;
     if (0 == i) { // top
       dy = aRect.y + bm.ascent;
     }
     else if (bottom == i) { // bottom
       dy = aRect.y + aRect.height - bm.descent;
     }
     else { // middle
       dy = aRect.y + bm.ascent + (aRect.height - (bm.ascent + bm.descent))/2;
     }
     // _cairo_scaled_font_show_glyphs snaps origins to device pixels.
     // Do this now so that we can get the other dimensions right.
     // (This may not achieve much with non-rectangular transformations.)
-    dy = SnapToDevPixels(ctx, oneDevPixel, nsPoint(dx, dy)).y;
-    // abcissa passed to DrawString
+    dy = SnapToDevPixels(aThebesContext, oneDevPixel, nsPoint(dx, dy)).y;
+    // abcissa passed to DrawGlyph
     offset[i] = dy;
     // _cairo_scaled_font_glyph_device_extents rounds outwards to the nearest
     // pixel, so the bm values can include 1 row of faint pixels on each edge.
     // Don't rely on this pixel as it can look like a gap.
     start[i] = dy - bm.ascent + oneDevPixel; // top join
     end[i] = dy + bm.descent - oneDevPixel; // bottom join
   }
 
@@ -2034,36 +2171,35 @@ nsMathMLChar::PaintVertically(nsPresCont
     if (ch.Exists()) {
       nscoord dy = offset[i];
       // Draw a glyph in a clipped area so that we don't have hairy chars
       // pending outside
       nsRect clipRect = unionRect;
       // Clip at the join to get a solid edge (without overlap or gap), when
       // this won't change the glyph too much.  If the glyph is too small to
       // clip then we'll overlap rather than have a gap.
-      nscoord height = bmdata[i].ascent + bmdata[i].descent;
+      nscoord height = mBmData[i].ascent + mBmData[i].descent;
       if (ch == chGlue ||
           height * (1.0 - NS_MATHML_DELIMITER_FACTOR) > oneDevPixel) {
         if (0 == i) { // top
           clipRect.height = end[i] - clipRect.y;
         }
         else if (bottom == i) { // bottom
           clipRect.height -= start[i] - clipRect.y;
           clipRect.y = start[i];
         }
         else { // middle
           clipRect.y = start[i];
           clipRect.height = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
-        AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aStyleContext, aRenderingContext,
-                      aFont, aGlyphTable, ch, mFamily);
-        aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
+        AutoPushClipRect clip(aThebesContext, oneDevPixel, clipRect);
+        SetFontFamily(aPresContext, aGlyphTable, ch, mFamily, aFont);
+        DrawGlyph(aThebesContext, mGlyphs[i], dx, dy);
       }
     }
   }
 
   ///////////////
   // fill the gap between top and middle, and between middle and bottom.
   if (!chGlue.Exists()) { // null glue : draw a rule
     // figure out the dimensions of the rule to be drawn :
@@ -2072,67 +2208,65 @@ nsMathMLChar::PaintVertically(nsPresCont
     // set rbearing to leftmost rbearing among the two current successive parts.
     // this not only satisfies the convention used for over/underbraces
     // in TeX, but also takes care of broken fonts like the stretchy integral
     // in Symbol for small font sizes in unix.
     nscoord lbearing, rbearing;
     int32_t first = 0, last = 1;
     while (last <= bottom) {
       if (chdata[last].Exists()) {
-        lbearing = bmdata[last].leftBearing;
-        rbearing = bmdata[last].rightBearing;
+        lbearing = mBmData[last].leftBearing;
+        rbearing = mBmData[last].rightBearing;
         if (chdata[first].Exists()) {
-          if (lbearing < bmdata[first].leftBearing)
-            lbearing = bmdata[first].leftBearing;
-          if (rbearing > bmdata[first].rightBearing)
-            rbearing = bmdata[first].rightBearing;
+          if (lbearing < mBmData[first].leftBearing)
+            lbearing = mBmData[first].leftBearing;
+          if (rbearing > mBmData[first].rightBearing)
+            rbearing = mBmData[first].rightBearing;
         }
       }
       else if (chdata[first].Exists()) {
-        lbearing = bmdata[first].leftBearing;
-        rbearing = bmdata[first].rightBearing;
+        lbearing = mBmData[first].leftBearing;
+        rbearing = mBmData[first].rightBearing;
       }
       else {
         NS_ERROR("Cannot stretch - All parts missing");
         return NS_ERROR_UNEXPECTED;
       }
       // paint the rule between the parts
       nsRect rule(aRect.x + lbearing, end[first],
                   rbearing - lbearing, start[last] - end[first]);
-      if (!rule.IsEmpty())
-        aRenderingContext.FillRect(rule);
+      PaintRule(aThebesContext, oneDevPixel, rule);
       first = last;
       last++;
     }
   }
-  else if (bmdata[glue].ascent + bmdata[glue].descent > 0) {
+  else if (mBmData[glue].ascent + mBmData[glue].descent > 0) {
     // glue is present
-    nsBoundingMetrics& bm = bmdata[glue];
+    nsBoundingMetrics& bm = mBmData[glue];
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.ascent + bm.descent >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.ascent -= oneDevPixel;
       bm.descent -= oneDevPixel;
     }
 
-    SetFontFamily(aStyleContext, aRenderingContext,
-                  aFont, aGlyphTable, chGlue, mFamily);
+    SetFontFamily(aPresContext, aGlyphTable, chGlue, mFamily, aFont);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < bottom; ++i) {
       // Make sure not to draw outside the character
       nscoord dy = std::max(end[i], aRect.y);
       nscoord fillEnd = std::min(start[i+1], aRect.YMost());
       while (dy < fillEnd) {
         clipRect.y = dy;
         clipRect.height = std::min(bm.ascent + bm.descent, fillEnd - dy);
-        AutoPushClipRect clip(aRenderingContext, clipRect);
+        AutoPushClipRect clip(aThebesContext, oneDevPixel, clipRect);
         dy += bm.ascent;
-        aRenderingContext.DrawString(chGlue.code, chGlue.Length(), dx, dy);
+        DrawGlyph(aThebesContext, mGlyphs[glue], dx, dy);
         dy += bm.descent;
       }
     }
   }
 #ifdef DEBUG
   else {
     for (i = 0; i < bottom; ++i) {
       NS_ASSERTION(end[i] >= start[i+1],
@@ -2140,84 +2274,72 @@ nsMathMLChar::PaintVertically(nsPresCont
     }
   }
 #endif
   return NS_OK;
 }
 
 // paint a stretchy char by assembling glyphs horizontally
 nsresult
-nsMathMLChar::PaintHorizontally(nsPresContext*      aPresContext,
-                                nsRenderingContext& aRenderingContext,
-                                nsFont&              aFont,
-                                nsStyleContext*      aStyleContext,
-                                nsGlyphTable*        aGlyphTable,
-                                nsRect&              aRect)
+nsMathMLChar::PaintHorizontally(nsPresContext* aPresContext,
+                                gfxContext*    aThebesContext,
+                                nsFont&        aFont,
+                                nsGlyphTable*  aGlyphTable,
+                                nsRect&        aRect)
 {
   // Get the device pixel size in the horizontal direction.
   // (This makes no effort to optimize for non-translation transformations.)
   nscoord oneDevPixel = aPresContext->AppUnitsPerDevPixel();
 
   // get metrics data to be re-used later
   int32_t i = 0;
   nsGlyphCode ch, chdata[4];
-  nsBoundingMetrics bmdata[4];
   int32_t glue, right;
   nsGlyphCode chGlue = aGlyphTable->GlueOf(aPresContext, this);
-  for (int32_t j = 0; j < 4; ++j) {
-    switch (j) {
+  for (int32_t i = 0; i < 4; ++i) {
+    switch (i) {
       case 0:
         ch = aGlyphTable->LeftOf(aPresContext, this);
         break;
       case 1:
         ch = aGlyphTable->MiddleOf(aPresContext, this);
-        if (!ch.Exists())
-          continue; // no middle
         break;
       case 2:
         ch = aGlyphTable->RightOf(aPresContext, this);
         right = i;
         break;
       case 3:
         ch = chGlue;
         glue = i;
         break;
     }
     // empty slots are filled with the glue if it is not null
     if (!ch.Exists()) ch = chGlue;
-    // if (!ch.Exists()) glue is null, leave bounding metrics at 0.
-    if (ch.Exists()) {
-      SetFontFamily(aStyleContext, aRenderingContext,
-                    aFont, aGlyphTable, ch, mFamily);
-      bmdata[i] = aRenderingContext.GetBoundingMetrics(ch.code, ch.Length());
-    }
     chdata[i] = ch;
-    ++i;
   }
   nscoord dy = aRect.y + mBoundingMetrics.ascent;
   nscoord offset[3], start[3], end[3];
-  nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
   for (i = 0; i <= right; ++i) {
     ch = chdata[i];
-    const nsBoundingMetrics& bm = bmdata[i];
+    const nsBoundingMetrics& bm = mBmData[i];
     nscoord dx;
     if (0 == i) { // left
       dx = aRect.x - bm.leftBearing;
     }
     else if (right == i) { // right
       dx = aRect.x + aRect.width - bm.rightBearing;
     }
     else { // middle
       dx = aRect.x + (aRect.width - bm.width)/2;
     }
     // _cairo_scaled_font_show_glyphs snaps origins to device pixels.
     // Do this now so that we can get the other dimensions right.
     // (This may not achieve much with non-rectangular transformations.)
-    dx = SnapToDevPixels(ctx, oneDevPixel, nsPoint(dx, dy)).x;
-    // abcissa passed to DrawString
+    dx = SnapToDevPixels(aThebesContext, oneDevPixel, nsPoint(dx, dy)).x;
+    // abcissa passed to DrawGlyph
     offset[i] = dx;
     // _cairo_scaled_font_glyph_device_extents rounds outwards to the nearest
     // pixel, so the bm values can include 1 row of faint pixels on each edge.
     // Don't rely on this pixel as it can look like a gap.
     start[i] = dx + bm.leftBearing + oneDevPixel; // left join
     end[i] = dx + bm.rightBearing - oneDevPixel; // right join
   }
 
@@ -2238,103 +2360,100 @@ nsMathMLChar::PaintHorizontally(nsPresCo
     ch = chdata[i];
     // glue can be null, and other parts could have been set to glue
     if (ch.Exists()) {
       nscoord dx = offset[i];
       nsRect clipRect = unionRect;
       // Clip at the join to get a solid edge (without overlap or gap), when
       // this won't change the glyph too much.  If the glyph is too small to
       // clip then we'll overlap rather than have a gap.
-      nscoord width = bmdata[i].rightBearing - bmdata[i].leftBearing;
+      nscoord width = mBmData[i].rightBearing - mBmData[i].leftBearing;
       if (ch == chGlue ||
           width * (1.0 - NS_MATHML_DELIMITER_FACTOR) > oneDevPixel) {
         if (0 == i) { // left
           clipRect.width = end[i] - clipRect.x;
         }
         else if (right == i) { // right
           clipRect.width -= start[i] - clipRect.x;
           clipRect.x = start[i];
         }
         else { // middle
           clipRect.x = start[i];
           clipRect.width = end[i] - start[i];
         }
       }
       if (!clipRect.IsEmpty()) {
-        AutoPushClipRect clip(aRenderingContext, clipRect);
-        SetFontFamily(aStyleContext, aRenderingContext,
-                      aFont, aGlyphTable, ch, mFamily);
-        aRenderingContext.DrawString(ch.code, ch.Length(), dx, dy);
+        AutoPushClipRect clip(aThebesContext, oneDevPixel, clipRect);
+        SetFontFamily(aPresContext, aGlyphTable, ch, mFamily, aFont);
+        DrawGlyph(aThebesContext, mGlyphs[i], dx, dy);
       }
     }
   }
 
   ////////////////
   // fill the gap between left and middle, and between middle and right.
   if (!chGlue.Exists()) { // null glue : draw a rule
     // figure out the dimensions of the rule to be drawn :
     // set ascent to lowest ascent among the two current successive parts.
     // set descent to highest descent among the two current successive parts.
     // this satisfies the convention used for over/underbraces, and helps
     // fix broken fonts.
     nscoord ascent, descent;
     int32_t first = 0, last = 1;
     while (last <= right) {
       if (chdata[last].Exists()) {
-        ascent = bmdata[last].ascent;
-        descent = bmdata[last].descent;
+        ascent = mBmData[last].ascent;
+        descent = mBmData[last].descent;
         if (chdata[first].Exists()) {
-          if (ascent > bmdata[first].ascent)
-            ascent = bmdata[first].ascent;
-          if (descent > bmdata[first].descent)
-            descent = bmdata[first].descent;
+          if (ascent > mBmData[first].ascent)
+            ascent = mBmData[first].ascent;
+          if (descent > mBmData[first].descent)
+            descent = mBmData[first].descent;
         }
       }
       else if (chdata[first].Exists()) {
-        ascent = bmdata[first].ascent;
-        descent = bmdata[first].descent;
+        ascent = mBmData[first].ascent;
+        descent = mBmData[first].descent;
       }
       else {
         NS_ERROR("Cannot stretch - All parts missing");
         return NS_ERROR_UNEXPECTED;
       }
       // paint the rule between the parts
       nsRect rule(end[first], dy - ascent,
                   start[last] - end[first], ascent + descent);
-      if (!rule.IsEmpty())
-        aRenderingContext.FillRect(rule);
+      PaintRule(aThebesContext, oneDevPixel, rule);
       first = last;
       last++;
     }
   }
-  else if (bmdata[glue].rightBearing - bmdata[glue].leftBearing > 0) {
+  else if (mBmData[glue].rightBearing - mBmData[glue].leftBearing > 0) {
     // glue is present
-    nsBoundingMetrics& bm = bmdata[glue];
+    nsBoundingMetrics& bm = mBmData[glue];
     // Ensure the stride for the glue is not reduced to less than one pixel
     if (bm.rightBearing - bm.leftBearing >= 3 * oneDevPixel) {
       // To protect against gaps, pretend the glue is smaller than it is,
       // in order to trim off ends and thus get a solid edge for the join.
       bm.leftBearing += oneDevPixel;
       bm.rightBearing -= oneDevPixel;
     }
 
-    SetFontFamily(aStyleContext, aRenderingContext,
-                  aFont, aGlyphTable, chGlue, mFamily);
+    SetFontFamily(aPresContext, aGlyphTable, chGlue, mFamily, aFont);
     nsRect clipRect = unionRect;
 
     for (i = 0; i < right; ++i) {
       // Make sure not to draw outside the character
       nscoord dx = std::max(end[i], aRect.x);
       nscoord fillEnd = std::min(start[i+1], aRect.XMost());
       while (dx < fillEnd) {
         clipRect.x = dx;
         clipRect.width = std::min(bm.rightBearing - bm.leftBearing, fillEnd - dx);
-        AutoPushClipRect clip(aRenderingContext, clipRect);
+        AutoPushClipRect clip(aThebesContext, oneDevPixel, clipRect);
         dx -= bm.leftBearing;
-        aRenderingContext.DrawString(chGlue.code, chGlue.Length(), dx, dy);
+        DrawGlyph(aThebesContext, mGlyphs[glue], dx, dy);
         dx += bm.rightBearing;
       }
     }
   }
 #ifdef DEBUG
   else { // no glue
     for (i = 0; i < right; ++i) {
       NS_ASSERTION(end[i] >= start[i+1],
diff --git a/layout/mathml/nsMathMLChar.h b/layout/mathml/nsMathMLChar.h
--- a/layout/mathml/nsMathMLChar.h
+++ b/layout/mathml/nsMathMLChar.h
@@ -1,21 +1,23 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsMathMLChar_h___
 #define nsMathMLChar_h___
 
+#include "nsAutoPtr.h"
 #include "nsMathMLOperators.h"
 #include "nsPoint.h"
 #include "nsRect.h"
 #include "nsString.h"
 #include "nsBoundingMetrics.h"
+#include "nsFontMetrics.h"
 
 class nsGlyphTable;
 class nsIFrame;
 class nsDisplayListBuilder;
 class nsDisplayListSet;
 class nsPresContext;
 class nsRenderingContext;
 class nsBoundingMetrics;
@@ -36,34 +38,45 @@ enum {
   NS_STRETCH_LARGEOP  = 0x10,
   NS_STRETCH_INTEGRAL  = 0x20,
 
   // Intended for internal use:
   // Find the widest metrics that might be returned from a vertical stretch
   NS_STRETCH_MAXWIDTH = 0x40
 };
 
-// A single glyph in our internal representation is characterized by a
-// 'code@font' pair. The 'code' is interpreted as a Unicode point or as the
-// direct glyph index (depending on the type of nsGlyphTable where this comes
-// from). The 'font' is a numeric identifier given to the font to which the
-// glyph belongs.
+// A single glyph in our internal representation is either
+// 1) a 'code@font' pair from the mathfontFONTFAMILY.properties table. The
+// 'code' is interpreted as a Unicode point. The 'font' is a numeric
+// identifier given to the font to which the glyph belongs, which is 0 for the
+// FONTFAMILY and > 0 for 'external' fonts.
+// 2) a glyph index from the Open Type MATH table. In that case, all the glyphs
+// come from the font containing that table and 'font' is just set to -1.
 struct nsGlyphCode {
-  PRUnichar code[2]; 
-  int32_t   font;
+  union {
+    PRUnichar code[2];
+    uint32_t glyphID;
+  };
+  int8_t   font;
 
-  int32_t Length() { return (code[1] == PRUnichar('\0') ? 1 : 2); }
+  bool IsGlyphID() const { return font == -1; }
+
+  int32_t Length() const {
+    return (IsGlyphID() || code[1] == PRUnichar('\0') ? 1 : 2);
+  }
   bool Exists() const
   {
-    return (code[0] != 0);
+    return IsGlyphID() ? glyphID != 0 : code[0] != 0;
   }
   bool operator==(const nsGlyphCode& other) const
   {
-    return (other.code[0] == code[0] && other.code[1] == code[1] && 
-            other.font == font);
+    return (other.font == font && other.IsGlyphID() == IsGlyphID() &&
+            ((IsGlyphID() && other.glyphID == glyphID) ||
+             (!IsGlyphID() && other.code[0] == code[0] &&
+              other.code[1] == code[1])));
   }
   bool operator!=(const nsGlyphCode& other) const
   {
     return ! operator==(other);
   }
 };
 
 // Class used to handle stretchy symbols (accent, delimiter and boundary
@@ -72,17 +85,17 @@ class nsMathMLChar
 {
 public:
   // constructor and destructor
   nsMathMLChar() {
     MOZ_COUNT_CTOR(nsMathMLChar);
     mStyleContext = nullptr;
     mUnscaledAscent = 0;
     mScaleX = mScaleY = 1.0;
-    mDrawNormal = true;
+    mDraw = DRAW_NORMAL;
     mMirrored = false;
   }
 
   // not a virtual destructor: this class is not intended to be subclassed
   ~nsMathMLChar();
 
   void Display(nsDisplayListBuilder*   aBuilder,
                nsIFrame*               aForFrame,
@@ -188,57 +201,91 @@ protected:
   friend class nsGlyphTable;
   nsString           mData;
 
 private:
   nsRect             mRect;
   nsStretchDirection mDirection;
   nsBoundingMetrics  mBoundingMetrics;
   nsStyleContext*    mStyleContext;
+
+  nsRefPtr<nsFontMetrics> mFontMetrics;
+
   nsGlyphTable*      mGlyphTable;
-  nsGlyphCode        mGlyph;
+  // mGlyphs/mBmData are arrays describing the glyphs used to draw the operator.
+  // See the drawing methods below.
+  nsGlyphCode        mGlyphs[4];
+  nsBoundingMetrics  mBmData[4];
   // mFamily is non-empty when the family for the current size is different
   // from the family in the nsStyleContext.
   nsString           mFamily;
   // mUnscaledAscent is the actual ascent of the char.
   nscoord            mUnscaledAscent;
   // mScaleX, mScaleY are the factors by which we scale the char.
   float              mScaleX, mScaleY;
-  // mDrawNormal indicates whether we use special glyphs or not.
-  bool               mDrawNormal;
+
+  // mDraw indicates how we draw the stretchy operator:
+  // - DRAW_NORMAL: we render the mData string normally.
+  // - DRAW_VARIANT: we draw a larger size variant given by mGlyphs[0].
+  // - DRAW_PARTS: we assemble several parts given by mGlyphs[0], ... mGlyphs[4]
+  // XXXfredw: the MATH table can have any numbers of parts and extenders.
+  typedef enum {
+    DRAW_NORMAL, DRAW_VARIANT, DRAW_PARTS
+  } DrawingMethod;
+  DrawingMethod mDraw;
+
   // mMirrored indicates whether the character is mirrored. 
   bool               mMirrored;
 
   class StretchEnumContext;
   friend class StretchEnumContext;
 
   // helper methods
+  bool
+  SetFontFamily(nsPresContext*      aPresContext,
+                const nsGlyphTable* aGlyphTable,
+                const nsGlyphCode&  aGlyphCode,
+                const nsAString&    aDefaultFamily,
+                nsFont&             aFont);
+
+  gfxTextRun*
+  MakeTextRun(gfxContext* aThebesContext, const nsGlyphCode& aGlyph);
+
+  nsBoundingMetrics
+  MeasureGlyph(gfxContext*        aThebesContext,
+               const nsGlyphCode& aGlyphCode);
+
+  void
+  DrawGlyph(gfxContext*         aThebesContext,
+            const nsGlyphCode&  aGlyph,
+            nscoord             dx,
+            nscoord             dy);
+
   nsresult
   StretchInternal(nsPresContext*           aPresContext,
-                  nsRenderingContext&     aRenderingContext,
+                  gfxContext*              aThebesContext,
                   nsStretchDirection&      aStretchDirection,
                   const nsBoundingMetrics& aContainerSize,
                   nsBoundingMetrics&       aDesiredStretchSize,
                   uint32_t                 aStretchHint,
                   float           aMaxSize = NS_MATHML_OPERATOR_SIZE_INFINITY,
                   bool            aMaxSizeIsAbsolute = false);
 
   nsresult
-  PaintVertically(nsPresContext*       aPresContext,
-                  nsRenderingContext& aRenderingContext,
-                  nsFont&              aFont,
-                  nsStyleContext*      aStyleContext,
-                  nsGlyphTable*        aGlyphTable,
-                  nsRect&              aRect);
+  PaintVertically(nsPresContext* aPresContext,
+                  gfxContext*    aThebesContext,
+                  nsFont&        aFont,
+                  nsGlyphTable*  aGlyphTable,
+                  nsRect&        aRect);
 
   nsresult
-  PaintHorizontally(nsPresContext*       aPresContext,
-                    nsRenderingContext& aRenderingContext,
-                    nsFont&              aFont,
-                    nsStyleContext*      aStyleContext,
-                    nsGlyphTable*        aGlyphTable,
-                    nsRect&              aRect);
+  PaintHorizontally(nsPresContext* aPresContext,
+                    gfxContext*    aThebesContext,
+                    nsFont&        aFont,
+                    nsGlyphTable*  aGlyphTable,
+                    nsRect&        aRect);
 
   void
-  ApplyTransforms(nsRenderingContext& aRenderingContext, nsRect &r);
+  ApplyTransforms(gfxContext* aThebesContext, int32_t aAppUnitsPerGfxUnit,
+                  nsRect &r);
 };
 
 #endif /* nsMathMLChar_h___ */
