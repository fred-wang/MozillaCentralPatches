# HG changeset patch
# Parent ad04d9e92b2428894b5d78dfd3cf8cc8f63c9a07
# User Frédéric Wang <fred.wang@free.fr>
Part 5 - Use MATH constants for limits. r=karl, b=961365

diff --git a/layout/mathml/nsMathMLmunderoverFrame.cpp b/layout/mathml/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/nsMathMLmunderoverFrame.cpp
@@ -392,43 +392,63 @@ nsMathMLmunderoverFrame::Place(nsRenderi
 
   if (!NS_MATHML_EMBELLISH_IS_ACCENTUNDER(mEmbellishData.flags)) {
     // Rule 13a, App. G, TeXbook
     nscoord bigOpSpacing2, bigOpSpacing4, bigOpSpacing5, dummy; 
     GetBigOpSpacings (fm, 
                       dummy, bigOpSpacing2, 
                       dummy, bigOpSpacing4, 
                       bigOpSpacing5);
+    if (TryGetMathTable(fm)) {
+      // XXXfredw The Open Type MATH table has some StretchStack* parameters
+      // that we may use when the base is a stretchy horizontal operator.
+      GetMathConstantEm(fm,
+                        gfxFontEntry::LowerLimitGapMin, bigOpSpacing2);
+      GetMathConstantEm(fm,
+                        gfxFontEntry::LowerLimitBaselineDropMin, bigOpSpacing4);
+      bigOpSpacing5 = 0;
+    }
     underDelta1 = std::max(bigOpSpacing2, (bigOpSpacing4 - bmUnder.ascent));
     underDelta2 = bigOpSpacing5;
   }
   else {
     // No corresponding rule in TeXbook - we are on our own here
     // XXX tune the gap delta between base and underscript 
-
-    // Should we use Rule 10 like \underline does?
+    // XXX Should we use Rule 10 like \underline does?
+    // XXXfredw Perhaps use the Underbar* parameters of the MATH table.
     underDelta1 = ruleThickness + onePixel/2;
     underDelta2 = ruleThickness;
   }
   // empty under?
   if (!(bmUnder.ascent + bmUnder.descent)) {
     underDelta1 = 0;
     underDelta2 = 0;
   }
 
   nscoord overDelta1 = 0; // gap between base and overscript
   nscoord overDelta2 = 0; // extra space above overscript
 
   if (!NS_MATHML_EMBELLISH_IS_ACCENTOVER(mEmbellishData.flags)) {    
     // Rule 13a, App. G, TeXbook
+    // XXXfredw The Open Type MATH table has some StretchStack* parameters
+    // that we may use when the base is a stretchy horizontal operator.
     nscoord bigOpSpacing1, bigOpSpacing3, bigOpSpacing5, dummy; 
     GetBigOpSpacings (fm, 
                       bigOpSpacing1, dummy, 
                       bigOpSpacing3, dummy, 
                       bigOpSpacing5);
+    if (TryGetMathTable(fm)) {
+      // XXXfredw The Open Type MATH table has some StretchStack* parameters
+      // that we may use when the base is a stretchy horizontal operator.
+      GetMathConstantEm(fm,
+                        gfxFontEntry::UpperLimitGapMin, bigOpSpacing1);
+      GetMathConstantEm(fm,
+                        gfxFontEntry::UpperLimitBaselineRiseMin, bigOpSpacing3);
+      bigOpSpacing5 = 0;
+    }
     overDelta1 = std::max(bigOpSpacing1, (bigOpSpacing3 - bmOver.descent));
     overDelta2 = bigOpSpacing5;
 
     // XXX This is not a TeX rule... 
     // delta1 (as computed abvove) can become really big when bmOver.descent is
     // negative,  e.g., if the content is &OverBar. In such case, we use the height
     if (bmOver.descent < 0)    
       overDelta1 = std::max(bigOpSpacing1, (bigOpSpacing3 - (bmOver.ascent + bmOver.descent)));
@@ -459,19 +479,21 @@ nsMathMLmunderoverFrame::Place(nsRenderi
     // do not follow this convention. So we modify TeX's rule 
     // so that TeX's rule gets subsumed for accents that follow 
     // TeX's convention,
     // while also allowing accents that do not follow the convention :
     // we try to keep the *bottom* of the accent char atleast x-height 
     // from the baseline of the base char. we also slap on an extra
     // padding between the accent and base chars.
     overDelta1 = ruleThickness + onePixel/2;
-    if (bmBase.ascent < xHeight) {
-      // also ensure at least x-height above the baseline of the base
-      overDelta1 += xHeight - bmBase.ascent;
+    nscoord accentBaseHeight = xHeight;
+    GetMathConstantEm(fm, gfxFontEntry::AccentBaseHeight, accentBaseHeight);
+    if (bmBase.ascent < accentBaseHeight) {
+      // also ensure at least accentBaseHeight above the baseline of the base
+      overDelta1 += accentBaseHeight - bmBase.ascent;
     }
     overDelta2 = ruleThickness;
   }
   // empty over?
   if (!(bmOver.ascent + bmOver.descent)) {
     overDelta1 = 0;
     overDelta2 = 0;
   }
