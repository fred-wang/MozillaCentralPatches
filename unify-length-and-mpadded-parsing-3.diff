# HG changeset patch
# Parent 92e7e559f2e76dc05993a43ae1ac1c0305cf0aff
# User Frédéric Wang <fred.wang@free.fr>
Unify Mpadded and Length attributes parsing (bug 677036) - part 1

diff --git a/content/mathml/content/src/nsMathMLElement.cpp b/content/mathml/content/src/nsMathMLElement.cpp
--- a/content/mathml/content/src/nsMathMLElement.cpp
+++ b/content/mathml/content/src/nsMathMLElement.cpp
@@ -305,28 +305,34 @@ Implementation here:
   [h/v-unit]
 */
 
 /* static */ bool
 nsMathMLElement::ParseNumericValue(const nsString& aString,
                                    nsCSSValue&     aCSSValue,
                                    PRUint32        aFlags)
 {
+  MpaddedPseudoUnitWrite(aFlags, NS_MATHML_PSEUDO_UNIT_UNSPECIFIED);
+  MpaddedSignWrite(aFlags, NS_MATHML_SIGN_INVALID);
+
+  if (aFlags & PARSE_MPADDED_SYNTAX) {
+    // not implemented yet
+    return false;
+  }
+
   nsAutoString str(aString);
   str.CompressWhitespace(); // aString is const in this code...
 
   PRInt32 stringLength = str.Length();
   if (!stringLength)
     return false;
 
   if (aFlags & PARSE_ALLOW_NAMEDSPACE) {
     if (ParseNamedSpaceValue(aString, aCSSValue, aFlags)) {
       return true;
-    } else if (aFlags & PARSE_CALLED_FROM_MPADDED_FRAME) {
-      return false;
     }
   }
 
   nsAutoString number, unit;
 
   // see if the negative sign is there
   PRInt32 i = 0;
   PRUnichar c = str[0];
diff --git a/content/mathml/content/src/nsMathMLElement.h b/content/mathml/content/src/nsMathMLElement.h
--- a/content/mathml/content/src/nsMathMLElement.h
+++ b/content/mathml/content/src/nsMathMLElement.h
@@ -81,24 +81,60 @@ public:
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
 
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
 
   enum {
+    // IN parameters
     PARSE_ALLOW_UNITLESS = 0x01, // unitless 0 will be turned into 0px
     PARSE_ALLOW_NEGATIVE = 0x02,
     PARSE_ALLOW_NAMEDSPACE = 0x04,
-    // mpadded uses its own format for attribute values but relies on
-    // ParseNumericValue to parse some substrings. This flag allows to handle
-    // these calls in a specific way. See also bug 677036.
-    PARSE_CALLED_FROM_MPADDED_FRAME = 0x08
+    PARSE_MPADDED_SYNTAX = 0x08,
+
+    // IN/OUT parameters
+    NS_MATHML_SIGN_INVALID = 0 << 4,
+    NS_MATHML_SIGN_UNSPECIFIED = 1 << 4,
+    NS_MATHML_SIGN_PLUS = 2 << 4,
+    NS_MATHML_SIGN_MINUS = 3 << 4,
+    NS_MATHML_PSEUDO_UNIT_UNSPECIFIED = 0 << 6,
+    NS_MATHML_PSEUDO_UNIT_ITSELF = 1 << 6,
+    NS_MATHML_PSEUDO_UNIT_HEIGHT = 2 << 6,
+    NS_MATHML_PSEUDO_UNIT_DEPTH =  3 << 6,
+    NS_MATHML_PSEUDO_UNIT_WIDTH = 4 << 6,
+    NS_MATHML_PSEUDO_UNIT_NAMEDSPACE = 5 << 6
   };
+
+  enum {
+    NS_MATHML_SIGN_MASK = 3 << 4,
+    NS_MATHML_PSEUDO_UNIT_MASK = 7 << 6
+  };
+
+  static void MpaddedSignWrite(PRUint32& aFlags, PRUint32 aValue)
+  {
+    aFlags = ((aFlags & (~NS_MATHML_SIGN_MASK)) | aValue);
+  };
+
+  static void MpaddedPseudoUnitWrite(PRUint32& aFlags, PRUint32 aValue)
+  {
+    aFlags = ((aFlags & (~NS_MATHML_PSEUDO_UNIT_MASK)) | aValue);
+  };
+
+  static PRUint32 MpaddedSignRead(PRUint32 aFlags)
+  {
+    return  (aFlags & NS_MATHML_SIGN_MASK);
+  };
+
+  static PRUint32 MpaddedPseudoUnitRead(PRUint32 aFlags)
+  {
+    return  (aFlags & NS_MATHML_PSEUDO_UNIT_MASK);
+  };
+
   static bool ParseNamedSpaceValue(const nsString& aString,
                                    nsCSSValue&     aCSSValue,
                                    PRUint32        aFlags);
 
   static bool ParseNumericValue(const nsString& aString,
                                   nsCSSValue&     aCSSValue,
                                   PRUint32        aFlags);
 
diff --git a/layout/mathml/nsMathMLmpaddedFrame.cpp b/layout/mathml/nsMathMLmpaddedFrame.cpp
--- a/layout/mathml/nsMathMLmpaddedFrame.cpp
+++ b/layout/mathml/nsMathMLmpaddedFrame.cpp
@@ -35,40 +35,27 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 
 #include "nsCOMPtr.h"
-#include "nsCRT.h"  // to get NS_IS_SPACE
 #include "nsFrame.h"
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsStyleConsts.h"
 
 #include "nsMathMLmpaddedFrame.h"
 
 //
 // <mpadded> -- adjust space around content - implementation
 //
 
-#define NS_MATHML_SIGN_INVALID           -1 // if the attribute is not there
-#define NS_MATHML_SIGN_UNSPECIFIED        0
-#define NS_MATHML_SIGN_MINUS              1
-#define NS_MATHML_SIGN_PLUS               2
-
-#define NS_MATHML_PSEUDO_UNIT_UNSPECIFIED 0
-#define NS_MATHML_PSEUDO_UNIT_ITSELF      1 // special
-#define NS_MATHML_PSEUDO_UNIT_WIDTH       2
-#define NS_MATHML_PSEUDO_UNIT_HEIGHT      3
-#define NS_MATHML_PSEUDO_UNIT_DEPTH       4
-#define NS_MATHML_PSEUDO_UNIT_NAMEDSPACE  5
-
 nsIFrame*
 NS_NewMathMLmpaddedFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsMathMLmpaddedFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmpaddedFrame)
 
@@ -85,257 +72,103 @@ nsMathMLmpaddedFrame::InheritAutomaticDa
   mPresentationData.flags |= NS_MATHML_STRETCH_ALL_CHILDREN_VERTICALLY;
 
   return NS_OK;
 }
 
 void
 nsMathMLmpaddedFrame::ProcessAttributes()
 {
-  /*
-  parse the attributes
-
-  width  = [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | h-unit | namedspace)
-  height = [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | v-unit | namedspace)
-  depth  = [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | v-unit | namedspace)
-  lspace = [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | h-unit | namedspace)
-  voffset= [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | v-unit | namedspace)
-  */
+  // Parse the attributes. The format is:
+  //
+  // ( "+" | "-" )? unsigned-number ( ("%" pseudo-unit?) |
+  //                                  pseudo-unit | unit | namedspace )
+  // The REC says:
+  //
+  // "There is one exceptional element, <mpadded>, whose attributes cannot be 
+  // set with <mstyle>. When the attributes width, height and depth are
+  // specified on an <mstyle> element, they apply only to the <mspace/> element.
+  // Similarly, when lspace is set with <mstyle>, it applies only to the <mo>
+  // element. To be consistent, the voffset attribute of the mpadded element can
+  // not be set on mstyle." 
+  //
+  // See if attributes are local, don't access mstyle !
 
   nsAutoString value;
 
-  /* The REC says:
-  There is one exceptional element, <mpadded>, whose attributes cannot be 
-  set with <mstyle>. When the attributes width, height and depth are specified
-  on an <mstyle> element, they apply only to the <mspace/> element. Similarly, 
-  when lspace is set with <mstyle>, it applies only to the <mo> element. 
-  */
-
-  // See if attributes are local, don't access mstyle !
-
   // width
-  mWidthSign = NS_MATHML_SIGN_INVALID;
+  nsMathMLElement::MpaddedSignWrite(mWidthFlags,
+                                    nsMathMLElement::NS_MATHML_SIGN_INVALID);
   GetAttribute(mContent, nsnull, nsGkAtoms::width, value);
   if (!value.IsEmpty()) {
-    ParseAttribute(value, mWidthSign, mWidth, mWidthPseudoUnit);
+    nsMathMLElement::ParseNumericValue(value, mWidth, 
+                                       nsMathMLElement::PARSE_MPADDED_SYNTAX);
   }
 
   // height
-  mHeightSign = NS_MATHML_SIGN_INVALID;
+  nsMathMLElement::MpaddedSignWrite(mHeightFlags,
+                                    nsMathMLElement::NS_MATHML_SIGN_INVALID);
   GetAttribute(mContent, nsnull, nsGkAtoms::height, value);
   if (!value.IsEmpty()) {
-    ParseAttribute(value, mHeightSign, mHeight, mHeightPseudoUnit);
+    nsMathMLElement::ParseNumericValue(value, mHeight,
+                                       nsMathMLElement::PARSE_MPADDED_SYNTAX);
   }
 
   // depth
-  mDepthSign = NS_MATHML_SIGN_INVALID;
+  nsMathMLElement::MpaddedSignWrite(mDepthFlags,
+                                    nsMathMLElement::NS_MATHML_SIGN_INVALID);
   GetAttribute(mContent, nsnull, nsGkAtoms::depth_, value);
   if (!value.IsEmpty()) {
-    ParseAttribute(value, mDepthSign, mDepth, mDepthPseudoUnit);
+    nsMathMLElement::ParseNumericValue(value, mDepth,
+                                       nsMathMLElement::PARSE_MPADDED_SYNTAX);
   }
 
   // lspace
-  mLeadingSpaceSign = NS_MATHML_SIGN_INVALID;
+  nsMathMLElement::MpaddedSignWrite(mLeadingSpaceFlags,
+                                    nsMathMLElement::NS_MATHML_SIGN_INVALID);
   GetAttribute(mContent, nsnull, nsGkAtoms::lspace_, value);
   if (!value.IsEmpty()) {
-    ParseAttribute(value, mLeadingSpaceSign, mLeadingSpace,
-                   mLeadingSpacePseudoUnit);
+    nsMathMLElement::ParseNumericValue(value, mLeadingSpace,
+                                       nsMathMLElement::PARSE_MPADDED_SYNTAX);
   }
 
   // voffset
-  mVerticalOffsetSign = NS_MATHML_SIGN_INVALID;
+  nsMathMLElement::MpaddedSignWrite(mVerticalOffsetFlags,
+                                    nsMathMLElement::NS_MATHML_SIGN_INVALID);
   GetAttribute(mContent, nsnull, nsGkAtoms::voffset_, value);
   if (!value.IsEmpty()) {
-    ParseAttribute(value, mVerticalOffsetSign, mVerticalOffset, 
-                   mVerticalOffsetPseudoUnit);
+    nsMathMLElement::ParseNumericValue(value, mVerticalOffset,
+                                       nsMathMLElement::PARSE_MPADDED_SYNTAX);
   }
-  
-}
-
-// parse an input string in the following format (see bug 148326 for testcases):
-// [+|-] unsigned-number (% [pseudo-unit] | pseudo-unit | css-unit | namedspace)
-bool
-nsMathMLmpaddedFrame::ParseAttribute(nsString&   aString,
-                                     PRInt32&    aSign,
-                                     nsCSSValue& aCSSValue,
-                                     PRInt32&    aPseudoUnit)
-{
-  aCSSValue.Reset();
-  aSign = NS_MATHML_SIGN_INVALID;
-  aPseudoUnit = NS_MATHML_PSEUDO_UNIT_UNSPECIFIED;
-  aString.CompressWhitespace(); // aString is not a const in this code
-
-  PRInt32 stringLength = aString.Length();
-  if (!stringLength)
-    return false;
-
-  nsAutoString number, unit;
-
-  //////////////////////
-  // see if the sign is there
-
-  PRInt32 i = 0;
-
-  if (aString[0] == '+') {
-    aSign = NS_MATHML_SIGN_PLUS;
-    i++;
-  }
-  else if (aString[0] == '-') {
-    aSign = NS_MATHML_SIGN_MINUS;
-    i++;
-  }
-  else
-    aSign = NS_MATHML_SIGN_UNSPECIFIED;
-
-  // skip any space after the sign
-  if (i < stringLength && nsCRT::IsAsciiSpace(aString[i]))
-    i++;
-
-  // get the number
-  bool gotDot = false, gotPercent = false;
-  for (; i < stringLength; i++) {
-    PRUnichar c = aString[i];
-    if (gotDot && c == '.') {
-      // error - two dots encountered
-      aSign = NS_MATHML_SIGN_INVALID;
-      return false;
-    }
-
-    if (c == '.')
-      gotDot = true;
-    else if (!nsCRT::IsAsciiDigit(c)) {
-      break;
-    }
-    number.Append(c);
-  }
-
-  // catch error if we didn't enter the loop above... we could simply initialize
-  // floatValue = 1, to cater for cases such as width="height", but that wouldn't
-  // be in line with the spec which requires an explicit number
-  if (number.IsEmpty()) {
-#ifdef NS_DEBUG
-    printf("mpadded: attribute with bad numeric value: %s\n",
-            NS_LossyConvertUTF16toASCII(aString).get());
-#endif
-    aSign = NS_MATHML_SIGN_INVALID;
-    return false;
-  }
-
-  PRInt32 errorCode;
-  float floatValue = number.ToFloat(&errorCode);
-  if (errorCode) {
-    aSign = NS_MATHML_SIGN_INVALID;
-    return false;
-  }
-
-  // skip any space after the number
-  if (i < stringLength && nsCRT::IsAsciiSpace(aString[i]))
-    i++;
-
-  // see if this is a percentage-based value
-  if (i < stringLength && aString[i] == '%') {
-    i++;
-    gotPercent = true;
-
-    // skip any space after the '%' sign
-    if (i < stringLength && nsCRT::IsAsciiSpace(aString[i]))
-      i++;
-  }
-
-  // the remainder now should be a css-unit, or a pseudo-unit, or a named-space
-  aString.Right(unit, stringLength - i);
-
-  if (unit.IsEmpty()) {
-    // also cater for the edge case of "0" for which the unit is optional
-    if (gotPercent || !floatValue) {
-      aCSSValue.SetPercentValue(floatValue / 100.0f);
-      aPseudoUnit = NS_MATHML_PSEUDO_UNIT_ITSELF;
-      return true;
-    }
-    /*
-    else {
-      // no explicit CSS unit and no explicit pseudo-unit...
-      // In this case, the MathML REC suggests taking ems for
-      // h-unit (width, lspace) or exs for v-unit (height, depth).
-      // Here, however, we explicitly request authors to specify
-      // the unit. This is more in line with the CSS REC (and
-      // it allows keeping the code simpler...)
-    }
-    */
-  }
-  else if (unit.EqualsLiteral("width"))  aPseudoUnit = NS_MATHML_PSEUDO_UNIT_WIDTH;
-  else if (unit.EqualsLiteral("height")) aPseudoUnit = NS_MATHML_PSEUDO_UNIT_HEIGHT;
-  else if (unit.EqualsLiteral("depth"))  aPseudoUnit = NS_MATHML_PSEUDO_UNIT_DEPTH;
-  else if (!gotPercent) { // percentage can only apply to a pseudo-unit
-
-    // see if the unit is a named-space
-    if (nsMathMLElement::ParseNumericValue(unit, aCSSValue,
-                                           nsMathMLElement::
-                                           PARSE_CALLED_FROM_MPADDED_FRAME |
-                                           nsMathMLElement::
-                                           PARSE_ALLOW_NEGATIVE |
-                                           nsMathMLElement::
-                                           PARSE_ALLOW_NAMEDSPACE)) {
-      // re-scale properly, and we know that the unit of the named-space is 'em'
-      floatValue *= aCSSValue.GetFloatValue();
-      aCSSValue.SetFloatValue(floatValue, eCSSUnit_EM);
-      aPseudoUnit = NS_MATHML_PSEUDO_UNIT_NAMEDSPACE;
-      return true;
-    }
-
-    // see if the input was just a CSS value
-    number.Append(unit); // leave the sign out if it was there
-    if (nsMathMLElement::ParseNumericValue(number, aCSSValue,
-                                           nsMathMLElement::
-                                           PARSE_CALLED_FROM_MPADDED_FRAME))
-      return true;
-  }
-
-  // if we enter here, we have a number that will act as a multiplier on a pseudo-unit
-  if (aPseudoUnit != NS_MATHML_PSEUDO_UNIT_UNSPECIFIED) {
-    if (gotPercent)
-      aCSSValue.SetPercentValue(floatValue / 100.0f);
-    else
-      aCSSValue.SetFloatValue(floatValue, eCSSUnit_Number);
-
-    return true;
-  }
-
-
-#ifdef NS_DEBUG
-  printf("mpadded: attribute with bad numeric value: %s\n",
-          NS_LossyConvertUTF16toASCII(aString).get());
-#endif
-  // if we reach here, it means we encounter an unexpected input
-  aSign = NS_MATHML_SIGN_INVALID;
-  return false;
 }
 
 void
-nsMathMLmpaddedFrame::UpdateValue(PRInt32                  aSign,
-                                  PRInt32                  aPseudoUnit,
+nsMathMLmpaddedFrame::UpdateValue(PRInt32                  aFlags,
                                   const nsCSSValue&        aCSSValue,
                                   const nsBoundingMetrics& aBoundingMetrics,
                                   nscoord&                 aValueToUpdate) const
 {
+  PRUint32 sign = nsMathMLElement::MpaddedSignRead(aFlags);
   nsCSSUnit unit = aCSSValue.GetUnit();
-  if (NS_MATHML_SIGN_INVALID != aSign && eCSSUnit_Null != unit) {
+
+  if (sign != nsMathMLElement::NS_MATHML_SIGN_INVALID &&
+      unit != eCSSUnit_Null) {
     nscoord scaler = 0, amount = 0;
 
     if (eCSSUnit_Percent == unit || eCSSUnit_Number == unit) {
-      switch(aPseudoUnit) {
-        case NS_MATHML_PSEUDO_UNIT_WIDTH:
+      switch(nsMathMLElement::MpaddedPseudoUnitRead(aFlags)) {
+        case nsMathMLElement::NS_MATHML_PSEUDO_UNIT_WIDTH:
              scaler = aBoundingMetrics.width;
              break;
 
-        case NS_MATHML_PSEUDO_UNIT_HEIGHT:
+        case nsMathMLElement::NS_MATHML_PSEUDO_UNIT_HEIGHT:
              scaler = aBoundingMetrics.ascent;
              break;
 
-        case NS_MATHML_PSEUDO_UNIT_DEPTH:
+        case nsMathMLElement::NS_MATHML_PSEUDO_UNIT_DEPTH:
              scaler = aBoundingMetrics.descent;
              break;
 
         default:
           // if we ever reach here, it would mean something is wrong 
           // somewhere with the setup and/or the caller
           NS_ERROR("Unexpected Pseudo Unit");
           return;
@@ -344,39 +177,37 @@ nsMathMLmpaddedFrame::UpdateValue(PRInt3
 
     if (eCSSUnit_Number == unit)
       amount = NSToCoordRound(float(scaler) * aCSSValue.GetFloatValue());
     else if (eCSSUnit_Percent == unit)
       amount = NSToCoordRound(float(scaler) * aCSSValue.GetPercentValue());
     else
       amount = CalcLength(PresContext(), mStyleContext, aCSSValue);
 
-    if (NS_MATHML_SIGN_PLUS == aSign)
+    if (sign == nsMathMLElement::NS_MATHML_SIGN_PLUS)
       aValueToUpdate += amount;
-    else if (NS_MATHML_SIGN_MINUS == aSign)
+    else if (sign == nsMathMLElement::NS_MATHML_SIGN_MINUS)
       aValueToUpdate -= amount;
     else
       aValueToUpdate  = amount;
   }
 }
 
 NS_IMETHODIMP
 nsMathMLmpaddedFrame::Reflow(nsPresContext*          aPresContext,
                              nsHTMLReflowMetrics&     aDesiredSize,
                              const nsHTMLReflowState& aReflowState,
                              nsReflowStatus&          aStatus)
 {
   ProcessAttributes();
 
   ///////////////
   // Let the base class format our content like an inferred mrow
-  nsresult rv = nsMathMLContainerFrame::Reflow(aPresContext, aDesiredSize,
-                                               aReflowState, aStatus);
-  //NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus), "bad status");
-  return rv;
+  return nsMathMLContainerFrame::Reflow(aPresContext, aDesiredSize,
+                                        aReflowState, aStatus);
 }
 
 /* virtual */ nsresult
 nsMathMLmpaddedFrame::Place(nsRenderingContext& aRenderingContext,
                             bool                 aPlaceOrigin,
                             nsHTMLReflowMetrics& aDesiredSize)
 {
   nsresult rv =
@@ -411,68 +242,91 @@ nsMathMLmpaddedFrame::Place(nsRenderingC
   nscoord lspace = 0;
   // In MathML3, "width" will be the bounding box width and "advancewidth" will
   // refer "to the horizontal distance between the positioning point of the
   // mpadded and the positioning point for the following content".  MathML2
   // doesn't make the distinction.
   nscoord width  = mBoundingMetrics.width;
   nscoord voffset = 0;
 
-  PRInt32 pseudoUnit;
+  PRUint32 flags, sign, pseudoUnit;
   nscoord initialWidth = width;
 
   // update width
-  pseudoUnit = (mWidthPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
-             ? NS_MATHML_PSEUDO_UNIT_WIDTH : mWidthPseudoUnit;
-  UpdateValue(mWidthSign, pseudoUnit, mWidth,
-              mBoundingMetrics, width);
+  flags = mWidthFlags;
+  pseudoUnit = nsMathMLElement::MpaddedPseudoUnitRead(flags);
+  nsMathMLElement::MpaddedPseudoUnitWrite(flags,
+                                          (pseudoUnit ==
+                                           nsMathMLElement::
+                                           NS_MATHML_PSEUDO_UNIT_ITSELF) ?
+                                          nsMathMLElement::
+                                          NS_MATHML_PSEUDO_UNIT_WIDTH :
+                                          pseudoUnit);
+  UpdateValue(flags, mWidth, mBoundingMetrics, width);
   width = NS_MAX(0, width);
 
   // update "height" (this is the ascent in the terminology of the REC)
-  pseudoUnit = (mHeightPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
-             ? NS_MATHML_PSEUDO_UNIT_HEIGHT : mHeightPseudoUnit;
-  UpdateValue(mHeightSign, pseudoUnit, mHeight,
-              mBoundingMetrics, height);
+  flags = mHeightFlags;
+  pseudoUnit = nsMathMLElement::MpaddedPseudoUnitRead(flags);
+  nsMathMLElement::MpaddedPseudoUnitWrite(flags,
+                                          (pseudoUnit ==
+                                           nsMathMLElement::
+                                           NS_MATHML_PSEUDO_UNIT_ITSELF) ?
+                                          nsMathMLElement::
+                                          NS_MATHML_PSEUDO_UNIT_HEIGHT :
+                                          pseudoUnit);
+  UpdateValue(flags, mHeight, mBoundingMetrics, height);
   height = NS_MAX(0, height);
 
   // update "depth" (this is the descent in the terminology of the REC)
-  pseudoUnit = (mDepthPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
-             ? NS_MATHML_PSEUDO_UNIT_DEPTH : mDepthPseudoUnit;
-  UpdateValue(mDepthSign, pseudoUnit, mDepth,
-              mBoundingMetrics, depth);
+  flags = mDepthFlags;
+  pseudoUnit = nsMathMLElement::MpaddedPseudoUnitRead(flags);
+  nsMathMLElement::MpaddedPseudoUnitWrite(flags,
+                                          (pseudoUnit ==
+                                           nsMathMLElement::
+                                           NS_MATHML_PSEUDO_UNIT_ITSELF) ?
+                                          nsMathMLElement::
+                                          NS_MATHML_PSEUDO_UNIT_DEPTH :
+                                          pseudoUnit);
+  UpdateValue(flags, mDepth, mBoundingMetrics, depth);
   depth = NS_MAX(0, depth);
 
   // update lspace
-  if (mLeadingSpacePseudoUnit != NS_MATHML_PSEUDO_UNIT_ITSELF) {
-    pseudoUnit = mLeadingSpacePseudoUnit;
-    UpdateValue(mLeadingSpaceSign, pseudoUnit, mLeadingSpace,
-                mBoundingMetrics, lspace);
+  flags = mLeadingSpaceFlags;
+  if (nsMathMLElement::MpaddedPseudoUnitRead(flags) !=
+      nsMathMLElement::NS_MATHML_PSEUDO_UNIT_ITSELF) {
+    UpdateValue(flags, mLeadingSpace, mBoundingMetrics, lspace);
   }
 
   // update voffset
-  if (mVerticalOffsetPseudoUnit != NS_MATHML_PSEUDO_UNIT_ITSELF) {
-    pseudoUnit = mVerticalOffsetPseudoUnit;
-    UpdateValue(mVerticalOffsetSign, pseudoUnit, mVerticalOffset,
-                mBoundingMetrics, voffset);
+  flags = mVerticalOffsetFlags;
+  if (nsMathMLElement::MpaddedPseudoUnitRead(flags) !=
+      nsMathMLElement::NS_MATHML_PSEUDO_UNIT_ITSELF) {
+    UpdateValue(flags, mVerticalOffset, mBoundingMetrics, voffset);
   }
   // do the padding now that we have everything
   // The idea here is to maintain the invariant that <mpadded>...</mpadded> (i.e.,
   // with no attributes) looks the same as <mrow>...</mrow>. But when there are
   // attributes, tweak our metrics and move children to achieve the desired visual
   // effects.
 
-  if ((NS_MATHML_IS_RTL(mPresentationData.flags) ?
-       mWidthSign : mLeadingSpaceSign) != NS_MATHML_SIGN_INVALID) {
+  sign =
+    nsMathMLElement::MpaddedSignRead(NS_MATHML_IS_RTL(mPresentationData.flags) ?
+                                     mWidthFlags : mLeadingSpaceFlags);
+
+  if (sign != nsMathMLElement::NS_MATHML_SIGN_INVALID) {
     // there was padding on the left. dismiss the left italic correction now
     // (so that our parent won't correct us)
     mBoundingMetrics.leftBearing = 0;
   }
 
-  if ((NS_MATHML_IS_RTL(mPresentationData.flags) ?
-       mLeadingSpaceSign : mWidthSign) != NS_MATHML_SIGN_INVALID) {
+  sign =
+    nsMathMLElement::MpaddedSignRead(NS_MATHML_IS_RTL(mPresentationData.flags) ?
+                                     mLeadingSpaceFlags : mWidthFlags);
+  if (sign != nsMathMLElement::NS_MATHML_SIGN_INVALID) {
     // there was padding on the right. dismiss the right italic correction now
     // (so that our parent won't correct us)
     mBoundingMetrics.width = width;
     mBoundingMetrics.rightBearing = mBoundingMetrics.width;
   }
 
   nscoord dy = height - mBoundingMetrics.ascent;
   nscoord dx = NS_MATHML_IS_RTL(mPresentationData.flags) ?
diff --git a/layout/mathml/nsMathMLmpaddedFrame.h b/layout/mathml/nsMathMLmpaddedFrame.h
--- a/layout/mathml/nsMathMLmpaddedFrame.h
+++ b/layout/mathml/nsMathMLmpaddedFrame.h
@@ -81,39 +81,26 @@ protected:
 
 private:
   nsCSSValue mWidth;
   nsCSSValue mHeight;
   nsCSSValue mDepth;
   nsCSSValue mLeadingSpace;
   nsCSSValue mVerticalOffset;
 
-  PRInt32    mWidthSign;
-  PRInt32    mHeightSign;
-  PRInt32    mDepthSign;
-  PRInt32    mLeadingSpaceSign;
-  PRInt32    mVerticalOffsetSign;
-
-  PRInt32    mWidthPseudoUnit;
-  PRInt32    mHeightPseudoUnit;
-  PRInt32    mDepthPseudoUnit;
-  PRInt32    mLeadingSpacePseudoUnit;
-  PRInt32    mVerticalOffsetPseudoUnit;
+  PRUint32    mWidthFlags;
+  PRUint32    mHeightFlags;
+  PRUint32    mDepthFlags;
+  PRUint32    mLeadingSpaceFlags;
+  PRUint32    mVerticalOffsetFlags;
 
   // helpers to process the attributes
   void
   ProcessAttributes();
 
-  static bool
-  ParseAttribute(nsString&   aString,
-                 PRInt32&    aSign,
-                 nsCSSValue& aCSSValue,
-                 PRInt32&    aPseudoUnit);
-
   void
-  UpdateValue(PRInt32                  aSign,
-              PRInt32                  aPseudoUnit,
+  UpdateValue(PRInt32                  aFlags,
               const nsCSSValue&        aCSSValue,
               const nsBoundingMetrics& aBoundingMetrics,
               nscoord&                 aValueToUpdate) const;
 };
 
 #endif /* nsMathMLmpaddedFrame_h___ */
