# HG changeset patch
# Parent 6fa163ff81a310fa4f30d11aa7a5ec8e4ff3e1bf
# User Frédéric Wang <fred.wang@free.fr>
MathML warning

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -23,25 +23,122 @@
 #include "nsCSSRendering.h"
 #include "prprf.h"         // For PR_snprintf()
 
 #include "nsDisplayList.h"
 
 #include "nsMathMLOperators.h"
 #include <algorithm>
 
+#if defined MOZ_ENABLE_GIO && defined MOZ_ENABLE_DBUS
+#define MOZ_USE_PACKAGE_KIT
+#endif
+
+#ifdef MOZ_USE_PACKAGE_KIT
+#include "nsIGIOService.h"
+#include "nsIArray.h"
+#include "nsIMutableArray.h"
+#endif
+
+#include "mozilla/EventDispatcher.h"
+#include "nsIDOMKeyEvent.h"
+#include "nsThreadUtils.h"
+
 using namespace mozilla;
 
 //#define NOISY_SEARCH 1
 
 // -----------------------------------------------------------------------------
 static const nsGlyphCode kNullGlyph = {{{0, 0}}, 0};
 typedef enum {eExtension_base, eExtension_variants, eExtension_parts}
   nsMathfontPrefExtension;
 
+static bool gMathFontWarning = false;
+
+static void
+MathFontWarningPrefChanged(const char *aPref, void *aClosure)
+{
+  gMathFontWarning =
+    Preferences::GetBool("font.mathfont-warning", gMathFontWarning);
+}
+
+#ifdef MOZ_USE_PACKAGE_KIT
+static nsresult
+GetMathFontPackageList(nsIArray** aResult)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsIMutableArray> array = do_CreateInstance(NS_ARRAY_CONTRACTID);
+  if (!array)
+    return NS_ERROR_FAILURE;
+
+  uint32_t packageCount = 2;
+  const nsLiteralString packages[] = {
+    NS_LITERAL_STRING("latinmodernmath"),
+    NS_LITERAL_STRING("stixmath")
+  };
+
+  for (uint32_t i = 0; i < packageCount; i++) {
+    nsCOMPtr<nsISupportsString> package =
+      do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = package->SetData(packages[i]);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = array->AppendElement(package, false);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  *aResult = static_cast<nsCOMPtr<nsIArray> >(array);
+  NS_ADDREF(*aResult);
+  return NS_OK;
+}
+#endif
+
+class nsFontNotificationEvent : public nsRunnable
+{
+public:
+  nsFontNotificationEvent(nsPresContext* aPresContext)
+    : mPresContext(aPresContext)
+  {
+  }
+
+  NS_IMETHOD Run()
+  {
+#ifdef MOZ_USE_PACKAGE_KIT
+    nsCOMPtr<nsIArray> array;
+    if (NS_SUCCEEDED(GetMathFontPackageList(getter_AddRefs(array)))) {
+      nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
+      if (giovfs) {
+        giovfs->InstallPackages(array,
+                                nsIGIOService::PK_INSTALL_PACKAGE_NAMES);
+      }
+    }
+#else
+    nsCOMPtr<nsIDOMEvent> event;
+    if (NS_SUCCEEDED(EventDispatcher::CreateEvent(mPresContext->Document(),
+                                                  mPresContext, nullptr,
+                                                  NS_LITERAL_STRING("Event"),
+                                                  getter_AddRefs(event)))){
+      event->InitEvent(NS_LITERAL_STRING("DOMMissingMathMLFonts"), true, true);
+      event->SetTrusted(true);
+
+      EventDispatcher::DispatchDOMEvent(mPresContext->Document(),
+                                        nullptr, event,
+                                        mPresContext, nullptr);
+    }
+#endif
+    return NS_OK;
+  }
+  
+private:
+  nsPresContext* mPresContext;
+};
+
 // -----------------------------------------------------------------------------
 // nsGlyphTable is a class that provides an interface for accessing glyphs
 // of stretchy chars. It acts like a table that stores the variants of bigger
 // sizes (if any) and the partial glyphs needed to build extensible symbols.
 // An instance of nsGlyphTable is associated to one primary font. Extra glyphs
 // can be taken in other additional fonts when stretching certain characters.
 // These supplementary fonts are referred to as "external" fonts to the table.
 //
@@ -498,16 +595,21 @@ MathFontEnumCallback(const nsString& aFa
 }
 
 static nsresult
 InitGlobals(nsPresContext* aPresContext)
 {
   NS_ASSERTION(!gGlyphTableInitialized, "Error -- already initialized");
   gGlyphTableInitialized = true;
 
+  // Set up a listener for mathfont-warning and check the initial value
+  Preferences::RegisterCallback(MathFontWarningPrefChanged,
+                                "font.mathfont-warning");
+  MathFontWarningPrefChanged(nullptr, nullptr);
+
   // Allocate the placeholders for the preferred parts and variants
   nsresult rv = NS_ERROR_OUT_OF_MEMORY;
   gGlyphTableList = new nsGlyphTableList();
   if (gGlyphTableList) {
     rv = gGlyphTableList->Initialize();
   }
   if (NS_FAILED(rv)) {
     delete gGlyphTableList;
@@ -1505,16 +1607,31 @@ nsMathMLChar::StretchInternal(nsPresCont
       if (!maxWidth) {
         mScaleY *= scale;
       }
       aDesiredStretchSize.ascent *= scale;
       aDesiredStretchSize.descent *= scale;
     }
   }
 
+  // XXXfredw: improve the heuristics to determine missing fonts:
+  // - only for known stretchable characters?
+  // - only for non-MATH font?
+  // - only when Web fonts are not loading?
+  if (!maxWidth && gMathFontWarning) {
+    // Send a warning if it seems that the mathematical fonts available are not
+    // enough to stretch the operators.
+    if ((!glyphFound && largeop) || (mScaleX > 2.0 || mScaleY > 2.0)) {
+      // Dispatch the notification
+      nsCOMPtr<nsIRunnable> event = new nsFontNotificationEvent(aPresContext);
+      NS_DispatchToCurrentThread(event);
+      gMathFontWarning = false; // we do that only once per session.
+    }
+  }
+
   return NS_OK;
 }
 
 nsresult
 nsMathMLChar::Stretch(nsPresContext*           aPresContext,
                       nsRenderingContext&     aRenderingContext,
                       nsStretchDirection       aStretchDirection,
                       const nsBoundingMetrics& aContainerSize,
diff --git a/modules/libpref/src/init/all.js b/modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js
+++ b/modules/libpref/src/init/all.js
@@ -4402,8 +4402,11 @@ pref("snav.enabled", false);
 // Wakelock is disabled by default.
 pref("dom.wakelock.enabled", false);
 
 // The URL of the Firefox Accounts auth server backend
 pref("identity.fxaccounts.auth.uri", "https://api.accounts.firefox.com/v1");
 
 // disable mozsample size for now
 pref("image.mozsamplesize.enabled", false);
+
+// warning for missing MathML fonts
+pref("font.mathfont-warning", true);
diff --git a/toolkit/system/gnome/nsGIOService.cpp b/toolkit/system/gnome/nsGIOService.cpp
--- a/toolkit/system/gnome/nsGIOService.cpp
+++ b/toolkit/system/gnome/nsGIOService.cpp
@@ -12,16 +12,27 @@
 
 #include <gio/gio.h>
 #include <gtk/gtk.h>
 #ifdef MOZ_ENABLE_DBUS
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #endif
 
+#if defined MOZ_ENABLE_GIO && defined MOZ_ENABLE_DBUS
+#define MOZ_USE_PACKAGE_KIT
+#endif
+
+#ifdef MOZ_USE_PACKAGE_KIT
+#include "mozilla/Services.h"
+#include "nsArrayUtils.h"
+#include "nsIArray.h"
+#include "nsIObserverService.h"
+#include "nsISupportsPrimitives.h"
+#endif
 
 char *
 get_content_type_from_mime_type(const char *mimeType)
 {
   GList* contentTypes = g_content_types_get_registered();
   GList* ct_ptr = contentTypes;
   char* foundContentType = nullptr;
 
@@ -487,8 +498,155 @@ nsGIOService::CreateAppFromCommand(nsACS
     g_error_free(error);
     return NS_ERROR_FAILURE;
   }
   nsGIOMimeApp *mozApp = new nsGIOMimeApp(app_info);
   NS_ENSURE_TRUE(mozApp, NS_ERROR_OUT_OF_MEMORY);
   NS_ADDREF(*appInfo = mozApp);
   return NS_OK;
 }
+
+#ifdef MOZ_USE_PACKAGE_KIT
+struct InstallPackagesUserData {
+  GVariant* parameters;
+  uint32_t method;
+};
+
+static void InstallPackagesNotifyObservers(bool aError)
+{
+  nsCOMPtr<nsIObserverService> observerService = mozilla::services::GetObserverService();
+  if (observerService) {
+    observerService->NotifyObservers(nullptr,
+                                     "gio-install-packages",
+                                     aError ?
+                                     NS_LITERAL_STRING("error").get() :
+                                     NS_LITERAL_STRING("installed").get());
+  }
+}
+
+static void
+InstallPackagesCommandExecutedCallback(GObject *aSourceObject,
+                                       GAsyncResult *aResult,
+                                       gpointer aUserData)
+{
+  GDBusProxy* proxy = static_cast<GDBusProxy*>(aUserData);
+  GError* error = nullptr;
+  GVariant* result = g_dbus_proxy_call_finish(proxy, aResult, &error);
+  if (result != nullptr) {
+    InstallPackagesNotifyObservers(false);
+    g_variant_unref(result);
+  } else {
+    InstallPackagesNotifyObservers(true);
+    g_error_free(error);
+  }
+
+  g_object_unref(proxy);
+}
+
+static void
+InstallPackagesProxyReadyCallback(GObject *aSourceObject, GAsyncResult *aResult,
+                                  gpointer aUserData)
+{
+  InstallPackagesUserData* userData =
+    static_cast<InstallPackagesUserData*>(aUserData);
+
+  GError* error = nullptr;
+  GDBusProxy* proxy = g_dbus_proxy_new_finish(aResult, &error);
+
+  if (proxy != nullptr) {
+    // Send the asynchronous request to install the packages
+    // The call will release the "floating" reference userData->parameters
+    const char* methodNames[] = {
+      "InstallPackageNames",
+      "InstallMimeTypes",
+      "InstallFontconfigResources",
+      "InstallGStreamerResources"
+    };
+    g_dbus_proxy_call(proxy,
+                      methodNames[userData->method],
+                      userData->parameters,
+                      G_DBUS_CALL_FLAGS_NONE,
+                      -1,
+                      nullptr,
+                      static_cast<GAsyncReadyCallback>
+                      (&InstallPackagesCommandExecutedCallback),
+                      static_cast<gpointer>(proxy));
+  } else {
+    InstallPackagesNotifyObservers(true);
+    g_error_free(error);
+    g_variant_unref(userData->parameters);
+  }
+  delete userData;
+}
+#endif
+
+NS_IMETHODIMP
+nsGIOService::InstallPackages(nsIArray* aPackageList,
+                              uint32_t aInstallMethod)
+{
+#ifndef MOZ_USE_PACKAGE_KIT
+  return NS_ERROR_FAILURE;
+#else
+  uint32_t arrayLength;
+  aPackageList->GetLength(&arrayLength);
+  if (arrayLength == 0 ||
+      arrayLength == std::numeric_limits<uint32_t>::max() ||
+      aInstallMethod >= PK_INSTALL_COUNT)
+    return NS_OK;
+
+  // Create the GVariant* parameter from the list of packages.
+  GVariant* parameters = nullptr;
+  gchar** packages = new gchar*[arrayLength + 1];
+  NS_ENSURE_TRUE(packages, NS_ERROR_OUT_OF_MEMORY);
+
+  nsresult rv = NS_OK;
+  for (uint32_t i = 0; i < arrayLength; i++) {
+    nsCOMPtr<nsISupportsString> package =
+      do_QueryElementAt(aPackageList, i);
+    if (!package) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+    nsString data;
+    package->GetData(data);
+    nsAutoCString utf8data = NS_ConvertUTF16toUTF8(data);
+    packages[i] = g_strdup(const_cast<gchar*>(utf8data.get()));
+    if (!packages[i]) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+  }
+  packages[arrayLength] = nullptr;
+
+  if (NS_SUCCEEDED(rv)) {
+    // We create a new GVariant object to send parameters to PackageKit.
+    parameters = g_variant_new("(u^a&ss)", 0, packages, "hide-finished");
+    if (!parameters) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+  for (uint32_t i = 0; i < arrayLength; i++) {
+    g_free(packages[i]);
+  }
+  delete packages;
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Send the asynchronous request to load the bus proxy
+  InstallPackagesUserData* userData = new InstallPackagesUserData;
+  if (!userData) {
+    g_variant_unref(parameters);
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  userData->parameters = parameters;
+  userData->method = aInstallMethod;
+  g_dbus_proxy_new_for_bus(G_BUS_TYPE_SESSION,
+                           G_DBUS_PROXY_FLAGS_NONE,
+                           nullptr,
+                           "org.freedesktop.PackageKit",
+                           "/org/freedesktop/PackageKit",
+                           "org.freedesktop.PackageKit.Modify",
+                           nullptr,
+                           static_cast<GAsyncReadyCallback>
+                           (&InstallPackagesProxyReadyCallback),
+                           static_cast<gpointer>(userData));
+  return NS_OK;
+#endif
+}
diff --git a/xpcom/system/nsIGIOService.idl b/xpcom/system/nsIGIOService.idl
--- a/xpcom/system/nsIGIOService.idl
+++ b/xpcom/system/nsIGIOService.idl
@@ -1,15 +1,16 @@
 /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 
+interface nsIArray;
 interface nsIUTF8StringEnumerator;
 interface nsIURI;
 
 /* nsIGIOMimeApp holds information about an application that is looked up
    with nsIGIOService::GetAppForMimeType. */
 // 66009894-9877-405b-9321-bf30420e34e6 prev uuid
 
 [scriptable, uuid(ca6bad0c-8a48-48ac-82c7-27bb8f510fbe)] 
@@ -70,13 +71,29 @@ interface nsIGIOService : nsISupports
   /*** Misc. methods ***/
 
   /* Open the given URI in the default application */
   void               showURI(in nsIURI uri);
   [noscript] void    showURIForInput(in ACString uri);
 
   /* Open path in file manager using org.freedesktop.FileManager1 interface */
   [noscript] void    orgFreedesktopFileManager1ShowItems(in ACString path);
+
+  /* PackageKit installation methods */
+  const unsigned long PK_INSTALL_PACKAGE_NAMES = 0;
+  const unsigned long PK_INSTALL_MIME_TYPES = 1;
+  const unsigned long PK_INSTALL_FONTCONFIG_RESOURCES = 2;
+  const unsigned long PK_INSTALL_GSTREAMER_RESOURCES = 3;
+  const unsigned long PK_INSTALL_COUNT = 4;
+
+  /* Ask to install a list of packages via PackageKit
+   * @param   packageList
+   *          A list of strings describing the packages to install.
+   * @param   packageKitMethod
+   *          The PackageKit installation method.
+   */
+  void installPackages(in nsIArray packageList,
+                       in unsigned long packageKitMethod);
 };
 
 %{C++
 #define NS_GIOSERVICE_CONTRACTID "@mozilla.org/gio-service;1"
 %}
