# HG changeset patch
# Parent 0b0185ce7762047b3655e392d65e59d4c0048f10
# User Frédéric Wang <fred.wang@free.fr>
Part 4 - Use MATH constants for scripts. r=karl, b=961365

diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
@@ -130,36 +130,30 @@ nsMathMLmmultiscriptsFrame::Place(nsRend
   //
   if (tag != nsGkAtoms::msub_) {
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::superscriptshift_, value);
     if (!value.IsEmpty()) {
       ParseNumericValue(value, &supScriptShift, 0, PresContext(),
                         mStyleContext);
     }
   }
-  // scriptspace from TeX for extra spacing after sup/subscript 
-  // (0.5pt in plain TeX)
-  nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
-
   return PlaceMultiScript(PresContext(), aRenderingContext, aPlaceOrigin,
-                          aDesiredSize, this, subScriptShift, supScriptShift,
-                          scriptSpace);
+                          aDesiredSize, this, subScriptShift, supScriptShift);
 }
 
 // exported routine that both munderover and mmultiscripts share.
 // munderover uses this when movablelimits is set.
 nsresult
 nsMathMLmmultiscriptsFrame::PlaceMultiScript(nsPresContext*      aPresContext,
                                         nsRenderingContext& aRenderingContext,
                                         bool                 aPlaceOrigin,
                                         nsHTMLReflowMetrics& aDesiredSize,
                                         nsMathMLContainerFrame* aFrame,
                                         nscoord              aUserSubScriptShift,
-                                        nscoord              aUserSupScriptShift,
-                                        nscoord              aScriptSpace)
+                                        nscoord              aUserSupScriptShift)
 {
   nsIAtom* tag = aFrame->GetContent()->Tag();
 
   // This function deals with both munderover etc. as well as msubsup etc.
   // As the former behaves identically to the later, we treat it as such
   // to avoid additional checks later.
   if (tag == nsGkAtoms::mover_)
     tag = nsGkAtoms::msup_;
@@ -182,31 +176,32 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
   if (!baseFrame) {
     if (tag == nsGkAtoms::mmultiscripts_)
       aFrame->ReportErrorToConsole("NoBase");
     else
       aFrame->ReportChildCountError();
     return aFrame->ReflowError(aRenderingContext, aDesiredSize);
   }
 
-
   // get x-height (an ex)
   const nsStyleFont* font = aFrame->StyleFont();
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(baseFrame, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord xHeight = fm->XHeight();
 
-  nscoord ruleSize;
-  GetRuleThickness (aRenderingContext, fm, ruleSize);
+  // scriptspace from TeX for extra spacing after sup/subscript 
+  // (0.5pt in plain TeX)
+  nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
+  GetMathConstantEm(fm, gfxFontEntry::SpaceAfterScript, scriptSpace);
 
   // force the scriptSpace to be at least 1 pixel
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
-  aScriptSpace = std::max(onePixel, aScriptSpace);
+  scriptSpace = std::max(onePixel, scriptSpace);
 
   /////////////////////////////////////
   // first the shift for the subscript
 
   // subScriptShift{1,2}
   // = minimum amount to shift the subscript down
   // = sub{1,2} in TeXbook
   // subScriptShift1 = subscriptshift attribute * x-height
@@ -215,16 +210,21 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
   // Get subScriptShift{1,2} default from font
   GetSubScriptShifts (fm, subScriptShift1, subScriptShift2);
   nscoord subScriptShift;
   if (tag == nsGkAtoms::msub_) {
     subScriptShift = subScriptShift1;
   } else {
     subScriptShift = std::max(subScriptShift1, subScriptShift2);
   }
+
+  // Get the sub script shift from the MATH table. Note that contrary to TeX we
+  // only have one parameter.
+  GetMathConstantEm(fm, gfxFontEntry::SubscriptShiftDown, subScriptShift);
+
   if (0 < aUserSubScriptShift) {
     // the user has set the subscriptshift attribute
     subScriptShift = std::max(subScriptShift, aUserSubScriptShift);
   }
 
   /////////////////////////////////////
   // next the shift for the superscript
 
@@ -251,16 +251,22 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
   } else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style C' in TeXbook = D',T',S',SS'
     supScriptShift = supScriptShift3;
   } else {
     // everything else = T,S,SS
     supScriptShift = supScriptShift2;
   }
 
+  // Get the super script shift from the MATH table. Note that contrary to TeX
+  // we only have two parameters.
+  GetMathConstantEm(fm, NS_MATHML_IS_COMPRESSED(presentationData.flags) ?
+                    gfxFontEntry::SuperscriptShiftUpCramped :
+                    gfxFontEntry::SuperscriptShiftUp, supScriptShift);
+
   if (0 < aUserSupScriptShift) {
     // the user has set the supscriptshift attribute
     supScriptShift = std::max(supScriptShift, aUserSupScriptShift);
   }
 
   ////////////////////////////////////
   // Get the children's sizes
   ////////////////////////////////////
@@ -379,58 +385,61 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
            std::max(multiSubSize.BlockStartAscent(),
                     subScriptSize.BlockStartAscent()));
         bmMultiSub.ascent = std::max(bmMultiSub.ascent, bmSubScript.ascent);
         bmMultiSub.descent = std::max(bmMultiSub.descent, bmSubScript.descent);
         multiSubSize.Height() = 
           std::max(multiSubSize.Height(),
                    subScriptSize.Height() - subScriptSize.BlockStartAscent());
         if (bmSubScript.width)
-          width = bmSubScript.width + aScriptSpace;
+          width = bmSubScript.width + scriptSpace;
         rightBearing = bmSubScript.rightBearing;
 
         if (tag == nsGkAtoms::msub_) {
           boundingMetrics.rightBearing = boundingMetrics.width + rightBearing;
           boundingMetrics.width += width;
 
           // get min subscript shift limit from x-height
           // = h(x) - 4/5 * sigma_5, Rule 18b, App. G, TeXbook
-          nscoord minShiftFromXHeight = (nscoord) 
-            (bmSubScript.ascent - (4.0f/5.0f) * xHeight);
+          nscoord subscriptTopMax = NSToCoordRound((4.0f/5.0f) * xHeight);
+          GetMathConstantEm(fm, gfxFontEntry::SubscriptTopMax, subscriptTopMax);
+          nscoord minShiftFromXHeight = bmSubScript.ascent - subscriptTopMax;
           maxSubScriptShift = std::max(trySubScriptShift,minShiftFromXHeight);
 
           maxSubScriptShift = std::max(maxSubScriptShift, trySubScriptShift);
           trySubScriptShift = subScriptShift;
         }
       } else {
         // supscript
         supScriptFrame = childFrame;
         GetReflowAndBoundingMetricsFor(supScriptFrame, supScriptSize, bmSupScript);
         // get the supdrop from the supscript font
         GetSupDropFromChild (supScriptFrame, supDrop);
         // parameter u, Rule 18a, App. G, TeXbook
         minSupScriptShift = bmBase.ascent - supDrop;
         // get min supscript shift limit from x-height
         // = d(x) + 1/4 * sigma_5, Rule 18c, App. G, TeXbook
-        minShiftFromXHeight = NSToCoordRound
-          ((bmSupScript.descent + (1.0f/4.0f) * xHeight));
+        nscoord superscriptBottomMin = NSToCoordRound((1.0f/4.0f) * xHeight);
+        GetMathConstantEm(fm, gfxFontEntry::SuperscriptBottomMin,
+                          superscriptBottomMin);
+        minShiftFromXHeight = bmSupScript.descent + superscriptBottomMin;
         trySupScriptShift = std::max(minSupScriptShift,
                                      std::max(minShiftFromXHeight,
                                               supScriptShift));
         multiSupSize.SetBlockStartAscent(
           std::max(multiSupSize.BlockStartAscent(),
                    supScriptSize.BlockStartAscent()));
         bmMultiSup.ascent = std::max(bmMultiSup.ascent, bmSupScript.ascent);
         bmMultiSup.descent = std::max(bmMultiSup.descent, bmSupScript.descent);
         multiSupSize.Height() =
           std::max(multiSupSize.Height(),
                    supScriptSize.Height() - supScriptSize.BlockStartAscent());
 
         if (bmSupScript.width)
-          width = std::max(width, bmSupScript.width + aScriptSpace);
+          width = std::max(width, bmSupScript.width + scriptSpace);
 
         if (!prescriptsFrame) { // we are still looping over base & postscripts
           rightBearing = std::max(rightBearing,
                                   italicCorrection + bmSupScript.rightBearing);
           boundingMetrics.rightBearing = boundingMetrics.width + rightBearing;
           boundingMetrics.width += width;
         } else {
           prescriptsWidth += width;
@@ -442,28 +451,37 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
         }
         width = rightBearing = 0;
 
         // negotiate between the various shifts so that
         // there is enough gap between the sup and subscripts
         // Rule 18e, App. G, TeXbook
         if (tag == nsGkAtoms::mmultiscripts_ || 
             tag == nsGkAtoms::msubsup_) {
+          nscoord ruleSize;
+          GetRuleThickness(aRenderingContext, fm, ruleSize);
+          nscoord subSuperscriptGapMin = 4 * ruleSize;
+          GetMathConstantEm(fm, gfxFontEntry::SubSuperscriptGapMin,
+                            subSuperscriptGapMin);
           nscoord gap =
             (trySupScriptShift - bmSupScript.descent) -
             (bmSubScript.ascent - trySubScriptShift);
-          if (gap < 4.0f * ruleSize) {
-            // adjust trySubScriptShift to get a gap of (4.0 * ruleSize)
-            trySubScriptShift += NSToCoordRound ((4.0f * ruleSize) - gap);
+          if (gap < subSuperscriptGapMin) {
+            // adjust trySubScriptShift to get a gap of subSuperscriptGapMin
+            trySubScriptShift += subSuperscriptGapMin - gap;
           }
 
           // next we want to ensure that the bottom of the superscript
           // will be > (4/5) * x-height above baseline
-          gap = NSToCoordRound ((4.0f/5.0f) * xHeight -
-                  (trySupScriptShift - bmSupScript.descent));
+          nscoord superscriptBottomMaxWithSubscript =
+            NSToCoordRound((4.0f/5.0f) * xHeight);
+          GetMathConstantEm(fm, gfxFontEntry::SuperscriptBottomMaxWithSubscript,
+                            superscriptBottomMaxWithSubscript);
+          gap = superscriptBottomMaxWithSubscript -
+            (trySupScriptShift - bmSupScript.descent);
           if (gap > 0) {
             trySupScriptShift += gap;
             trySubScriptShift -= gap;
           }
         }
 
         maxSubScriptShift = std::max(maxSubScriptShift, trySubScriptShift);
         maxSupScriptShift = std::max(maxSupScriptShift, trySupScriptShift);
@@ -623,17 +641,17 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
               maxSupScriptShift;
             FinishReflowChild (supScriptFrame, aPresContext, supScriptSize,
                                nullptr,
                                aFrame->MirrorIfRTL(aDesiredSize.Width(),
                                                    supScriptSize.Width(),
                                                    x),
                                dy, 0);
           }
-          dx += width + aScriptSpace;
+          dx += width + scriptSpace;
         }
       }
       childFrame = childFrame->GetNextSibling();
     } while (prescriptsFrame != childFrame);
   }
 
   return NS_OK;
 }
diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.h b/layout/mathml/nsMathMLmmultiscriptsFrame.h
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.h
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.h
@@ -32,18 +32,17 @@ public:
 
   static nsresult
   PlaceMultiScript(nsPresContext*      aPresContext,
                     nsRenderingContext& aRenderingContext,
                     bool                 aPlaceOrigin,
                     nsHTMLReflowMetrics& aDesiredSize,
                     nsMathMLContainerFrame* aForFrame,
                     nscoord              aUserSubScriptShift,
-                    nscoord              aUserSupScriptShift,
-                    nscoord              aScriptSpace);
+                    nscoord              aUserSupScriptShift);
 
   uint8_t
   ScriptIncrement(nsIFrame* aFrame) MOZ_OVERRIDE;
 
 protected:
   nsMathMLmmultiscriptsFrame(nsStyleContext* aContext) : nsMathMLContainerFrame(aContext) {}
   virtual ~nsMathMLmmultiscriptsFrame();
   
diff --git a/layout/mathml/nsMathMLmunderoverFrame.cpp b/layout/mathml/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/nsMathMLmunderoverFrame.cpp
@@ -282,39 +282,35 @@ i.e.,:
 nsMathMLmunderoverFrame::Place(nsRenderingContext& aRenderingContext,
                                bool                 aPlaceOrigin,
                                nsHTMLReflowMetrics& aDesiredSize)
 {
   nsIAtom* tag = mContent->Tag();
   if (NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
       StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_INLINE) {
     //place like sub sup or subsup
-    nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
     if (tag == nsGkAtoms::munderover_) {
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     } else if (tag == nsGkAtoms::munder_) {
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     } else {
       NS_ASSERTION(tag == nsGkAtoms::mover_, "mContent->Tag() not recognized");
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     }
     
   }
 
   ////////////////////////////////////
   // Get the children's desired sizes
 
   nsBoundingMetrics bmBase, bmUnder, bmOver;
