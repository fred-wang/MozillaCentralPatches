# HG changeset patch
# Parent fff49fa2d7d4b36ecb4a09952aa9ba7930f6da8b
# User Frédéric Wang <fred.wang@free.fr>
Part 4 - Use MATH constants for scripts. r=jfkthame, b=961365

diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
@@ -130,36 +130,30 @@ nsMathMLmmultiscriptsFrame::Place(nsRend
   //
   if (tag != nsGkAtoms::msub_) {
     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::superscriptshift_, value);
     if (!value.IsEmpty()) {
       ParseNumericValue(value, &supScriptShift, 0, PresContext(),
                         mStyleContext);
     }
   }
-  // scriptspace from TeX for extra spacing after sup/subscript 
-  // (0.5pt in plain TeX)
-  nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
-
   return PlaceMultiScript(PresContext(), aRenderingContext, aPlaceOrigin,
-                          aDesiredSize, this, subScriptShift, supScriptShift,
-                          scriptSpace);
+                          aDesiredSize, this, subScriptShift, supScriptShift);
 }
 
 // exported routine that both munderover and mmultiscripts share.
 // munderover uses this when movablelimits is set.
 nsresult
 nsMathMLmmultiscriptsFrame::PlaceMultiScript(nsPresContext*      aPresContext,
                                         nsRenderingContext& aRenderingContext,
                                         bool                 aPlaceOrigin,
                                         nsHTMLReflowMetrics& aDesiredSize,
                                         nsMathMLContainerFrame* aFrame,
                                         nscoord              aUserSubScriptShift,
-                                        nscoord              aUserSupScriptShift,
-                                        nscoord              aScriptSpace)
+                                        nscoord              aUserSupScriptShift)
 {
   nsIAtom* tag = aFrame->GetContent()->Tag();
 
   // This function deals with both munderover etc. as well as msubsup etc.
   // As the former behaves identically to the later, we treat it as such
   // to avoid additional checks later.
   if (tag == nsGkAtoms::mover_)
     tag = nsGkAtoms::msup_;
@@ -182,83 +176,107 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
   if (!baseFrame) {
     if (tag == nsGkAtoms::mmultiscripts_)
       aFrame->ReportErrorToConsole("NoBase");
     else
       aFrame->ReportChildCountError();
     return aFrame->ReflowError(aRenderingContext, aDesiredSize);
   }
 
-
   // get x-height (an ex)
   const nsStyleFont* font = aFrame->StyleFont();
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(baseFrame, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord xHeight = fm->XHeight();
 
-  nscoord ruleSize;
-  GetRuleThickness (aRenderingContext, fm, ruleSize);
+  nscoord oneDevPixel = fm->AppUnitsPerDevPixel();
+  gfxFont* mathFont = fm->GetThebesFontGroup()->GetFirstMathFont();
+  // scriptspace from TeX for extra spacing after sup/subscript 
+  nscoord scriptSpace;
+  if (mathFont) {
+      mathFont->GetMathConstant(gfxFontEntry::SpaceAfterScript,
+                                oneDevPixel, scriptSpace);
+  } else {
+    // (0.5pt in plain TeX)
+    scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
+  }
 
   // force the scriptSpace to be at least 1 pixel
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
-  aScriptSpace = std::max(onePixel, aScriptSpace);
+  scriptSpace = std::max(onePixel, scriptSpace);
 
   /////////////////////////////////////
   // first the shift for the subscript
 
-  // subScriptShift{1,2}
-  // = minimum amount to shift the subscript down
-  // = sub{1,2} in TeXbook
-  // subScriptShift1 = subscriptshift attribute * x-height
-  nscoord subScriptShift1, subScriptShift2;
+  nscoord subScriptShift;
+  if (mathFont) {
+    // Try and get the sub script shift from the MATH table. Note that contrary
+    // to TeX we only have one parameter.
+    mathFont->GetMathConstant(gfxFontEntry::SubscriptShiftDown,
+                              oneDevPixel, subScriptShift);
+  } else {
+    // subScriptShift{1,2}
+    // = minimum amount to shift the subscript down
+    // = sub{1,2} in TeXbook
+    // subScriptShift1 = subscriptshift attribute * x-height
+    nscoord subScriptShift1, subScriptShift2;
+    // Get subScriptShift{1,2} default from font
+    GetSubScriptShifts (fm, subScriptShift1, subScriptShift2);
+    if (tag == nsGkAtoms::msub_) {
+      subScriptShift = subScriptShift1;
+    } else {
+      subScriptShift = std::max(subScriptShift1, subScriptShift2);
+    }
+  }
 
-  // Get subScriptShift{1,2} default from font
-  GetSubScriptShifts (fm, subScriptShift1, subScriptShift2);
-  nscoord subScriptShift;
-  if (tag == nsGkAtoms::msub_) {
-    subScriptShift = subScriptShift1;
-  } else {
-    subScriptShift = std::max(subScriptShift1, subScriptShift2);
-  }
   if (0 < aUserSubScriptShift) {
     // the user has set the subscriptshift attribute
     subScriptShift = std::max(subScriptShift, aUserSubScriptShift);
   }
 
   /////////////////////////////////////
   // next the shift for the superscript
 
-  // supScriptShift{1,2,3}
-  // = minimum amount to shift the supscript up
-  // = sup{1,2,3} in TeX
-  // supScriptShift1 = superscriptshift attribute * x-height
-  // Note that there are THREE values for supscript shifts depending
-  // on the current style
-  nscoord supScriptShift1, supScriptShift2, supScriptShift3;
-  // Set supScriptShift{1,2,3} default from font
-  GetSupScriptShifts (fm, supScriptShift1, supScriptShift2, supScriptShift3);
-
-  // get sup script shift depending on current script level and display style
-  // Rule 18c, App. G, TeXbook
+  nscoord supScriptShift;
   nsPresentationData presentationData;
   aFrame->GetPresentationData(presentationData);
-  nscoord supScriptShift;
-  if (font->mScriptLevel == 0 &&
-      font->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK &&
-      !NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
-    // Style D in TeXbook
-    supScriptShift = supScriptShift1;
-  } else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
-    // Style C' in TeXbook = D',T',S',SS'
-    supScriptShift = supScriptShift3;
+  if (mathFont) {
+    // Try and get the super script shift from the MATH table. Note that
+    // contrary to TeX we only have two parameters.
+    mathFont->GetMathConstant(NS_MATHML_IS_COMPRESSED(presentationData.flags) ?
+                              gfxFontEntry::SuperscriptShiftUpCramped :
+                              gfxFontEntry::SuperscriptShiftUp,
+                              oneDevPixel, supScriptShift);
   } else {
-    // everything else = T,S,SS
-    supScriptShift = supScriptShift2;
+    // supScriptShift{1,2,3}
+    // = minimum amount to shift the supscript up
+    // = sup{1,2,3} in TeX
+    // supScriptShift1 = superscriptshift attribute * x-height
+    // Note that there are THREE values for supscript shifts depending
+    // on the current style
+    nscoord supScriptShift1, supScriptShift2, supScriptShift3;
+    // Set supScriptShift{1,2,3} default from font
+    GetSupScriptShifts (fm, supScriptShift1, supScriptShift2, supScriptShift3);
+    
+    // get sup script shift depending on current script level and display style
+    // Rule 18c, App. G, TeXbook
+    if (font->mScriptLevel == 0 &&
+        font->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK &&
+        !NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
+      // Style D in TeXbook
+      supScriptShift = supScriptShift1;
+    } else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
+      // Style C' in TeXbook = D',T',S',SS'
+      supScriptShift = supScriptShift3;
+    } else {
+      // everything else = T,S,SS
+      supScriptShift = supScriptShift2;
+    }
   }
 
   if (0 < aUserSupScriptShift) {
     // the user has set the supscriptshift attribute
     supScriptShift = std::max(supScriptShift, aUserSupScriptShift);
   }
 
   ////////////////////////////////////
@@ -379,58 +397,71 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
            std::max(multiSubSize.BlockStartAscent(),
                     subScriptSize.BlockStartAscent()));
         bmMultiSub.ascent = std::max(bmMultiSub.ascent, bmSubScript.ascent);
         bmMultiSub.descent = std::max(bmMultiSub.descent, bmSubScript.descent);
         multiSubSize.Height() = 
           std::max(multiSubSize.Height(),
                    subScriptSize.Height() - subScriptSize.BlockStartAscent());
         if (bmSubScript.width)
-          width = bmSubScript.width + aScriptSpace;
+          width = bmSubScript.width + scriptSpace;
         rightBearing = bmSubScript.rightBearing;
 
         if (tag == nsGkAtoms::msub_) {
           boundingMetrics.rightBearing = boundingMetrics.width + rightBearing;
           boundingMetrics.width += width;
 
-          // get min subscript shift limit from x-height
-          // = h(x) - 4/5 * sigma_5, Rule 18b, App. G, TeXbook
-          nscoord minShiftFromXHeight = (nscoord) 
-            (bmSubScript.ascent - (4.0f/5.0f) * xHeight);
+          nscoord subscriptTopMax;
+          if (mathFont) {
+              mathFont->GetMathConstant(gfxFontEntry::SubscriptTopMax,
+                                        oneDevPixel, subscriptTopMax);
+          } else {
+            // get min subscript shift limit from x-height
+            // = h(x) - 4/5 * sigma_5, Rule 18b, App. G, TeXbook
+            subscriptTopMax = NSToCoordRound((4.0f/5.0f) * xHeight);
+          }
+          nscoord minShiftFromXHeight = bmSubScript.ascent - subscriptTopMax;
           maxSubScriptShift = std::max(trySubScriptShift,minShiftFromXHeight);
 
           maxSubScriptShift = std::max(maxSubScriptShift, trySubScriptShift);
           trySubScriptShift = subScriptShift;
         }
       } else {
         // supscript
         supScriptFrame = childFrame;
         GetReflowAndBoundingMetricsFor(supScriptFrame, supScriptSize, bmSupScript);
         // get the supdrop from the supscript font
         GetSupDropFromChild (supScriptFrame, supDrop);
         // parameter u, Rule 18a, App. G, TeXbook
         minSupScriptShift = bmBase.ascent - supDrop;
-        // get min supscript shift limit from x-height
-        // = d(x) + 1/4 * sigma_5, Rule 18c, App. G, TeXbook
-        minShiftFromXHeight = NSToCoordRound
-          ((bmSupScript.descent + (1.0f/4.0f) * xHeight));
+        nscoord superscriptBottomMin;
+        if (mathFont) {
+            mathFont->GetMathConstant(gfxFontEntry::SuperscriptBottomMin,
+                                      oneDevPixel,
+                                      superscriptBottomMin);
+        } else {
+          // get min supscript shift limit from x-height
+          // = d(x) + 1/4 * sigma_5, Rule 18c, App. G, TeXbook
+          superscriptBottomMin = NSToCoordRound((1.0f/4.0f) * xHeight);
+        } 
+        minShiftFromXHeight = bmSupScript.descent + superscriptBottomMin;
         trySupScriptShift = std::max(minSupScriptShift,
                                      std::max(minShiftFromXHeight,
                                               supScriptShift));
         multiSupSize.SetBlockStartAscent(
           std::max(multiSupSize.BlockStartAscent(),
                    supScriptSize.BlockStartAscent()));
         bmMultiSup.ascent = std::max(bmMultiSup.ascent, bmSupScript.ascent);
         bmMultiSup.descent = std::max(bmMultiSup.descent, bmSupScript.descent);
         multiSupSize.Height() =
           std::max(multiSupSize.Height(),
                    supScriptSize.Height() - supScriptSize.BlockStartAscent());
 
         if (bmSupScript.width)
-          width = std::max(width, bmSupScript.width + aScriptSpace);
+          width = std::max(width, bmSupScript.width + scriptSpace);
 
         if (!prescriptsFrame) { // we are still looping over base & postscripts
           rightBearing = std::max(rightBearing,
                                   italicCorrection + bmSupScript.rightBearing);
           boundingMetrics.rightBearing = boundingMetrics.width + rightBearing;
           boundingMetrics.width += width;
         } else {
           prescriptsWidth += width;
@@ -442,28 +473,48 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
         }
         width = rightBearing = 0;
 
         // negotiate between the various shifts so that
         // there is enough gap between the sup and subscripts
         // Rule 18e, App. G, TeXbook
         if (tag == nsGkAtoms::mmultiscripts_ || 
             tag == nsGkAtoms::msubsup_) {
+          nscoord subSuperscriptGapMin;
+          if (mathFont) {
+              mathFont->GetMathConstant(gfxFontEntry::SubSuperscriptGapMin,
+                                        oneDevPixel,
+                                        subSuperscriptGapMin);
+          } else {
+            nscoord ruleSize;
+            GetRuleThickness(aRenderingContext, fm, ruleSize);
+            subSuperscriptGapMin = 4 * ruleSize;
+          }
           nscoord gap =
             (trySupScriptShift - bmSupScript.descent) -
             (bmSubScript.ascent - trySubScriptShift);
-          if (gap < 4.0f * ruleSize) {
-            // adjust trySubScriptShift to get a gap of (4.0 * ruleSize)
-            trySubScriptShift += NSToCoordRound ((4.0f * ruleSize) - gap);
+          if (gap < subSuperscriptGapMin) {
+            // adjust trySubScriptShift to get a gap of subSuperscriptGapMin
+            trySubScriptShift += subSuperscriptGapMin - gap;
           }
 
           // next we want to ensure that the bottom of the superscript
-          // will be > (4/5) * x-height above baseline
-          gap = NSToCoordRound ((4.0f/5.0f) * xHeight -
-                  (trySupScriptShift - bmSupScript.descent));
+          // will be > superscriptBottomMaxWithSubscript
+          nscoord superscriptBottomMaxWithSubscript;
+          if (mathFont) {
+              mathFont->GetMathConstant(gfxFontEntry::
+                                        SuperscriptBottomMaxWithSubscript,
+                                        oneDevPixel,
+                                        superscriptBottomMaxWithSubscript);
+          } else {
+            superscriptBottomMaxWithSubscript =
+              NSToCoordRound((4.0f/5.0f) * xHeight);
+          }
+          gap = superscriptBottomMaxWithSubscript -
+            (trySupScriptShift - bmSupScript.descent);
           if (gap > 0) {
             trySupScriptShift += gap;
             trySubScriptShift -= gap;
           }
         }
 
         maxSubScriptShift = std::max(maxSubScriptShift, trySubScriptShift);
         maxSupScriptShift = std::max(maxSupScriptShift, trySupScriptShift);
@@ -623,17 +674,17 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
               maxSupScriptShift;
             FinishReflowChild (supScriptFrame, aPresContext, supScriptSize,
                                nullptr,
                                aFrame->MirrorIfRTL(aDesiredSize.Width(),
                                                    supScriptSize.Width(),
                                                    x),
                                dy, 0);
           }
-          dx += width + aScriptSpace;
+          dx += width + scriptSpace;
         }
       }
       childFrame = childFrame->GetNextSibling();
     } while (prescriptsFrame != childFrame);
   }
 
   return NS_OK;
 }
diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.h b/layout/mathml/nsMathMLmmultiscriptsFrame.h
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.h
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.h
@@ -32,18 +32,17 @@ public:
 
   static nsresult
   PlaceMultiScript(nsPresContext*      aPresContext,
                     nsRenderingContext& aRenderingContext,
                     bool                 aPlaceOrigin,
                     nsHTMLReflowMetrics& aDesiredSize,
                     nsMathMLContainerFrame* aForFrame,
                     nscoord              aUserSubScriptShift,
-                    nscoord              aUserSupScriptShift,
-                    nscoord              aScriptSpace);
+                    nscoord              aUserSupScriptShift);
 
   uint8_t
   ScriptIncrement(nsIFrame* aFrame) MOZ_OVERRIDE;
 
 protected:
   nsMathMLmmultiscriptsFrame(nsStyleContext* aContext) : nsMathMLContainerFrame(aContext) {}
   virtual ~nsMathMLmmultiscriptsFrame();
   
diff --git a/layout/mathml/nsMathMLmunderoverFrame.cpp b/layout/mathml/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/nsMathMLmunderoverFrame.cpp
@@ -282,39 +282,35 @@ i.e.,:
 nsMathMLmunderoverFrame::Place(nsRenderingContext& aRenderingContext,
                                bool                 aPlaceOrigin,
                                nsHTMLReflowMetrics& aDesiredSize)
 {
   nsIAtom* tag = mContent->Tag();
   if (NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
       StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_INLINE) {
     //place like sub sup or subsup
-    nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
     if (tag == nsGkAtoms::munderover_) {
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     } else if (tag == nsGkAtoms::munder_) {
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     } else {
       NS_ASSERTION(tag == nsGkAtoms::mover_, "mContent->Tag() not recognized");
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
-                                                          this, 0, 0,
-                                                          scriptSpace);
+                                                          this, 0, 0);
     }
     
   }
 
   ////////////////////////////////////
   // Get the children's desired sizes
 
   nsBoundingMetrics bmBase, bmUnder, bmOver;
