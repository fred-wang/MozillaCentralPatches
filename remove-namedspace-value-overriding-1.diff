# HG changeset patch
# Parent 82fe146ec9449c35d2d78c91863191b1c426d18d
# User Frédéric Wang <fred.wang@free.fr>
Remove namedspace value overriding - part 1 (bug 673759). r=karlt

diff --git a/content/mathml/content/src/nsMathMLElement.cpp b/content/mathml/content/src/nsMathMLElement.cpp
--- a/content/mathml/content/src/nsMathMLElement.cpp
+++ b/content/mathml/content/src/nsMathMLElement.cpp
@@ -227,16 +227,63 @@ nsMapRuleToAttributesFunc
 nsMathMLElement::GetAttributeMappingFunction() const
 {
   // It doesn't really matter what our tag is here, because only attributes
   // that satisfy IsAttributeMapped will be stored in the mapped attributes
   // list and available to the mapping function
   return &MapMathMLAttributesInto;
 }
 
+/* static */ bool
+nsMathMLElement::ParseNamedSpaceValue(const nsString& aString,
+                                      nsCSSValue&     aCSSValue,
+                                      PRUint32        aFlags)
+{
+   PRInt32 i = 0;
+   // See if it is one of the 'namedspace' (ranging 1/18em...7/18em)
+   if (aString.EqualsLiteral("veryverythinmathspace")) {
+     i = 1;
+   } else if (aString.EqualsLiteral("verythinmathspace")) {
+     i = 2;
+   } else if (aString.EqualsLiteral("thinmathspace")) {
+     i = 3;
+   } else if (aString.EqualsLiteral("mediummathspace")) {
+     i = 4;
+   } else if (aString.EqualsLiteral("thickmathspace")) {
+     i = 5;
+   } else if (aString.EqualsLiteral("verythickmathspace")) {
+     i = 6;
+   } else if (aString.EqualsLiteral("veryverythickmathspace")) {
+     i = 7;
+   } else if (aFlags & PARSE_ALLOW_NEGATIVE) {
+     if (aString.EqualsLiteral("negativeveryverythinmathspace")) {
+       i = -1;
+     } else if (aString.EqualsLiteral("negativeverythinmathspace")) {
+       i = -2;
+     } else if (aString.EqualsLiteral("negativethinmathspace")) {
+       i = -3;
+     } else if (aString.EqualsLiteral("negativemediummathspace")) {
+       i = -4;
+     } else if (aString.EqualsLiteral("negativethickmathspace")) {
+       i = -5;
+     } else if (aString.EqualsLiteral("negativeverythickmathspace")) {
+       i = -6;
+     } else if (aString.EqualsLiteral("negativeveryverythickmathspace")) {
+       i = -7;
+     }
+   }
+   if (0 != i) { 
+     // fall back to the default value
+     aCSSValue.SetFloatValue(float(i)/float(18), eCSSUnit_EM);
+     return true;
+   }
+   
+   return false;
+}
+ 
 // ================
 // Utilities for parsing and retrieving numeric values
 
 /*
 The REC says:
   An explicit plus sign ('+') is not allowed as part of a numeric value
   except when it is specifically listed in the syntax (as a quoted '+'
   or "+"),
@@ -258,23 +305,32 @@ Implementation here:
   [h/v-unit]
 */
 
 /* static */ bool
 nsMathMLElement::ParseNumericValue(const nsString& aString,
                                    nsCSSValue&     aCSSValue,
                                    PRUint32        aFlags)
 {
+  if (aFlags & PARSE_MPADDED_SYNTAX) {
+    // XXXfw To reimplement! (bug 677036)
+    return false;
+  }
+
   nsAutoString str(aString);
   str.CompressWhitespace(); // aString is const in this code...
 
   PRInt32 stringLength = str.Length();
   if (!stringLength)
     return false;
 
+  if (ParseNamedSpaceValue(aString, aCSSValue, aFlags)) {
+    return true;
+  }
+
   nsAutoString number, unit;
 
   // see if the negative sign is there
   PRInt32 i = 0;
   PRUnichar c = str[0];
   if (c == '-') {
     number.Append(c);
     i++;
diff --git a/content/mathml/content/src/nsMathMLElement.h b/content/mathml/content/src/nsMathMLElement.h
--- a/content/mathml/content/src/nsMathMLElement.h
+++ b/content/mathml/content/src/nsMathMLElement.h
@@ -82,18 +82,23 @@ public:
                                 const nsAString& aValue,
                                 nsAttrValue& aResult);
 
   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
 
   enum {
     PARSE_ALLOW_UNITLESS = 0x01, // unitless 0 will be turned into 0px
-    PARSE_ALLOW_NEGATIVE = 0x02
+    PARSE_ALLOW_NEGATIVE = 0x02,
+    PARSE_MPADDED_SYNTAX = 0x04
   };
+  static bool ParseNamedSpaceValue(const nsString& aString,
+                                   nsCSSValue&     aCSSValue,
+                                   PRUint32        aFlags);
+
   static bool ParseNumericValue(const nsString& aString,
                                   nsCSSValue&     aCSSValue,
                                   PRUint32        aFlags);
 
   static void MapMathMLAttributesInto(const nsMappedAttributes* aAttributes, 
                                       nsRuleData* aRuleData);
   
   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
diff --git a/layout/mathml/nsMathMLFrame.cpp b/layout/mathml/nsMathMLFrame.cpp
--- a/layout/mathml/nsMathMLFrame.cpp
+++ b/layout/mathml/nsMathMLFrame.cpp
@@ -342,138 +342,64 @@ nsMathMLFrame::GetAxisHeight(nsRendering
   nsBoundingMetrics bm = aRenderingContext.GetBoundingMetrics(&minus, 1);
   aAxisHeight = bm.ascent - (bm.ascent + bm.descent)/2;
   if (aAxisHeight <= 0 || aAxisHeight >= xHeight) {
     // fall-back to the other version
     GetAxisHeight(aFontMetrics, aAxisHeight);
   }
 }
 
-/* static */ nscoord
-nsMathMLFrame::CalcLength(nsPresContext*   aPresContext,
-                          nsStyleContext*   aStyleContext,
-                          const nsCSSValue& aCSSValue)
+/* static */ void
+nsMathMLFrame::ParseNumericValue(const nsString&   aString,
+                                 nscoord&          aLengthValue,
+                                 PRUint32          aFlags,
+                                 nsPresContext*    aPresContext,
+                                 nsStyleContext*   aStyleContext)
 {
-  NS_ASSERTION(aCSSValue.IsLengthUnit(), "not a length unit");
+  nsCSSValue cssValue;
 
-  if (aCSSValue.IsFixedLengthUnit()) {
-    return aCSSValue.GetFixedLength(aPresContext);
-  }
-  if (aCSSValue.IsPixelLengthUnit()) {
-    return aCSSValue.GetPixelLength();
+  if (!nsMathMLElement::ParseNumericValue(aString, cssValue, aFlags)) {
+    return;
   }
 
-  nsCSSUnit unit = aCSSValue.GetUnit();
+  nsCSSUnit unit = cssValue.GetUnit();
+
+  if (unit == eCSSUnit_Percent || unit == eCSSUnit_Number) {
+    aLengthValue = NSToCoordRound(cssValue.GetFloatValue() * aLengthValue);
+    return;
+  }
+
+  if (cssValue.IsFixedLengthUnit()) {
+    aLengthValue = cssValue.GetFixedLength(aPresContext);
+    return;
+  }
+
+  if (cssValue.IsPixelLengthUnit()) {
+    aLengthValue = cssValue.GetPixelLength();
+    return;
+  }
 
   if (eCSSUnit_EM == unit) {
     const nsStyleFont* font = aStyleContext->GetStyleFont();
-    return NSToCoordRound(aCSSValue.GetFloatValue() * (float)font->mFont.size);
+    aLengthValue = NSToCoordRound(cssValue.GetFloatValue() *
+                                  (float)font->mFont.size);
+    return;
   }
   else if (eCSSUnit_XHeight == unit) {
     nsRefPtr<nsFontMetrics> fm;
     nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
                                                  getter_AddRefs(fm));
     nscoord xHeight = fm->XHeight();
-    return NSToCoordRound(aCSSValue.GetFloatValue() * (float)xHeight);
+    aLengthValue = NSToCoordRound(cssValue.GetFloatValue() * (float)xHeight);
+    return;
   }
 
   // MathML doesn't specify other CSS units such as rem or ch
-  NS_ERROR("Unsupported unit");
-  return 0;
-}
-
-/* static */ bool
-nsMathMLFrame::ParseNamedSpaceValue(nsIFrame*   aMathMLmstyleFrame,
-                                    nsString&   aString,
-                                    nsCSSValue& aCSSValue)
-{
-  aCSSValue.Reset();
-  aString.CompressWhitespace(); //  aString is not a const in this code...
-  if (!aString.Length()) return false;
-
-  // See if it is one of the 'namedspace' (ranging 1/18em...7/18em)
-  PRInt32 i = 0;
-  nsIAtom* namedspaceAtom = nsnull;
-  if (aString.EqualsLiteral("veryverythinmathspace")) {
-    i = 1;
-    namedspaceAtom = nsGkAtoms::veryverythinmathspace_;
-  }
-  else if (aString.EqualsLiteral("verythinmathspace")) {
-    i = 2;
-    namedspaceAtom = nsGkAtoms::verythinmathspace_;
-  }
-  else if (aString.EqualsLiteral("thinmathspace")) {
-    i = 3;
-    namedspaceAtom = nsGkAtoms::thinmathspace_;
-  }
-  else if (aString.EqualsLiteral("mediummathspace")) {
-    i = 4;
-    namedspaceAtom = nsGkAtoms::mediummathspace_;
-  }
-  else if (aString.EqualsLiteral("thickmathspace")) {
-    i = 5;
-    namedspaceAtom = nsGkAtoms::thickmathspace_;
-  }
-  else if (aString.EqualsLiteral("verythickmathspace")) {
-    i = 6;
-    namedspaceAtom = nsGkAtoms::verythickmathspace_;
-  }
-  else if (aString.EqualsLiteral("veryverythickmathspace")) {
-    i = 7;
-    namedspaceAtom = nsGkAtoms::veryverythickmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativeveryverythinmathspace")) {
-    i = -1;
-    namedspaceAtom = nsGkAtoms::negativeveryverythinmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativeverythinmathspace")) {
-    i = -2;
-    namedspaceAtom = nsGkAtoms::negativeverythinmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativethinmathspace")) {
-    i = -3;
-    namedspaceAtom = nsGkAtoms::negativethinmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativemediummathspace")) {
-    i = -4;
-    namedspaceAtom = nsGkAtoms::negativemediummathspace_;
-  }
-  else if (aString.EqualsLiteral("negativethickmathspace")) {
-    i = -5;
-    namedspaceAtom = nsGkAtoms::negativethickmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativeverythickmathspace")) {
-    i = -6;
-    namedspaceAtom = nsGkAtoms::negativeverythickmathspace_;
-  }
-  else if (aString.EqualsLiteral("negativeveryverythickmathspace")) {
-    i = -7;
-    namedspaceAtom = nsGkAtoms::negativeveryverythickmathspace_;
-  }
-
-  if (0 != i) {
-    if (aMathMLmstyleFrame) {
-      // see if there is a <mstyle> that has overriden the default value
-      // GetAttribute() will recurse all the way up into the <mstyle> hierarchy
-      nsAutoString value;
-      GetAttribute(nsnull, aMathMLmstyleFrame, namedspaceAtom, value);
-      if (!value.IsEmpty()) {
-        if (ParseNumericValue(value, aCSSValue) &&
-            aCSSValue.IsLengthUnit()) {
-          return true;
-        }
-      }
-    }
-
-    // fall back to the default value
-    aCSSValue.SetFloatValue(float(i)/float(18), eCSSUnit_EM);
-    return true;
-  }
-
-  return false;
+  NS_NOTREACHED("Unsupported unit");
+  return;
 }
 
 // ================
 // Utils to map attributes into CSS rules (work-around to bug 69409 which
 // is not scheduled to be fixed anytime soon)
 //
 
 static const PRInt32 kMathMLversion1 = 1;
diff --git a/layout/mathml/nsMathMLFrame.h b/layout/mathml/nsMathMLFrame.h
--- a/layout/mathml/nsMathMLFrame.h
+++ b/layout/mathml/nsMathMLFrame.h
@@ -181,33 +181,21 @@ public:
   static bool
   GetAttribute(nsIContent* aContent,
                nsIFrame*   aMathMLmstyleFrame,          
                nsIAtom*    aAttributeAtom,
                nsString&   aValue);
 
   // utilities to parse and retrieve numeric values in CSS units
   // All values are stored in twips.
-  static bool
-  ParseNumericValue(const nsString& aString,
-                    nsCSSValue&     aCSSValue) {
-    return nsMathMLElement::ParseNumericValue(aString, aCSSValue,
-            nsMathMLElement::PARSE_ALLOW_NEGATIVE |
-            nsMathMLElement::PARSE_ALLOW_UNITLESS);
-  }
-
-  static nscoord 
-  CalcLength(nsPresContext*   aPresContext,
-             nsStyleContext*   aStyleContext,
-             const nsCSSValue& aCSSValue);
-
-  static bool
-  ParseNamedSpaceValue(nsIFrame*   aMathMLmstyleFrame,
-                       nsString&   aString,
-                       nsCSSValue& aCSSValue);
+  static void ParseNumericValue(const nsString&   aString,
+                                nscoord&          aLengthValue,
+                                PRUint32          aFlags,
+                                nsPresContext*    aPresContext,
+                                nsStyleContext*   aStyleContext);
 
   static eMathMLFrameType
   GetMathMLFrameTypeFor(nsIFrame* aFrame)
   {
     if (aFrame->IsFrameOfType(nsIFrame::eMathML)) {
       nsIMathMLFrame* mathMLFrame = do_QueryFrame(aFrame);
       if (mathMLFrame)
         return mathMLFrame->GetMathMLFrameType();
diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -119,16 +119,24 @@ nsMathMLmfracFrame::CalcLineThickness(ns
                                       nsString&        aThicknessAttribute,
                                       nscoord          onePixel,
                                       nscoord          aDefaultRuleThickness)
 {
   nscoord defaultThickness = aDefaultRuleThickness;
   nscoord lineThickness = aDefaultRuleThickness;
   nscoord minimumThickness = onePixel;
 
+  // linethickness
+  //
+  // "Specifies the thickness of the horizontal 'fraction bar', or 'rule'. The
+  // default value is 'medium', 'thin' is thinner, but visible, 'thick' is
+  // thicker; the exact thickness of these is left up to the rendering agent."
+  //
+  // syntax: length | "thin" | "medium" | "thick"
+  //
   if (!aThicknessAttribute.IsEmpty()) {
     if (aThicknessAttribute.EqualsLiteral("thin")) {
       lineThickness = NSToCoordFloor(defaultThickness * THIN_FRACTION_LINE);
       minimumThickness = onePixel * THIN_FRACTION_LINE_MINIMUM_PIXELS;
       // should visually decrease by at least one pixel, if default is not a pixel
       if (defaultThickness > onePixel && lineThickness > defaultThickness - onePixel)
         lineThickness = defaultThickness - onePixel;
     }
@@ -137,27 +145,22 @@ nsMathMLmfracFrame::CalcLineThickness(ns
     }
     else if (aThicknessAttribute.EqualsLiteral("thick")) {
       lineThickness = NSToCoordCeil(defaultThickness * THICK_FRACTION_LINE);
       minimumThickness = onePixel * THICK_FRACTION_LINE_MINIMUM_PIXELS;
       // should visually increase by at least one pixel
       if (lineThickness < defaultThickness + onePixel)
         lineThickness = defaultThickness + onePixel;
     }
-    else { // see if it is a plain number, or a percentage, or a h/v-unit like 1ex, 2px, 1em
-      nsCSSValue cssValue;
-      if (ParseNumericValue(aThicknessAttribute, cssValue)) {
-        nsCSSUnit unit = cssValue.GetUnit();
-        if (eCSSUnit_Number == unit)
-          lineThickness = nscoord(float(defaultThickness) * cssValue.GetFloatValue());
-        else if (eCSSUnit_Percent == unit)
-          lineThickness = nscoord(float(defaultThickness) * cssValue.GetPercentValue());
-        else if (eCSSUnit_Null != unit)
-          lineThickness = CalcLength(aPresContext, aStyleContext, cssValue);
-      }
+    else {
+      // length value
+      lineThickness = defaultThickness;
+      ParseNumericValue(aThicknessAttribute, lineThickness,
+                        nsMathMLElement::PARSE_ALLOW_UNITLESS,
+                        aPresContext, aStyleContext);
     }
   }
 
   // use minimum if the lineThickness is a non-zero value less than minimun
   if (lineThickness && lineThickness < minimumThickness) 
     lineThickness = minimumThickness;
 
   return lineThickness;
diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
@@ -115,34 +115,46 @@ nsMathMLmmultiscriptsFrame::TransmitAuto
 }
 
 void
 nsMathMLmmultiscriptsFrame::ProcessAttributes()
 {
   mSubScriptShift = 0;
   mSupScriptShift = 0;
 
-  // check if the subscriptshift attribute is there
+  // subscriptshift
+  //
+  // "Specifies the minimum amount to shift the baseline of subscript down; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   nsAutoString value;
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::subscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      mSubScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, mSubScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
-  // check if the superscriptshift attribute is there
+  // superscriptshift
+  //
+  // "Specifies the minimum amount to shift the baseline of superscript up; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::superscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      mSupScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, mSupScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
 }
 
 /* virtual */ nsresult
 nsMathMLmmultiscriptsFrame::Place(nsRenderingContext& aRenderingContext,
                                   bool                 aPlaceOrigin,
                                   nsHTMLReflowMetrics& aDesiredSize)
 {
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -408,48 +408,44 @@ nsMathMLmoFrame::ProcessOperatorData()
         }
       }
     }
   }
 
   // If we are an accent without explicit lspace="." or rspace=".",
   // we will ignore our default leading/trailing space
 
-  // lspace = number h-unit | namedspace
+  // lspace
+  //
+  // "Specifies the leading space appearing before the operator"
+  //
   nscoord leadingSpace = mEmbellishData.leadingSpace;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::lspace_,
                value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) ||
-        ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue))
-    {
-      if ((eCSSUnit_Number == cssValue.GetUnit()) && !cssValue.GetFloatValue())
-        leadingSpace = 0;
-      else if (cssValue.IsLengthUnit())
-        leadingSpace = CalcLength(presContext, mStyleContext, cssValue);
-      mFlags |= NS_MATHML_OPERATOR_LSPACE_ATTR;
-    }
+    ParseNumericValue(value, leadingSpace, 
+                      nsMathMLElement::PARSE_ALLOW_UNITLESS |
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      presContext, mStyleContext);
+    mFlags |= NS_MATHML_OPERATOR_LSPACE_ATTR;
   }
 
-  // rspace = number h-unit | namedspace
+  // rspace
+  //
+  // "Specifies the trailing space appearing after the operator"
+  //
   nscoord trailingSpace = mEmbellishData.trailingSpace;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::rspace_,
                value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) ||
-        ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue))
-    {
-      if ((eCSSUnit_Number == cssValue.GetUnit()) && !cssValue.GetFloatValue())
-        trailingSpace = 0;
-      else if (cssValue.IsLengthUnit())
-        trailingSpace = CalcLength(presContext, mStyleContext, cssValue);
-      mFlags |= NS_MATHML_OPERATOR_RSPACE_ATTR;
-    }
+    ParseNumericValue(value, trailingSpace, 
+                      nsMathMLElement::PARSE_ALLOW_UNITLESS |
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      presContext, mStyleContext);
+    mFlags |= NS_MATHML_OPERATOR_RSPACE_ATTR;
   }
 
   // little extra tuning to round lspace & rspace to at least a pixel so that
   // operators don't look as if they are colliding with their operands
   if (leadingSpace || trailingSpace) {
     nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
     if (leadingSpace && leadingSpace < onePixel)
       leadingSpace = onePixel;
@@ -498,84 +494,35 @@ nsMathMLmoFrame::ProcessOperatorData()
   }
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::symmetric_,
                value);
   if (value.EqualsLiteral("false"))
     mFlags &= ~NS_MATHML_OPERATOR_SYMMETRIC;
   else if (value.EqualsLiteral("true"))
     mFlags |= NS_MATHML_OPERATOR_SYMMETRIC;
 
-  // minsize = number [ v-unit | h-unit ] | namedspace
+  // minsize
+  //
+  // 
+  //
   mMinSize = 0.0;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::minsize_,
                value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) ||
-        ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue))
-    {
-      nsCSSUnit unit = cssValue.GetUnit();
-      if (eCSSUnit_Number == unit)
-        mMinSize = cssValue.GetFloatValue();
-      else if (eCSSUnit_Percent == unit)
-        mMinSize = cssValue.GetPercentValue();
-      else if (eCSSUnit_Null != unit) {
-        mMinSize = float(CalcLength(presContext, mStyleContext, cssValue));
-        mFlags |= NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE;
-      }
-
-      if ((eCSSUnit_Number == unit) || (eCSSUnit_Percent == unit)) {
-        // see if the multiplicative inheritance should be from <mstyle>
-        GetAttribute(nsnull, mPresentationData.mstyle,
-                     nsGkAtoms::minsize_, value);
-        if (!value.IsEmpty()) {
-          if (ParseNumericValue(value, cssValue)) {
-            if (cssValue.IsLengthUnit()) {
-              mMinSize *= float(CalcLength(presContext, mStyleContext, cssValue));
-              mFlags |= NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE;
-            }
-          }
-        }
-      }
-    }
+    // XXXfw TODO
   }
 
-  // maxsize = number [ v-unit | h-unit ] | namedspace | infinity
+  // maxsize
+  //
+  // "Specifies the maximum size of the operator when stretchy"
   mMaxSize = NS_MATHML_OPERATOR_SIZE_INFINITY;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::maxsize_,
                value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) ||
-        ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue))
-    {
-      nsCSSUnit unit = cssValue.GetUnit();
-      if (eCSSUnit_Number == unit)
-        mMaxSize = cssValue.GetFloatValue();
-      else if (eCSSUnit_Percent == unit)
-        mMaxSize = cssValue.GetPercentValue();
-      else if (eCSSUnit_Null != unit) {
-        mMaxSize = float(CalcLength(presContext, mStyleContext, cssValue));
-        mFlags |= NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE;
-      }
-
-      if ((eCSSUnit_Number == unit) || (eCSSUnit_Percent == unit)) {
-        // see if the multiplicative inheritance should be from <mstyle>
-        GetAttribute(nsnull, mPresentationData.mstyle,
-                     nsGkAtoms::maxsize_, value);
-        if (!value.IsEmpty()) {
-          if (ParseNumericValue(value, cssValue)) {
-            if (cssValue.IsLengthUnit()) {
-              mMaxSize *= float(CalcLength(presContext, mStyleContext, cssValue));
-              mFlags |= NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE;
-            }
-          }
-        }
-      }
-    }
+    // XXXfw TODO    
   }
 }
 
 static PRUint32
 GetStretchHint(nsOperatorFlags aFlags, nsPresentationData aPresentationData,
                bool aIsVertical)
 {
   PRUint32 stretchHint = NS_STRETCH_NONE;
diff --git a/layout/mathml/nsMathMLmpaddedFrame.cpp b/layout/mathml/nsMathMLmpaddedFrame.cpp
--- a/layout/mathml/nsMathMLmpaddedFrame.cpp
+++ b/layout/mathml/nsMathMLmpaddedFrame.cpp
@@ -262,29 +262,29 @@ nsMathMLmpaddedFrame::ParseAttribute(nsS
     */
   }
   else if (unit.EqualsLiteral("width"))  aPseudoUnit = NS_MATHML_PSEUDO_UNIT_WIDTH;
   else if (unit.EqualsLiteral("height")) aPseudoUnit = NS_MATHML_PSEUDO_UNIT_HEIGHT;
   else if (unit.EqualsLiteral("depth"))  aPseudoUnit = NS_MATHML_PSEUDO_UNIT_DEPTH;
   else if (!gotPercent) { // percentage can only apply to a pseudo-unit
 
     // see if the unit is a named-space
-    // XXX nsnull in ParseNamedSpacedValue()? don't access mstyle?
-    if (ParseNamedSpaceValue(nsnull, unit, aCSSValue)) {
+    if (false) {
       // re-scale properly, and we know that the unit of the named-space is 'em'
       floatValue *= aCSSValue.GetFloatValue();
       aCSSValue.SetFloatValue(floatValue, eCSSUnit_EM);
       aPseudoUnit = NS_MATHML_PSEUDO_UNIT_NAMEDSPACE;
       return true;
     }
 
     // see if the input was just a CSS value
     number.Append(unit); // leave the sign out if it was there
-    if (ParseNumericValue(number, aCSSValue))
+    if (false) {
       return true;
+    }
   }
 
   // if we enter here, we have a number that will act as a multiplier on a pseudo-unit
   if (aPseudoUnit != NS_MATHML_PSEUDO_UNIT_UNSPECIFIED) {
     if (gotPercent)
       aCSSValue.SetPercentValue(floatValue / 100.0f);
     else
       aCSSValue.SetFloatValue(floatValue, eCSSUnit_Number);
@@ -335,17 +335,18 @@ nsMathMLmpaddedFrame::UpdateValue(PRInt3
       }
     }
 
     if (eCSSUnit_Number == unit)
       amount = NSToCoordRound(float(scaler) * aCSSValue.GetFloatValue());
     else if (eCSSUnit_Percent == unit)
       amount = NSToCoordRound(float(scaler) * aCSSValue.GetPercentValue());
     else
-      amount = CalcLength(PresContext(), mStyleContext, aCSSValue);
+      // XXXfw TODO
+      amount = 0; //CalcLength(PresContext(), mStyleContext, aCSSValue);
 
     if (NS_MATHML_SIGN_PLUS == aSign)
       aValueToUpdate += amount;
     else if (NS_MATHML_SIGN_MINUS == aSign)
       aValueToUpdate -= amount;
     else
       aValueToUpdate  = amount;
   }
diff --git a/layout/mathml/nsMathMLmspaceFrame.cpp b/layout/mathml/nsMathMLmspaceFrame.cpp
--- a/layout/mathml/nsMathMLmspaceFrame.cpp
+++ b/layout/mathml/nsMathMLmspaceFrame.cpp
@@ -66,61 +66,66 @@ bool
 nsMathMLmspaceFrame::IsLeaf() const
 {
   return true;
 }
 
 void
 nsMathMLmspaceFrame::ProcessAttributes(nsPresContext* aPresContext)
 {
-  /*
-  parse the attributes
-
-  width  = number h-unit 
-  height = number v-unit 
-  depth  = number v-unit 
-  */
-
   nsAutoString value;
-  nsCSSValue cssValue;
 
   // width 
+  //
+  // "Specifies the desired width of the space."
+  //
+  // The default value is "0em", so unitless values can be ignored.
+  // <mspace/> is listed among MathML elements allowing negative spacing and
+  // the MathML test suite contains "Presentation/TokenElements/mspace/mspace2" 
+  // as an example. Hence we allow negative values.
+  //
   mWidth = 0;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::width,
                value);
   if (!value.IsEmpty()) {
-    if ((ParseNumericValue(value, cssValue) ||
-         ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue)) &&
-         cssValue.IsLengthUnit()) {
-      mWidth = CalcLength(aPresContext, mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, mWidth,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      aPresContext, mStyleContext);
   }
 
   // height
+  //
+  // "Specifies the desired height (above the baseline) of the space."
+  //
+  // The default value is "0ex", so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bugs 411227, 716349)
+  //
   mHeight = 0;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::height,
                value);
   if (!value.IsEmpty()) {
-    if ((ParseNumericValue(value, cssValue) ||
-         ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue)) &&
-         cssValue.IsLengthUnit()) {
-      mHeight = CalcLength(aPresContext, mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, mHeight,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      aPresContext, mStyleContext);
   }
 
   // depth
+  //
+  // "Specifies the desired depth (below the baseline) of the space."
+  //
+  // The default value is "0ex", so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bugs 411227, 716349)
+  //
   mDepth = 0;
   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::depth_,
                value);
   if (!value.IsEmpty()) {
-    if ((ParseNumericValue(value, cssValue) ||
-         ParseNamedSpaceValue(mPresentationData.mstyle, value, cssValue)) &&
-         cssValue.IsLengthUnit()) {
-      mDepth = CalcLength(aPresContext, mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, mDepth,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      aPresContext, mStyleContext);
   }
 }
 
 NS_IMETHODIMP
 nsMathMLmspaceFrame::Reflow(nsPresContext*          aPresContext,
                             nsHTMLReflowMetrics&     aDesiredSize,
                             const nsHTMLReflowState& aReflowState,
                             nsReflowStatus&          aStatus)
diff --git a/layout/mathml/nsMathMLmsubFrame.cpp b/layout/mathml/nsMathMLmsubFrame.cpp
--- a/layout/mathml/nsMathMLmsubFrame.cpp
+++ b/layout/mathml/nsMathMLmsubFrame.cpp
@@ -84,26 +84,32 @@ nsMathMLmsubFrame::TransmitAutomaticData
 /* virtual */ nsresult
 nsMathMLmsubFrame::Place (nsRenderingContext& aRenderingContext,
                           bool                 aPlaceOrigin,
                           nsHTMLReflowMetrics& aDesiredSize)
 {
   // extra spacing after sup/subscript
   nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f); // 0.5pt as in plain TeX
 
-  // check if the subscriptshift attribute is there
+  // subscriptshift
+  //
+  // "Specifies the minimum amount to shift the baseline of subscript down; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   nscoord subScriptShift = 0;
   nsAutoString value;
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::subscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      subScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, subScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
 
   return nsMathMLmsubFrame::PlaceSubScript(PresContext(), 
                                            aRenderingContext,
                                            aPlaceOrigin,
                                            aDesiredSize,
                                            this,
                                            subScriptShift,
diff --git a/layout/mathml/nsMathMLmsubsupFrame.cpp b/layout/mathml/nsMathMLmsubsupFrame.cpp
--- a/layout/mathml/nsMathMLmsubsupFrame.cpp
+++ b/layout/mathml/nsMathMLmsubsupFrame.cpp
@@ -91,35 +91,48 @@ nsMathMLmsubsupFrame::TransmitAutomaticD
 nsMathMLmsubsupFrame::Place(nsRenderingContext& aRenderingContext,
                             bool                 aPlaceOrigin,
                             nsHTMLReflowMetrics& aDesiredSize)
 {
   // extra spacing between base and sup/subscript
   nscoord scriptSpace = 0;
 
   // check if the subscriptshift attribute is there
+  //
+  // The REC defines subscriptshift that way:
+  // "Specifies the minimum amount to shift the baseline of subscript down; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   nsAutoString value;
   nscoord subScriptShift = 0;
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::subscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      subScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, subScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
-  // check if the superscriptshift attribute is there
+  // superscriptshift
+  //
+  // "Specifies the minimum amount to shift the baseline of superscript up; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   nscoord supScriptShift = 0;
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::superscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      supScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, supScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
 
   return nsMathMLmsubsupFrame::PlaceSubSupScript(PresContext(),
                                                  aRenderingContext,
                                                  aPlaceOrigin,
                                                  aDesiredSize,
                                                  this,
                                                  subScriptShift,
diff --git a/layout/mathml/nsMathMLmsupFrame.cpp b/layout/mathml/nsMathMLmsupFrame.cpp
--- a/layout/mathml/nsMathMLmsupFrame.cpp
+++ b/layout/mathml/nsMathMLmsupFrame.cpp
@@ -84,26 +84,32 @@ nsMathMLmsupFrame::TransmitAutomaticData
 /* virtual */ nsresult
 nsMathMLmsupFrame::Place(nsRenderingContext& aRenderingContext,
                          bool                 aPlaceOrigin,
                          nsHTMLReflowMetrics& aDesiredSize)
 {
   // extra spacing after sup/subscript
   nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f); // 0.5pt as in plain TeX
 
-  // check if the superscriptshift attribute is there
+  // superscriptshift
+  //
+  // "Specifies the minimum amount to shift the baseline of superscript up; the
+  // default is for the rendering agent to use its own positioning rules."
+  //
+  // We use 0 as the default value so unitless values can be ignored.
+  // XXXfw Should we forbid negative values? (bug 411227)
+  //
   nsAutoString value;
   nscoord supScriptShift = 0;
   GetAttribute(mContent, mPresentationData.mstyle,
                nsGkAtoms::superscriptshift_, value);
   if (!value.IsEmpty()) {
-    nsCSSValue cssValue;
-    if (ParseNumericValue(value, cssValue) && cssValue.IsLengthUnit()) {
-      supScriptShift = CalcLength(PresContext(), mStyleContext, cssValue);
-    }
+    ParseNumericValue(value, supScriptShift,
+                      nsMathMLElement::PARSE_ALLOW_NEGATIVE,
+                      PresContext(), mStyleContext);
   }
 
   return nsMathMLmsupFrame::PlaceSuperScript(PresContext(), 
                                              aRenderingContext,
                                              aPlaceOrigin,
                                              aDesiredSize,
                                              this,
                                              supScriptShift,
