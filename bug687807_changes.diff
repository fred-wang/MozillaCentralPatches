# HG changeset patch
# Parent eed9fe35a00d284c6a10f083c104d3f4373108ba
# User James Kitchener <jkitch.bug@internode.on.net>
Bug 687807 - Improvements to stretching of embellished operators

diff --git a/layout/mathml/nsMathMLContainerFrame.cpp b/layout/mathml/nsMathMLContainerFrame.cpp
--- a/layout/mathml/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/nsMathMLContainerFrame.cpp
@@ -196,20 +196,24 @@ nsMathMLContainerFrame::GetPreferredStre
   }
   else if (aOptions & STRETCH_CONSIDER_EMBELLISHMENTS) {
     // compute our up-to-date size using Place()
     nsHTMLReflowMetrics metrics(GetWritingMode()); // ???
     Place(aRenderingContext, false, metrics);
     aPreferredStretchSize = metrics.mBoundingMetrics;
   }
   else {
-    // compute a size that doesn't include embellishements
-    bool stretchAll =
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
+    // compute a size that includes embellishments iff the container stretches
+    // in the same direction as the embellished operator.
+    bool stretchAll = aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL ?
+                      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) :
+                      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
+    NS_ASSERTION(aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL ||
+                 aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL,
+                 "You must specify a direction in which to stretch");
     NS_ASSERTION(NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) ||
                  stretchAll,
                  "invalid call to GetPreferredStretchSize");
     bool firstTime = true;
     nsBoundingMetrics bm, bmChild;
     nsIFrame* childFrame =
       stretchAll ? GetFirstPrincipalChild() : mPresentationData.baseFrame;
     while (childFrame) {
@@ -243,17 +247,17 @@ nsMathMLContainerFrame::GetPreferredStre
         bm = bmChild;
         if (!stretchAll) {
           // we may get here for cases such as <msup><mo>...</mo> ... </msup>,
           // or <maction>...<mo>...</mo></maction>.
           break;
         }
       }
       else {
-        if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {
+        if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
           // if we get here, it means this is container that will stack its children
           // vertically and fire an horizontal stretch on each them. This is the case
           // for \munder, \mover, \munderover. We just sum-up the size vertically.
           bm.descent += bmChild.ascent + bmChild.descent;
           // Sometimes non-spacing marks (when width is zero) are positioned
           // to the left of the origin, but it is the distance between left
           // and right bearing that is important rather than the offsets from
           // the origin.
@@ -261,17 +265,17 @@ nsMathMLContainerFrame::GetPreferredStre
             bmChild.rightBearing -= bmChild.leftBearing;
             bmChild.leftBearing = 0;
           }
           if (bm.leftBearing > bmChild.leftBearing)
             bm.leftBearing = bmChild.leftBearing;
           if (bm.rightBearing < bmChild.rightBearing)
             bm.rightBearing = bmChild.rightBearing;
         }
-        else if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags)) {
+        else if (aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) {
           // just sum-up the sizes horizontally.
           bm += bmChild;
         }
         else {
           NS_ERROR("unexpected case in GetPreferredStretchSize");
           break;
         }
       }
@@ -282,16 +286,22 @@ nsMathMLContainerFrame::GetPreferredStre
 }
 
 NS_IMETHODIMP
 nsMathMLContainerFrame::Stretch(nsRenderingContext& aRenderingContext,
                                 nsStretchDirection   aStretchDirection,
                                 nsBoundingMetrics&   aContainerSize,
                                 nsHTMLReflowMetrics& aDesiredStretchSize)
 {
+
+  NS_PRECONDITION(aStretchDirection != NS_STRETCH_DIRECTION_DEFAULT,
+                  "Default is not a supported direction.");
+  // If in doubt, choose a vertical direction and this method will correct
+  // to horizontal if necessary.
+
   if (NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags)) {
 
     if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {
       NS_WARNING("it is wrong to fire stretch more than once on a frame");
       return NS_OK;
     }
     mPresentationData.flags |= NS_MATHML_STRETCH_DONE;
 
@@ -323,31 +333,35 @@ nsMathMLContainerFrame::Stretch(nsRender
         //   <mstyle>
         //     <msub>
         //        <msub><mo>&Sum;</mo><mfrac><mi>a</mi><mi>b</mi></mfrac></msub>
         //        <msub><mo>&Sum;</mo><mfrac><mi>a</mi><mi>b</mi></mfrac></msub>
         //      </msub>
         //   </mstyle>
         // </math>
         nsBoundingMetrics containerSize = aContainerSize;
-        if (aStretchDirection != NS_STRETCH_DIRECTION_DEFAULT &&
-            aStretchDirection != mEmbellishData.direction) {
+        if (aStretchDirection != mEmbellishData.direction) {
           if (mEmbellishData.direction == NS_STRETCH_DIRECTION_UNSUPPORTED) {
             containerSize = childSize.mBoundingMetrics;
           }
           else {
             GetPreferredStretchSize(aRenderingContext, 
                                     stretchAll ? STRETCH_CONSIDER_EMBELLISHMENTS : 0,
                                     mEmbellishData.direction, containerSize);
+            if (mEmbellishData.direction == NS_STRETCH_DIRECTION_HORIZONTAL &&
+                NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {
+              // Stop subsequent calls from retriggering size calculations
+              aStretchDirection = NS_STRETCH_DIRECTION_HORIZONTAL;
+            }
           }
         }
 
         // do the stretching...
         mathMLFrame->Stretch(aRenderingContext,
-                             mEmbellishData.direction, containerSize, childSize);
+                             aStretchDirection, containerSize, childSize);
         // store the updated metrics
         SaveReflowAndBoundingMetricsFor(baseFrame, childSize,
                                         childSize.mBoundingMetrics);
         
         // Remember the siblings which were _deferred_.
         // Now that this embellished child may have changed, we need to
         // fire the stretch on its siblings using our updated size
 
@@ -497,27 +511,32 @@ nsMathMLContainerFrame::FinalizeReflow(n
     if (!parentWillFireStretch) {
       // There is nobody who will fire the stretch for us, we do it ourselves!
 
       bool stretchAll =
         /* NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) || */
         NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
 
       nsBoundingMetrics defaultSize;
-      if (mEmbellishData.coreFrame == this /* case of a bare <mo>...</mo> itself */
-          || stretchAll) { /* or <mover><mo>...</mo>...</mover>, or friends */
+      nsStretchDirection stretchDir;
+      if (mEmbellishData.coreFrame == this || /* case of a bare <mo>...</mo> itself */
+          (mEmbellishData.direction == NS_STRETCH_DIRECTION_HORIZONTAL &&
+           stretchAll) || /* or <mover><mo>...</mo>...</mover>, or friends */
+          mEmbellishData.direction == NS_STRETCH_DIRECTION_UNSUPPORTED) { /* Doesn't stretch */
         // use our current size as computed earlier by Place()
         defaultSize = aDesiredSize.mBoundingMetrics;
+        stretchDir = mEmbellishData.direction;
       }
       else { /* case of <msup><mo>...</mo>...</msup> or friends */
-        // compute a size that doesn't include embellishments
-        GetPreferredStretchSize(aRenderingContext, 0, mEmbellishData.direction,
-                                defaultSize);
+        // Default to a vertical stretch.  This will be corrected within
+        // Stretch() where necessary.
+        stretchDir = NS_STRETCH_DIRECTION_VERTICAL;
+        GetPreferredStretchSize(aRenderingContext, 0, stretchDir, defaultSize);
       }
-      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_DEFAULT, defaultSize,
+      Stretch(aRenderingContext, stretchDir, defaultSize,
               aDesiredSize);
 #ifdef DEBUG
       {
         // The Place() call above didn't request FinishReflowChild(),
         // so let's check that we eventually did through Stretch().
         nsIFrame* childFrame = GetFirstPrincipalChild();
         for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
           NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_IN_REFLOW),
