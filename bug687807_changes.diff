# HG changeset patch
# Parent a9b43778f0c25a56ac5ee65af4aa00c1bfa8db75
# User James Kitchener <jkitch.bug@internode.on.net>
Bug 687807 - Improvements to stretching of embellished operators

diff --git a/layout/mathml/nsIMathMLFrame.h b/layout/mathml/nsIMathMLFrame.h
--- a/layout/mathml/nsIMathMLFrame.h
+++ b/layout/mathml/nsIMathMLFrame.h
@@ -69,25 +69,30 @@ public:
   *
   * An embellished frame is treated in a special way. When it receives a
   * Stretch() command, it passes the command to its embellished child and
   * the stretched size is bubbled up from the inner-most <mo> frame. In other
   * words, the stretch command descend through the embellished hierarchy.
   *
   * @param aStretchDirection [in] the direction where to attempt to
   *        stretch.
+  * @param aHorizStretchRecalc [in] when set, this indicates aContainersize
+  *        should be recalculated when this method is called from an munderover
+  *        or similar frame.  The first call to stretch should generally set
+  *        this to true.
   * @param aContainerSize [in] struct that suggests the maximumn size for
   *        the stretched frame. Only member data of the struct that are 
   *        relevant to the direction are used (the rest is ignored). 
   * @param aDesiredStretchSize [in/out] On input the current size
   *        of the frame, on output the size after stretching.
   */
   NS_IMETHOD 
   Stretch(nsRenderingContext& aRenderingContext,
           nsStretchDirection   aStretchDirection,
+          bool                 aHorizStretchRecalc,
           nsBoundingMetrics&   aContainerSize,
           nsHTMLReflowMetrics& aDesiredStretchSize) = 0;
 
  /* Get the mEmbellishData member variable. */
  
   NS_IMETHOD
   GetEmbellishData(nsEmbellishData& aEmbellishData) = 0;
 
diff --git a/layout/mathml/nsMathMLContainerFrame.cpp b/layout/mathml/nsMathMLContainerFrame.cpp
--- a/layout/mathml/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/nsMathMLContainerFrame.cpp
@@ -198,18 +198,20 @@ nsMathMLContainerFrame::GetPreferredStre
     // compute our up-to-date size using Place()
     nsHTMLReflowMetrics metrics(GetWritingMode()); // ???
     Place(aRenderingContext, false, metrics);
     aPreferredStretchSize = metrics.mBoundingMetrics;
   }
   else {
     // compute a size that doesn't include embellishements
     bool stretchAll =
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
+      (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) &&
+       aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) ||
+      (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags) &&
+       aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL);
     NS_ASSERTION(NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) ||
                  stretchAll,
                  "invalid call to GetPreferredStretchSize");
     bool firstTime = true;
     nsBoundingMetrics bm, bmChild;
     nsIFrame* childFrame =
       stretchAll ? GetFirstPrincipalChild() : mPresentationData.baseFrame;
     while (childFrame) {
@@ -217,21 +219,20 @@ nsMathMLContainerFrame::GetPreferredStre
       nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);
       if (mathMLFrame) {
         nsEmbellishData embellishData;
         nsPresentationData presentationData;
         mathMLFrame->GetEmbellishData(embellishData);
         mathMLFrame->GetPresentationData(presentationData);
         if (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags) &&
             embellishData.direction == aStretchDirection &&
-            presentationData.baseFrame) {
-          // embellishements are not included, only consider the inner first child itself
-          // XXXkt Does that mean the core descendent frame should be used
-          // instead of the base child?
-          nsIMathMLFrame* mathMLchildFrame = do_QueryFrame(presentationData.baseFrame);
+            (!NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(presentationData.flags) ||
+             aStretchDirection != NS_STRETCH_DIRECTION_HORIZONTAL)) {
+          // embellishments are not included, only consider the inner first child itself
+          nsIMathMLFrame* mathMLchildFrame = do_QueryFrame(embellishData.coreFrame);
           if (mathMLchildFrame) {
             mathMLFrame = mathMLchildFrame;
           }
         }
         mathMLFrame->GetBoundingMetrics(bmChild);
       }
       else {
         nsHTMLReflowMetrics unused(GetWritingMode());
@@ -279,16 +280,17 @@ nsMathMLContainerFrame::GetPreferredStre
     }
     aPreferredStretchSize = bm;
   }
 }
 
 NS_IMETHODIMP
 nsMathMLContainerFrame::Stretch(nsRenderingContext& aRenderingContext,
                                 nsStretchDirection   aStretchDirection,
+                                bool                 aHorizStretchRecalc,
                                 nsBoundingMetrics&   aContainerSize,
                                 nsHTMLReflowMetrics& aDesiredStretchSize)
 {
   if (NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags)) {
 
     if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {
       NS_WARNING("it is wrong to fire stretch more than once on a frame");
       return NS_OK;
@@ -335,19 +337,35 @@ nsMathMLContainerFrame::Stretch(nsRender
           }
           else {
             GetPreferredStretchSize(aRenderingContext, 
                                     stretchAll ? STRETCH_CONSIDER_EMBELLISHMENTS : 0,
                                     mEmbellishData.direction, containerSize);
           }
         }
 
+        if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags) &&
+            mEmbellishData.direction == NS_STRETCH_DIRECTION_HORIZONTAL &&
+            aHorizStretchRecalc) {
+          // under/over frames are special in that horizontal stretches are
+          // always included when determining container size, however the
+          // previous call to GetPreferredStretchSize may not have been aware
+          // of the presence of such a frame.  In this event, we retrigger
+          // the size calculations.
+          GetPreferredStretchSize(aRenderingContext, 0,
+                                  mEmbellishData.direction, containerSize);
+          // Only the outermost under/over frame in an embellished operator
+          // gets special treatment.
+          aHorizStretchRecalc = false;
+        }
+
         // do the stretching...
         mathMLFrame->Stretch(aRenderingContext,
-                             mEmbellishData.direction, containerSize, childSize);
+                             mEmbellishData.direction, aHorizStretchRecalc,
+                             containerSize, childSize);
         // store the updated metrics
         SaveReflowAndBoundingMetricsFor(baseFrame, childSize,
                                         childSize.mBoundingMetrics);
         
         // Remember the siblings which were _deferred_.
         // Now that this embellished child may have changed, we need to
         // fire the stretch on its siblings using our updated size
 
@@ -364,17 +382,17 @@ nsMathMLContainerFrame::Stretch(nsRender
           while (childFrame) {
             if (childFrame != mPresentationData.baseFrame) {
               mathMLFrame = do_QueryFrame(childFrame);
               if (mathMLFrame) {
                 // retrieve the metrics that was stored at the previous pass
                 GetReflowAndBoundingMetricsFor(childFrame, 
                   childSize, childSize.mBoundingMetrics);
                 // do the stretching...
-                mathMLFrame->Stretch(aRenderingContext, stretchDir,
+                mathMLFrame->Stretch(aRenderingContext, stretchDir, false,
                                      containerSize, childSize);
                 // store the updated metrics
                 SaveReflowAndBoundingMetricsFor(childFrame, childSize,
                                                 childSize.mBoundingMetrics);
               }
             }
             childFrame = childFrame->GetNextSibling();
           }
@@ -497,28 +515,29 @@ nsMathMLContainerFrame::FinalizeReflow(n
     if (!parentWillFireStretch) {
       // There is nobody who will fire the stretch for us, we do it ourselves!
 
       bool stretchAll =
         /* NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) || */
         NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
 
       nsBoundingMetrics defaultSize;
-      if (mEmbellishData.coreFrame == this /* case of a bare <mo>...</mo> itself */
-          || stretchAll) { /* or <mover><mo>...</mo>...</mover>, or friends */
+      if (mEmbellishData.coreFrame == this || /* case of a bare <mo>...</mo> itself */
+          (mEmbellishData.direction != NS_STRETCH_DIRECTION_VERTICAL &&
+           stretchAll)) { /* or <mover><mo>...</mo>...</mover>, or friends */
         // use our current size as computed earlier by Place()
         defaultSize = aDesiredSize.mBoundingMetrics;
       }
       else { /* case of <msup><mo>...</mo>...</msup> or friends */
         // compute a size that doesn't include embellishments
         GetPreferredStretchSize(aRenderingContext, 0, mEmbellishData.direction,
                                 defaultSize);
       }
-      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_DEFAULT, defaultSize,
-              aDesiredSize);
+      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_DEFAULT, true,
+              defaultSize, aDesiredSize);
 #ifdef DEBUG
       {
         // The Place() call above didn't request FinishReflowChild(),
         // so let's check that we eventually did through Stretch().
         nsIFrame* childFrame = GetFirstPrincipalChild();
         for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
           NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_IN_REFLOW),
                        "DidReflow() was never called");
@@ -932,17 +951,17 @@ nsMathMLContainerFrame::Reflow(nsPresCon
     while (childFrame) {
       nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);
       if (mathMLFrame) {
         // retrieve the metrics that was stored at the previous pass
         nsHTMLReflowMetrics childDesiredSize(aReflowState);
         GetReflowAndBoundingMetricsFor(childFrame,
           childDesiredSize, childDesiredSize.mBoundingMetrics);
 
-        mathMLFrame->Stretch(*aReflowState.rendContext, stretchDir,
+        mathMLFrame->Stretch(*aReflowState.rendContext, stretchDir, true,
                              containerSize, childDesiredSize);
         // store the updated metrics
         SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                         childDesiredSize.mBoundingMetrics);
       }
       childFrame = childFrame->GetNextSibling();
     }
   }
diff --git a/layout/mathml/nsMathMLContainerFrame.h b/layout/mathml/nsMathMLContainerFrame.h
--- a/layout/mathml/nsMathMLContainerFrame.h
+++ b/layout/mathml/nsMathMLContainerFrame.h
@@ -38,16 +38,17 @@ public:
   NS_DECL_FRAMEARENA_HELPERS
 
   // --------------------------------------------------------------------------
   // Overloaded nsMathMLFrame methods -- see documentation in nsIMathMLFrame.h
 
   NS_IMETHOD
   Stretch(nsRenderingContext& aRenderingContext,
           nsStretchDirection   aStretchDirection,
+          bool                 aHorizStretchRecalc,
           nsBoundingMetrics&   aContainerSize,
           nsHTMLReflowMetrics& aDesiredStretchSize) MOZ_OVERRIDE;
 
   NS_IMETHOD
   UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
                                     int32_t         aLastIndex,
                                     uint32_t        aFlagsValues,
                                     uint32_t        aFlagsToUpdate) MOZ_OVERRIDE
diff --git a/layout/mathml/nsMathMLFrame.h b/layout/mathml/nsMathMLFrame.h
--- a/layout/mathml/nsMathMLFrame.h
+++ b/layout/mathml/nsMathMLFrame.h
@@ -47,16 +47,17 @@ public:
     return NS_OK;
   }
 
   virtual eMathMLFrameType GetMathMLFrameType() MOZ_OVERRIDE;
 
   NS_IMETHOD
   Stretch(nsRenderingContext& aRenderingContext,
           nsStretchDirection   aStretchDirection,
+          bool                 aHorizStretchRecalc,
           nsBoundingMetrics&   aContainerSize,
           nsHTMLReflowMetrics& aDesiredStretchSize) MOZ_OVERRIDE
   {
     return NS_OK;
   }
 
   NS_IMETHOD
   GetEmbellishData(nsEmbellishData& aEmbellishData) MOZ_OVERRIDE {
diff --git a/layout/mathml/nsMathMLmfencedFrame.cpp b/layout/mathml/nsMathMLmfencedFrame.cpp
--- a/layout/mathml/nsMathMLmfencedFrame.cpp
+++ b/layout/mathml/nsMathMLmfencedFrame.cpp
@@ -268,17 +268,17 @@ nsMathMLmfencedFrame::Reflow(nsPresConte
     nsIMathMLFrame* mathmlChild = do_QueryFrame(childFrame);
     if (mathmlChild) {
       nsHTMLReflowMetrics childDesiredSize(aReflowState);
       // retrieve the metrics that was stored at the previous pass
       GetReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                      childDesiredSize.mBoundingMetrics);
       
       mathmlChild->Stretch(*aReflowState.rendContext, 
-                           stretchDir, containerSize, childDesiredSize);
+                           stretchDir, true, containerSize, childDesiredSize);
       // store the updated metrics
       SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                       childDesiredSize.mBoundingMetrics);
       
       nscoord childDescent = childDesiredSize.Height() - childDesiredSize.BlockStartAscent();
       if (descent < childDescent)
         descent = childDescent;
       if (ascent < childDesiredSize.BlockStartAscent())
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -592,16 +592,17 @@ GetStretchHint(nsOperatorFlags aFlags, n
 }
 
 // NOTE: aDesiredStretchSize is an IN/OUT parameter
 //       On input  - it contains our current size
 //       On output - the same size or the new size that we want
 NS_IMETHODIMP
 nsMathMLmoFrame::Stretch(nsRenderingContext& aRenderingContext,
                          nsStretchDirection   aStretchDirection,
+                         bool                 aHorizStretchRecalc,
                          nsBoundingMetrics&   aContainerSize,
                          nsHTMLReflowMetrics& aDesiredStretchSize)
 {
   if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {
     NS_WARNING("it is wrong to fire stretch more than once on a frame");
     return NS_OK;
   }
   mPresentationData.flags |= NS_MATHML_STRETCH_DONE;
diff --git a/layout/mathml/nsMathMLmoFrame.h b/layout/mathml/nsMathMLmoFrame.h
--- a/layout/mathml/nsMathMLmoFrame.h
+++ b/layout/mathml/nsMathMLmoFrame.h
@@ -59,16 +59,17 @@ public:
                    nsIAtom*        aAttribute,
                    int32_t         aModType) MOZ_OVERRIDE;
 
   // This method is called by the parent frame to ask <mo> 
   // to stretch itself.
   NS_IMETHOD
   Stretch(nsRenderingContext& aRenderingContext,
           nsStretchDirection   aStretchDirection,
+          bool                 aHorizStretchRecalc,
           nsBoundingMetrics&   aContainerSize,
           nsHTMLReflowMetrics& aDesiredStretchSize) MOZ_OVERRIDE;
 
   virtual nsresult
   ChildListChanged(int32_t aModType) MOZ_OVERRIDE
   {
     ProcessTextData();
     return nsMathMLContainerFrame::ChildListChanged(aModType);
