# HG changeset patch
# Parent 20ca234fd62b2c00ee67b8eeaf15c7fcfdbef7ae
# User James Kitchener <jkitch.bug@gmail.com>
Bug 687807 - Stretch horizontally and vertically separately for MathML

diff --git a/layout/mathml/nsIMathMLFrame.h b/layout/mathml/nsIMathMLFrame.h
--- a/layout/mathml/nsIMathMLFrame.h
+++ b/layout/mathml/nsIMathMLFrame.h
@@ -67,16 +67,21 @@ public:
   * Called to ask a stretchy MathML frame to stretch itself depending
   * on its context.
   *
   * An embellished frame is treated in a special way. When it receives a
   * Stretch() command, it passes the command to its embellished child and
   * the stretched size is bubbled up from the inner-most <mo> frame. In other
   * words, the stretch command descend through the embellished hierarchy.
   *
+  * Stretch is called twice per frame.  Once for horizontal stretching with
+  * aStretchDirection set to NS_STRETCH_DIRECTION_HORIZONTAL and once for
+  * vertical stretching with aStretchDirection set to
+  * NS_STRETCH_DIRECTION_VERTICAL.  The stretch calls must happen in this order.
+  *
   * @param aStretchDirection [in] the direction where to attempt to
   *        stretch.
   * @param aContainerSize [in] struct that suggests the maximumn size for
   *        the stretched frame. Only member data of the struct that are 
   *        relevant to the direction are used (the rest is ignored). 
   * @param aDesiredStretchSize [in/out] On input the current size
   *        of the frame, on output the size after stretching.
   */
@@ -286,18 +291,19 @@ struct nsPresentationData {
 // This bit is set if the frame is "space-like", as defined by the spec.
 #define NS_MATHML_SPACE_LIKE                          0x00000040U
 
 // This bit is set when the frame cannot be formatted due to an
 // error (e.g., invalid markup such as a <msup> without an overscript).
 // When set, a visual feedback will be provided to the user.
 #define NS_MATHML_ERROR                               0x80000000U
 
-// a bit used for debug
-#define NS_MATHML_STRETCH_DONE                        0x20000000U
+// bits used for debug
+#define NS_MATHML_STRETCH_HORIZONTAL_DONE             0x20000000U
+#define NS_MATHML_STRETCH_VERTICAL_DONE               0x40000000U
 
 // This bit is used for visual debug. When set, the bounding box
 // of your frame is painted. This visual debug enable to ensure that
 // you have properly filled your mReference and mBoundingMetrics in
 // Place().
 #define NS_MATHML_SHOW_BOUNDING_METRICS               0x10000000U
 
 // Macros that retrieve those bits
@@ -312,18 +318,21 @@ struct nsPresentationData {
   (NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY == ((_flags) & NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY))
 
 #define NS_MATHML_IS_SPACE_LIKE(_flags) \
   (NS_MATHML_SPACE_LIKE == ((_flags) & NS_MATHML_SPACE_LIKE))
 
 #define NS_MATHML_HAS_ERROR(_flags) \
   (NS_MATHML_ERROR == ((_flags) & NS_MATHML_ERROR))
 
-#define NS_MATHML_STRETCH_WAS_DONE(_flags) \
-  (NS_MATHML_STRETCH_DONE == ((_flags) & NS_MATHML_STRETCH_DONE))
+#define NS_MATHML_STRETCH_HORIZONTAL_WAS_DONE(_flags) \
+  (NS_MATHML_STRETCH_HORIZONTAL_DONE == ((_flags) & NS_MATHML_STRETCH_HORIZONTAL_DONE))
+
+#define NS_MATHML_STRETCH_VERTICAL_WAS_DONE(_flags) \
+  (NS_MATHML_STRETCH_VERTICAL_DONE == ((_flags) & NS_MATHML_STRETCH_VERTICAL_DONE))
 
 #define NS_MATHML_PAINT_BOUNDING_METRICS(_flags) \
   (NS_MATHML_SHOW_BOUNDING_METRICS == ((_flags) & NS_MATHML_SHOW_BOUNDING_METRICS))
 
 // ==========================================================================
 // Bits used for the embellish flags -- these bits are set
 // in their relevant situation as they become available
 
diff --git a/layout/mathml/nsMathMLContainerFrame.cpp b/layout/mathml/nsMathMLContainerFrame.cpp
--- a/layout/mathml/nsMathMLContainerFrame.cpp
+++ b/layout/mathml/nsMathMLContainerFrame.cpp
@@ -176,128 +176,180 @@ nsMathMLContainerFrame::ClearSavedChildM
   nsIFrame* childFrame = mFrames.FirstChild();
   FramePropertyTable* props = PresContext()->PropertyTable();
   while (childFrame) {
     props->Delete(childFrame, HTMLReflowMetricsProperty());
     childFrame = childFrame->GetNextSibling();
   }
 }
 
+static nsIFrame*
+OutermostHorizontallyStretchedFrame(nsIFrame* aFrame)
+{
+  nsEmbellishData embData;
+  nsPresentationData presData;
+  nsIFrame* frame = aFrame;
+  nsIMathMLFrame* mathFrame = do_QueryFrame(frame);
+  while (mathFrame) {
+    mathFrame->GetEmbellishData(embData);
+    if (frame == embData.coreFrame) {
+      return frame;
+    }
+    mathFrame->GetPresentationData(presData);
+    if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(presData.flags)) {
+      return frame;
+    }
+    frame = presData.baseFrame;
+    mathFrame = do_QueryFrame(frame);
+  }
+  return frame;
+}
+
 // helper to get the preferred size that a container frame should use to fire
 // the stretch on its stretchy child frames.
+// This function is meant to be called twice, once each for horizontal and
+// vertical directions.
+// In the case of a vertical stretch, horizontal related metrics (leftbearing,
+// rightbearing, width) are not guaranteed to be accurate, likewise with
+// horizontal stretches and vertical metrics.  To get the complete complete
+// stretch size, you will need to call this function twice.
 void
 nsMathMLContainerFrame::GetPreferredStretchSize(nsRenderingContext& aRenderingContext,
                                                 uint32_t             aOptions,
                                                 nsStretchDirection   aStretchDirection,
                                                 nsBoundingMetrics&   aPreferredStretchSize)
 {
   if (aOptions & STRETCH_CONSIDER_ACTUAL_SIZE) {
     // when our actual size is ok, just use it
     aPreferredStretchSize = mBoundingMetrics;
   }
   else if (aOptions & STRETCH_CONSIDER_EMBELLISHMENTS) {
     // compute our up-to-date size using Place()
     nsHTMLReflowMetrics metrics(GetWritingMode()); // ???
     Place(aRenderingContext, false, metrics);
     aPreferredStretchSize = metrics.mBoundingMetrics;
-  }
-  else {
-    // compute a size that doesn't include embellishements
-    bool stretchAll =
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||
-      NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
-    NS_ASSERTION(NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) ||
-                 stretchAll,
-                 "invalid call to GetPreferredStretchSize");
+  } else if (!NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags) &&
+             !NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) &&
+             !NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {
+    // we don't stretch
+    aPreferredStretchSize = mBoundingMetrics;
+  } else if (mEmbellishData.coreFrame == this) {
+    // A single <mo> by itself.
+    aPreferredStretchSize = mBoundingMetrics;
+  } else {
+    // compute a size that doesn't include vertical embellishements, but includes horizontal
+    // embellishments.
     bool firstTime = true;
-    nsBoundingMetrics bm, bmChild;
+    nsBoundingMetrics bm, bmChild, bmChildHoriz;
+    bool stretchAll = (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags) &&
+                       aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) ||
+                      (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) &&
+                       aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL);
     nsIFrame* childFrame =
       stretchAll ? GetFirstPrincipalChild() : mPresentationData.baseFrame;
     while (childFrame) {
       // initializations in case this child happens not to be a MathML frame
       nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);
+      nsIFrame* baseFrameHoriz = nullptr;
       if (mathMLFrame) {
         nsEmbellishData embellishData;
         nsPresentationData presentationData;
         mathMLFrame->GetEmbellishData(embellishData);
         mathMLFrame->GetPresentationData(presentationData);
         if (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags) &&
             embellishData.direction == aStretchDirection &&
             presentationData.baseFrame) {
-          // embellishements are not included, only consider the inner first child itself
-          // XXXkt Does that mean the core descendent frame should be used
-          // instead of the base child?
-          nsIMathMLFrame* mathMLchildFrame = do_QueryFrame(presentationData.baseFrame);
+          nsIFrame* baseFrame = embellishData.coreFrame;
+          nsIMathMLFrame* mathMLchildFrame = do_QueryFrame(baseFrame);
           if (mathMLchildFrame) {
             mathMLFrame = mathMLchildFrame;
           }
         }
         mathMLFrame->GetBoundingMetrics(bmChild);
+        if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
+          // Adopt horizontal embellishments only.
+          baseFrameHoriz = OutermostHorizontallyStretchedFrame(childFrame);
+          nsIMathMLFrame* horizChild = do_QueryFrame(baseFrameHoriz);
+          if (horizChild) {
+            horizChild->GetBoundingMetrics(bmChildHoriz);
+            bmChild.leftBearing = bmChildHoriz.leftBearing;
+            bmChild.rightBearing = bmChildHoriz.rightBearing;
+            bmChild.width = bmChildHoriz.width;
+          }
+        }
       }
       else {
         nsHTMLReflowMetrics unused(GetWritingMode());
         GetReflowAndBoundingMetricsFor(childFrame, unused, bmChild);
       }
 
       if (firstTime) {
         firstTime = false;
         bm = bmChild;
         if (!stretchAll) {
           // we may get here for cases such as <msup><mo>...</mo> ... </msup>,
           // or <maction>...<mo>...</mo></maction>.
           break;
         }
       }
       else {
-        if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags)) {
-          // if we get here, it means this is container that will stack its children
-          // vertically and fire an horizontal stretch on each them. This is the case
-          // for \munder, \mover, \munderover. We just sum-up the size vertically.
-          bm.descent += bmChild.ascent + bmChild.descent;
+        if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
           // Sometimes non-spacing marks (when width is zero) are positioned
           // to the left of the origin, but it is the distance between left
           // and right bearing that is important rather than the offsets from
           // the origin.
           if (bmChild.width == 0) {
             bmChild.rightBearing -= bmChild.leftBearing;
             bmChild.leftBearing = 0;
           }
           if (bm.leftBearing > bmChild.leftBearing)
             bm.leftBearing = bmChild.leftBearing;
           if (bm.rightBearing < bmChild.rightBearing)
             bm.rightBearing = bmChild.rightBearing;
         }
-        else if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags)) {
+        if (aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) {
           // just sum-up the sizes horizontally.
-          bm += bmChild;
-        }
-        else {
-          NS_ERROR("unexpected case in GetPreferredStretchSize");
-          break;
+          if (bm.ascent < bmChild.ascent) {
+            bm.ascent = bmChild.ascent;
+          }
+          if (bm.descent < bmChild.descent) {
+            bm.descent = bmChild.descent;
+          }
         }
       }
       childFrame = childFrame->GetNextSibling();
     }
     aPreferredStretchSize = bm;
   }
 }
 
 NS_IMETHODIMP
 nsMathMLContainerFrame::Stretch(nsRenderingContext& aRenderingContext,
                                 nsStretchDirection   aStretchDirection,
                                 nsBoundingMetrics&   aContainerSize,
                                 nsHTMLReflowMetrics& aDesiredStretchSize)
 {
   if (NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags)) {
 
-    if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {
-      NS_WARNING("it is wrong to fire stretch more than once on a frame");
+    if (NS_MATHML_STRETCH_VERTICAL_WAS_DONE(mPresentationData.flags)) {
+      NS_WARNING("it is wrong to call Stretch after finishing a stretch on a given frame");
       return NS_OK;
     }
-    mPresentationData.flags |= NS_MATHML_STRETCH_DONE;
+
+    if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
+      NS_ASSERTION(!NS_MATHML_STRETCH_HORIZONTAL_WAS_DONE(mPresentationData.flags),
+                   "Don't call a horizontal stretch more than once on a frame");
+      mPresentationData.flags |= NS_MATHML_STRETCH_HORIZONTAL_DONE;
+    } else if (aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) {
+      NS_ASSERTION(NS_MATHML_STRETCH_HORIZONTAL_WAS_DONE(mPresentationData.flags),
+                   "Don't stretch vertically before stretching horizontally");
+      mPresentationData.flags |= NS_MATHML_STRETCH_VERTICAL_DONE;
+    } else {
+      NS_ERROR("Only horizontal and vertical stretching is supported");
+    }
 
     if (NS_MATHML_HAS_ERROR(mPresentationData.flags)) {
       NS_WARNING("it is wrong to fire stretch on a erroneous frame");
       return NS_OK;
     }
 
     // Pass the stretch to the base child ...
 
@@ -309,81 +361,69 @@ nsMathMLContainerFrame::Stretch(nsRender
         bool stretchAll =
           NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ||
           NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
 
         // And the trick is that the child's rect.x is still holding the descent,
         // and rect.y is still holding the ascent ...
         nsHTMLReflowMetrics childSize(aDesiredStretchSize);
         GetReflowAndBoundingMetricsFor(baseFrame, childSize, childSize.mBoundingMetrics);
+        nsBoundingMetrics containerSize = aContainerSize;
 
-        // See if we should downsize and confine the stretch to us...
-        // XXX there may be other cases where we can downsize the stretch,
+        // XXX there may be cases where we can downsize the stretch,
         // e.g., the first &Sum; might appear big in the following situation
         // <math xmlns='http://www.w3.org/1998/Math/MathML'>
         //   <mstyle>
         //     <msub>
         //        <msub><mo>&Sum;</mo><mfrac><mi>a</mi><mi>b</mi></mfrac></msub>
         //        <msub><mo>&Sum;</mo><mfrac><mi>a</mi><mi>b</mi></mfrac></msub>
         //      </msub>
         //   </mstyle>
         // </math>
-        nsBoundingMetrics containerSize = aContainerSize;
-        if (aStretchDirection != NS_STRETCH_DIRECTION_DEFAULT &&
-            aStretchDirection != mEmbellishData.direction) {
-          if (mEmbellishData.direction == NS_STRETCH_DIRECTION_UNSUPPORTED) {
-            containerSize = childSize.mBoundingMetrics;
-          }
-          else {
-            GetPreferredStretchSize(aRenderingContext, 
-                                    stretchAll ? STRETCH_CONSIDER_EMBELLISHMENTS : 0,
-                                    mEmbellishData.direction, containerSize);
-          }
-        }
 
         // do the stretching...
-        mathMLFrame->Stretch(aRenderingContext,
-                             mEmbellishData.direction, containerSize, childSize);
+        mathMLFrame->Stretch(aRenderingContext, aStretchDirection,
+                             containerSize, childSize);
         // store the updated metrics
         SaveReflowAndBoundingMetricsFor(baseFrame, childSize,
                                         childSize.mBoundingMetrics);
         
         // Remember the siblings which were _deferred_.
         // Now that this embellished child may have changed, we need to
         // fire the stretch on its siblings using our updated size
 
         if (stretchAll) {
 
-          nsStretchDirection stretchDir =
-            NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) ?
-              NS_STRETCH_DIRECTION_VERTICAL : NS_STRETCH_DIRECTION_HORIZONTAL;
-
           GetPreferredStretchSize(aRenderingContext, STRETCH_CONSIDER_EMBELLISHMENTS,
-                                  stretchDir, containerSize);
+                                  aStretchDirection, containerSize);
 
           nsIFrame* childFrame = mFrames.FirstChild();
           while (childFrame) {
             if (childFrame != mPresentationData.baseFrame) {
               mathMLFrame = do_QueryFrame(childFrame);
               if (mathMLFrame) {
                 // retrieve the metrics that was stored at the previous pass
                 GetReflowAndBoundingMetricsFor(childFrame, 
                   childSize, childSize.mBoundingMetrics);
                 // do the stretching...
-                mathMLFrame->Stretch(aRenderingContext, stretchDir,
+                mathMLFrame->Stretch(aRenderingContext, aStretchDirection,
                                      containerSize, childSize);
                 // store the updated metrics
                 SaveReflowAndBoundingMetricsFor(childFrame, childSize,
                                                 childSize.mBoundingMetrics);
               }
             }
             childFrame = childFrame->GetNextSibling();
           }
         }
 
+        if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
+          return NS_OK;
+        }
+
         // re-position all our children
         nsresult rv = Place(aRenderingContext, true, aDesiredStretchSize);
         if (NS_MATHML_HAS_ERROR(mPresentationData.flags) || NS_FAILED(rv)) {
           // Make sure the child frames get their DidReflow() calls.
           DidReflowChildren(mFrames.FirstChild());
         }
 
         // If our parent is not embellished, it means we are the outermost embellished
@@ -470,53 +510,47 @@ nsMathMLContainerFrame::FinalizeReflow(n
   // If placeOrigin is false we should reach Place() with aPlaceOrigin == true
   // through Stretch() eventually.
   if (NS_MATHML_HAS_ERROR(mPresentationData.flags) || NS_FAILED(rv)) {
     DidReflowChildren(GetFirstPrincipalChild());
     return rv;
   }
 
   bool parentWillFireStretch = false;
+  // Don't go without checking to see if our parent will later fire a Stretch() command
+  // targeted at us. The Stretch() will cause the rect.x and rect.y to clear...
+  nsIMathMLFrame* mathMLFrame = do_QueryFrame(GetParent());
+  if (mathMLFrame) {
+    nsEmbellishData embellishData;
+    nsPresentationData presentationData;
+    mathMLFrame->GetEmbellishData(embellishData);
+    mathMLFrame->GetPresentationData(presentationData);
+    if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(presentationData.flags) ||
+        NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(presentationData.flags) ||
+        (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags)
+          && presentationData.baseFrame == this))
+    {
+      parentWillFireStretch = true;
+    }
+  }
   if (!placeOrigin) {
     // This means the rect.x and rect.y of our children were not set!!
-    // Don't go without checking to see if our parent will later fire a Stretch() command
-    // targeted at us. The Stretch() will cause the rect.x and rect.y to clear...
-    nsIMathMLFrame* mathMLFrame = do_QueryFrame(GetParent());
-    if (mathMLFrame) {
-      nsEmbellishData embellishData;
-      nsPresentationData presentationData;
-      mathMLFrame->GetEmbellishData(embellishData);
-      mathMLFrame->GetPresentationData(presentationData);
-      if (NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(presentationData.flags) ||
-          NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(presentationData.flags) ||
-          (NS_MATHML_IS_EMBELLISH_OPERATOR(embellishData.flags)
-            && presentationData.baseFrame == this))
-      {
-        parentWillFireStretch = true;
-      }
-    }
     if (!parentWillFireStretch) {
       // There is nobody who will fire the stretch for us, we do it ourselves!
 
-      bool stretchAll =
-        /* NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) || */
-        NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY(mPresentationData.flags);
-
       nsBoundingMetrics defaultSize;
-      if (mEmbellishData.coreFrame == this /* case of a bare <mo>...</mo> itself */
-          || stretchAll) { /* or <mover><mo>...</mo>...</mover>, or friends */
-        // use our current size as computed earlier by Place()
-        defaultSize = aDesiredSize.mBoundingMetrics;
-      }
-      else { /* case of <msup><mo>...</mo>...</msup> or friends */
-        // compute a size that doesn't include embellishments
-        GetPreferredStretchSize(aRenderingContext, 0, mEmbellishData.direction,
-                                defaultSize);
-      }
-      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_DEFAULT, defaultSize,
+      // Horizontal Stretch
+      GetPreferredStretchSize(aRenderingContext, 0,
+                              NS_STRETCH_DIRECTION_HORIZONTAL, defaultSize);
+      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_HORIZONTAL, defaultSize,
+              aDesiredSize);
+      // Vertical Stretch
+      GetPreferredStretchSize(aRenderingContext, 0,
+                              NS_STRETCH_DIRECTION_VERTICAL, defaultSize);
+      Stretch(aRenderingContext, NS_STRETCH_DIRECTION_VERTICAL, defaultSize,
               aDesiredSize);
 #ifdef DEBUG
       {
         // The Place() call above didn't request FinishReflowChild(),
         // so let's check that we eventually did through Stretch().
         nsIFrame* childFrame = GetFirstPrincipalChild();
         for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
           NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_IN_REFLOW),
@@ -923,32 +957,55 @@ nsMathMLContainerFrame::Reflow(nsPresCon
       NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY(mPresentationData.flags) 
       ? NS_STRETCH_DIRECTION_VERTICAL 
       : NS_STRETCH_DIRECTION_HORIZONTAL;
 
     // what size should we use to stretch our stretchy children
     // We don't use STRETCH_CONSIDER_ACTUAL_SIZE -- because our size is not known yet
     // We don't use STRETCH_CONSIDER_EMBELLISHMENTS -- because we don't want to
     // include them in the caculations of the size of stretchy elements
-    nsBoundingMetrics containerSize;
-    GetPreferredStretchSize(*aReflowState.rendContext, 0, stretchDir,
-                            containerSize);
+    nsBoundingMetrics containerSize, childContainerSize;
+
+    GetPreferredStretchSize(*aReflowState.rendContext, 0,
+                            stretchDir, containerSize);
+
 
     // fire the stretch on each child
     childFrame = mFrames.FirstChild();
     while (childFrame) {
-      nsIMathMLFrame* mathMLFrame = do_QueryFrame(childFrame);
+      nsMathMLContainerFrame* mathMLFrame = do_QueryFrame(childFrame);
       if (mathMLFrame) {
         // retrieve the metrics that was stored at the previous pass
         nsHTMLReflowMetrics childDesiredSize(aReflowState);
         GetReflowAndBoundingMetricsFor(childFrame,
           childDesiredSize, childDesiredSize.mBoundingMetrics);
 
-        mathMLFrame->Stretch(*aReflowState.rendContext, stretchDir,
-                             containerSize, childDesiredSize);
+        // Consider horizontal and vertical stretches separately.  If the,
+        // stretch direction matches us, use our metrics for that direction,
+        // otherwise use the child's.
+        if (stretchDir == NS_STRETCH_DIRECTION_HORIZONTAL) {
+          childContainerSize = containerSize;
+        } else {
+          mathMLFrame->GetPreferredStretchSize(*aReflowState.rendContext, 0,
+                                               NS_STRETCH_DIRECTION_HORIZONTAL,
+                                               childContainerSize);
+        }
+        mathMLFrame->Stretch(*aReflowState.rendContext,
+                             NS_STRETCH_DIRECTION_HORIZONTAL, childContainerSize,
+                             childDesiredSize);
+        if (stretchDir == NS_STRETCH_DIRECTION_VERTICAL) {
+          childContainerSize = containerSize;
+        } else {
+          mathMLFrame->GetPreferredStretchSize(*aReflowState.rendContext, 0,
+                                               NS_STRETCH_DIRECTION_VERTICAL,
+                                               childContainerSize);
+        }
+        mathMLFrame->Stretch(*aReflowState.rendContext,
+                             NS_STRETCH_DIRECTION_VERTICAL, childContainerSize,
+                             childDesiredSize);
         // store the updated metrics
         SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                         childDesiredSize.mBoundingMetrics);
       }
       childFrame = childFrame->GetNextSibling();
     }
   }
 
diff --git a/layout/mathml/nsMathMLContainerFrame.h b/layout/mathml/nsMathMLContainerFrame.h
--- a/layout/mathml/nsMathMLContainerFrame.h
+++ b/layout/mathml/nsMathMLContainerFrame.h
@@ -119,17 +119,18 @@ public:
     nsContainerFrame::WillReflow(aPresContext);
   }
 
   virtual void DidReflow(nsPresContext*           aPresContext,
             const nsHTMLReflowState*  aReflowState,
             nsDidReflowStatus         aStatus) MOZ_OVERRIDE
 
   {
-    mPresentationData.flags &= ~NS_MATHML_STRETCH_DONE;
+    mPresentationData.flags &= ~(NS_MATHML_STRETCH_VERTICAL_DONE |
+                                 NS_MATHML_STRETCH_HORIZONTAL_DONE);
     return nsContainerFrame::DidReflow(aPresContext, aReflowState, aStatus);
   }
 
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
 
   virtual bool UpdateOverflow() MOZ_OVERRIDE;
diff --git a/layout/mathml/nsMathMLmfencedFrame.cpp b/layout/mathml/nsMathMLmfencedFrame.cpp
--- a/layout/mathml/nsMathMLmfencedFrame.cpp
+++ b/layout/mathml/nsMathMLmfencedFrame.cpp
@@ -248,33 +248,43 @@ nsMathMLmfencedFrame::Reflow(nsPresConte
       ascent = childDesiredSize.TopAscent();
 
     childFrame = childFrame->GetNextSibling();
   }
 
   /////////////
   // Ask stretchy children to stretch themselves
 
-  nsBoundingMetrics containerSize;
+  nsBoundingMetrics containerSize, childContainerSize;
   nsStretchDirection stretchDir = NS_STRETCH_DIRECTION_VERTICAL;
 
   GetPreferredStretchSize(*aReflowState.rendContext,
                           0, /* i.e., without embellishments */
                           stretchDir, containerSize);
   childFrame = firstChild;
   while (childFrame) {
-    nsIMathMLFrame* mathmlChild = do_QueryFrame(childFrame);
+    nsMathMLContainerFrame* mathmlChild = do_QueryFrame(childFrame);
     if (mathmlChild) {
       nsHTMLReflowMetrics childDesiredSize(aReflowState);
       // retrieve the metrics that was stored at the previous pass
       GetReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                      childDesiredSize.mBoundingMetrics);
-      
-      mathmlChild->Stretch(*aReflowState.rendContext, 
-                           stretchDir, containerSize, childDesiredSize);
+
+      // Use the child's metrics for any horizontal stretching needed
+      mathmlChild->GetPreferredStretchSize(*aReflowState.rendContext, 0,
+                                           NS_STRETCH_DIRECTION_HORIZONTAL,
+                                           childContainerSize);
+      mathmlChild->Stretch(*aReflowState.rendContext,
+                           NS_STRETCH_DIRECTION_HORIZONTAL,
+                           childContainerSize, childDesiredSize);
+      // and the parent mfenced frame's metrics for vertical stretching.
+      mathmlChild->Stretch(*aReflowState.rendContext,
+                           NS_STRETCH_DIRECTION_VERTICAL,
+                           containerSize, childDesiredSize);
+
       // store the updated metrics
       SaveReflowAndBoundingMetricsFor(childFrame, childDesiredSize,
                                       childDesiredSize.mBoundingMetrics);
       
       nscoord childDescent = childDesiredSize.Height() - childDesiredSize.TopAscent();
       if (descent < childDescent)
         descent = childDescent;
       if (ascent < childDesiredSize.TopAscent())
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -595,21 +595,40 @@ GetStretchHint(nsOperatorFlags aFlags, n
 //       On input  - it contains our current size
 //       On output - the same size or the new size that we want
 NS_IMETHODIMP
 nsMathMLmoFrame::Stretch(nsRenderingContext& aRenderingContext,
                          nsStretchDirection   aStretchDirection,
                          nsBoundingMetrics&   aContainerSize,
                          nsHTMLReflowMetrics& aDesiredStretchSize)
 {
-  if (NS_MATHML_STRETCH_WAS_DONE(mPresentationData.flags)) {
-    NS_WARNING("it is wrong to fire stretch more than once on a frame");
+
+  if (NS_MATHML_STRETCH_VERTICAL_WAS_DONE(mPresentationData.flags)) {
+    NS_WARNING("it is wrong to call Stretch after finishing a stretch on a given frame");
     return NS_OK;
   }
-  mPresentationData.flags |= NS_MATHML_STRETCH_DONE;
+
+  if (aStretchDirection == NS_STRETCH_DIRECTION_HORIZONTAL) {
+    NS_ASSERTION(!NS_MATHML_STRETCH_HORIZONTAL_WAS_DONE(mPresentationData.flags),
+                 "Don't call a horizontal stretch more than once on a frame");
+    // Store for later
+    mStretchMetrics = aContainerSize;
+    mPresentationData.flags |= NS_MATHML_STRETCH_HORIZONTAL_DONE;
+    return NS_OK;
+  } else if (aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) {
+    NS_ASSERTION(NS_MATHML_STRETCH_HORIZONTAL_WAS_DONE(mPresentationData.flags),
+                 "Don't stretch vertically before stretching horizontally");
+    // Restore saved horizontal metrics
+    aContainerSize.leftBearing = mStretchMetrics.leftBearing;
+    aContainerSize.rightBearing = mStretchMetrics.rightBearing;
+    aContainerSize.width = mStretchMetrics.width;
+  } else {
+    NS_ERROR("Only horizontal and vertical stretching is supported");
+  }
+
 
   nsIFrame* firstChild = mFrames.FirstChild();
 
   // get the axis height;
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
   nscoord axisHeight, height;
@@ -623,23 +642,17 @@ nsMathMLmoFrame::Stretch(nsRenderingCont
 
   // Operators that are stretchy, or those that are to be centered
   // to cater for fonts that are not math-aware, are handled by the MathMLChar
   // ('form' is reset if stretch fails -- i.e., we don't bother to stretch next time)
   bool useMathMLChar = UseMathMLChar();
 
   nsBoundingMetrics charSize;
   nsBoundingMetrics container = aDesiredStretchSize.mBoundingMetrics;
-  bool isVertical = false;
-
-  if (((aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) ||
-       (aStretchDirection == NS_STRETCH_DIRECTION_DEFAULT))  &&
-      (mEmbellishData.direction == NS_STRETCH_DIRECTION_VERTICAL)) {
-    isVertical = true;
-  }
+  bool isVertical = mEmbellishData.direction == NS_STRETCH_DIRECTION_VERTICAL;
 
   uint32_t stretchHint =
     GetStretchHint(mFlags, mPresentationData, isVertical, StyleFont());
 
   if (useMathMLChar) {
     nsBoundingMetrics initialSize = aDesiredStretchSize.mBoundingMetrics;
 
     if (stretchHint != NS_STRETCH_NONE) {
@@ -694,25 +707,16 @@ nsMathMLmoFrame::Stretch(nsRenderingCont
           height = container.ascent + container.descent;
           container.descent = aContainerSize.descent;
           container.ascent = height - container.descent;
         }
       }
 
       if (mMinSize > 0.0f) {
         // if we are here, there is a user defined minsize ...
-        // always allow the char to stretch in its natural direction,
-        // even if it is different from the caller's direction 
-        if (aStretchDirection != NS_STRETCH_DIRECTION_DEFAULT &&
-            aStretchDirection != mEmbellishData.direction) {
-          aStretchDirection = NS_STRETCH_DIRECTION_DEFAULT;
-          // but when we are not honoring the requested direction
-          // we should not use the caller's container size either
-          container = initialSize;
-        }
         if (NS_MATHML_OPERATOR_MINSIZE_IS_ABSOLUTE(mFlags)) {
           // there is an explicit value like minsize="20pt"
           // try to maintain the aspect ratio of the char
           float aspect = mMinSize / float(initialSize.ascent + initialSize.descent);
           container.ascent =
             std::max(container.ascent, nscoord(initialSize.ascent * aspect));
           container.descent =
             std::max(container.descent, nscoord(initialSize.descent * aspect));
@@ -734,17 +738,18 @@ nsMathMLmoFrame::Stretch(nsRenderingCont
           container.descent = aContainerSize.descent;
           container.ascent = height - container.descent;
         }
       }
     }
 
     // let the MathMLChar stretch itself...
     nsresult res = mMathMLChar.Stretch(PresContext(), aRenderingContext,
-                                       aStretchDirection, container, charSize,
+                                       NS_STRETCH_DIRECTION_DEFAULT,
+                                       container, charSize,
                                        stretchHint,
                                        StyleVisibility()->mDirection);
     if (NS_FAILED(res)) {
       // gracefully handle cases where stretching the char failed (i.e., GetBoundingMetrics failed)
       // clear our 'form' to behave as if the operator wasn't in the dictionary
       mFlags &= ~NS_MATHML_OPERATOR_FORM;
       useMathMLChar = false;
     }
diff --git a/layout/mathml/nsMathMLmoFrame.h b/layout/mathml/nsMathMLmoFrame.h
--- a/layout/mathml/nsMathMLmoFrame.h
+++ b/layout/mathml/nsMathMLmoFrame.h
@@ -92,11 +92,14 @@ protected:
   // our default data that may come from there, and to complete the setup
   // using attributes that we may have
   void
   ProcessOperatorData();
 
   // helper to double check thar our char should be rendered as a selected char
   bool
   IsFrameInSelection(nsIFrame* aFrame);
+
+private:
+  nsBoundingMetrics mStretchMetrics;
 };
 
 #endif /* nsMathMLmoFrame_h___ */
