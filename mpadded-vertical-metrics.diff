# HG changeset patch
# Parent 5403938d417cb2058bcf6317475e2a9f83776228
# User Frédéric Wang <fred.wang@free.fr>
Bug 685628 - mpadded: height/depth should apply to logical metrics. r=karlt

diff --git a/layout/mathml/nsMathMLmpaddedFrame.cpp b/layout/mathml/nsMathMLmpaddedFrame.cpp
--- a/layout/mathml/nsMathMLmpaddedFrame.cpp
+++ b/layout/mathml/nsMathMLmpaddedFrame.cpp
@@ -297,38 +297,39 @@ nsMathMLmpaddedFrame::ParseAttribute(nsS
           NS_LossyConvertUTF16toASCII(aString).get());
 #endif
   // if we reach here, it means we encounter an unexpected input
   aSign = NS_MATHML_SIGN_INVALID;
   return false;
 }
 
 void
-nsMathMLmpaddedFrame::UpdateValue(PRInt32                  aSign,
-                                  PRInt32                  aPseudoUnit,
-                                  const nsCSSValue&        aCSSValue,
-                                  const nsBoundingMetrics& aBoundingMetrics,
-                                  nscoord&                 aValueToUpdate) const
+nsMathMLmpaddedFrame::UpdateValue(PRInt32                    aSign,
+                                  PRInt32                    aPseudoUnit,
+                                  const nsCSSValue&          aCSSValue,
+                                  const nsBoundingMetrics&   aBoundingMetrics,
+                                  const nsHTMLReflowMetrics& aDesiredSize,
+                                  nscoord&                   aValueToUpdate) const
 {
   nsCSSUnit unit = aCSSValue.GetUnit();
   if (NS_MATHML_SIGN_INVALID != aSign && eCSSUnit_Null != unit) {
     nscoord scaler = 0, amount = 0;
 
     if (eCSSUnit_Percent == unit || eCSSUnit_Number == unit) {
       switch(aPseudoUnit) {
         case NS_MATHML_PSEUDO_UNIT_WIDTH:
              scaler = aBoundingMetrics.width;
              break;
 
         case NS_MATHML_PSEUDO_UNIT_HEIGHT:
-             scaler = aBoundingMetrics.ascent;
+             scaler = aDesiredSize.ascent;
              break;
 
         case NS_MATHML_PSEUDO_UNIT_DEPTH:
-             scaler = aBoundingMetrics.descent;
+             scaler = aDesiredSize.height - aDesiredSize.ascent;
              break;
 
         default:
           // if we ever reach here, it would mean something is wrong 
           // somewhere with the setup and/or the caller
           NS_ERROR("Unexpected Pseudo Unit");
           return;
       }
@@ -373,18 +374,18 @@ nsMathMLmpaddedFrame::Place(nsRenderingC
 {
   nsresult rv =
     nsMathMLContainerFrame::Place(aRenderingContext, false, aDesiredSize);
   if (NS_MATHML_HAS_ERROR(mPresentationData.flags) || NS_FAILED(rv)) {
     DidReflowChildren(GetFirstPrincipalChild());
     return rv;
   }
 
-  nscoord height = mBoundingMetrics.ascent;
-  nscoord depth  = mBoundingMetrics.descent;
+  nscoord height = aDesiredSize.ascent;
+  nscoord depth  = aDesiredSize.height - aDesiredSize.ascent;
   // In MathML2 (http://www.w3.org/TR/MathML2/chapter3.html#presm.mpadded),
   // lspace is "the amount of space between the left edge of a bounding box
   // and the start of the rendering of its contents' bounding box" and the
   // default is zero.
   //
   // In MathML3 draft
   // http://www.w3.org/TR/2007/WD-MathML3-20070427/chapter3.html#id.3.3.6.2,
   // lspace is "the amount of space between the left edge of the bounding box
@@ -404,45 +405,45 @@ nsMathMLmpaddedFrame::Place(nsRenderingC
   nscoord voffset = 0;
 
   PRInt32 pseudoUnit;
 
   // update width
   pseudoUnit = (mWidthPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
              ? NS_MATHML_PSEUDO_UNIT_WIDTH : mWidthPseudoUnit;
   UpdateValue(mWidthSign, pseudoUnit, mWidth,
-              mBoundingMetrics, width);
+              mBoundingMetrics, aDesiredSize, width);
   width = NS_MAX(0, width);
 
   // update "height" (this is the ascent in the terminology of the REC)
   pseudoUnit = (mHeightPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
              ? NS_MATHML_PSEUDO_UNIT_HEIGHT : mHeightPseudoUnit;
   UpdateValue(mHeightSign, pseudoUnit, mHeight,
-              mBoundingMetrics, height);
+              mBoundingMetrics, aDesiredSize, height);
   height = NS_MAX(0, height);
 
   // update "depth" (this is the descent in the terminology of the REC)
   pseudoUnit = (mDepthPseudoUnit == NS_MATHML_PSEUDO_UNIT_ITSELF)
              ? NS_MATHML_PSEUDO_UNIT_DEPTH : mDepthPseudoUnit;
   UpdateValue(mDepthSign, pseudoUnit, mDepth,
-              mBoundingMetrics, depth);
+              mBoundingMetrics, aDesiredSize, depth);
   depth = NS_MAX(0, depth);
 
   // update lspace
   if (mLeftSpacePseudoUnit != NS_MATHML_PSEUDO_UNIT_ITSELF) {
     pseudoUnit = mLeftSpacePseudoUnit;
     UpdateValue(mLeftSpaceSign, pseudoUnit, mLeftSpace,
-                mBoundingMetrics, lspace);
+                mBoundingMetrics, aDesiredSize, lspace);
   }
 
   // update voffset
   if (mVerticalOffsetPseudoUnit != NS_MATHML_PSEUDO_UNIT_ITSELF) {
     pseudoUnit = mVerticalOffsetPseudoUnit;
     UpdateValue(mVerticalOffsetSign, pseudoUnit, mVerticalOffset,
-                mBoundingMetrics, voffset);
+                mBoundingMetrics, aDesiredSize, voffset);
   }
   // do the padding now that we have everything
   // The idea here is to maintain the invariant that <mpadded>...</mpadded> (i.e.,
   // with no attributes) looks the same as <mrow>...</mrow>. But when there are
   // attributes, tweak our metrics and move children to achieve the desired visual
   // effects.
 
   if (mLeftSpaceSign != NS_MATHML_SIGN_INVALID) { // there was padding on the left
@@ -451,29 +452,26 @@ nsMathMLmpaddedFrame::Place(nsRenderingC
   }
 
   if (mWidthSign != NS_MATHML_SIGN_INVALID) { // there was padding on the right
     // dismiss the right italic correction now (so that our parent won't correct us)
     mBoundingMetrics.width = width;
     mBoundingMetrics.rightBearing = mBoundingMetrics.width;
   }
 
-  nscoord dy = height - mBoundingMetrics.ascent;
-  nscoord dx = lspace;
-
-  aDesiredSize.ascent += dy;
-  aDesiredSize.width = mBoundingMetrics.width;
-  aDesiredSize.height += dy + depth - mBoundingMetrics.descent;
   mBoundingMetrics.ascent = height;
   mBoundingMetrics.descent = depth;
+
+  aDesiredSize.width = mBoundingMetrics.width;
+  aDesiredSize.ascent = height;
+  aDesiredSize.height = height + depth;
   aDesiredSize.mBoundingMetrics = mBoundingMetrics;
 
   mReference.x = 0;
   mReference.y = aDesiredSize.ascent;
 
   if (aPlaceOrigin) {
     // Finish reflowing child frames, positioning their origins.
-    PositionRowChildFrames(aDesiredSize.width, dx,
-                           aDesiredSize.ascent - voffset);
+    PositionRowChildFrames(aDesiredSize.width, lspace, height - voffset);
   }
 
   return NS_OK;
 }
diff --git a/layout/mathml/nsMathMLmpaddedFrame.h b/layout/mathml/nsMathMLmpaddedFrame.h
--- a/layout/mathml/nsMathMLmpaddedFrame.h
+++ b/layout/mathml/nsMathMLmpaddedFrame.h
@@ -104,16 +104,17 @@ private:
 
   static bool
   ParseAttribute(nsString&   aString,
                  PRInt32&    aSign,
                  nsCSSValue& aCSSValue,
                  PRInt32&    aPseudoUnit);
 
   void
-  UpdateValue(PRInt32                  aSign,
-              PRInt32                  aPseudoUnit,
-              const nsCSSValue&        aCSSValue,
-              const nsBoundingMetrics& aBoundingMetrics,
-              nscoord&                 aValueToUpdate) const;
+  UpdateValue(PRInt32                    aSign,
+              PRInt32                    aPseudoUnit,
+              const nsCSSValue&          aCSSValue,
+              const nsBoundingMetrics&   aBoundingMetrics,
+              const nsHTMLReflowMetrics& aDesiredSize,
+              nscoord&                   aValueToUpdate) const;
 };
 
 #endif /* nsMathMLmpaddedFrame_h___ */
