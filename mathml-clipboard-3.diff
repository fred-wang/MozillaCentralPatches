# HG changeset patch
# Parent 97febd653f531163496d9f01953f7c49d6402d8d
# User Frédéric Wang <fred.wang@free.fr>
Implement copy operation for MathML and TeX. b=539506, r=?

diff --git a/content/base/src/nsCopySupport.cpp b/content/base/src/nsCopySupport.cpp
--- a/content/base/src/nsCopySupport.cpp
+++ b/content/base/src/nsCopySupport.cpp
@@ -42,16 +42,17 @@
 #include "nsIImageLoadingContent.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsContentUtils.h"
 #include "nsContentCID.h"
 
 #include "mozilla/dom/Element.h"
 
 #include "mozilla/Preferences.h"
+#include "nsMimeTypes.h"
 
 using namespace mozilla;
 
 nsresult NS_NewDomSelection(nsISelection **aDomSelection);
 
 static NS_DEFINE_CID(kCClipboardCID,           NS_CLIPBOARD_CID);
 static NS_DEFINE_CID(kCTransferableCID,        NS_TRANSFERABLE_CID);
 static NS_DEFINE_CID(kHTMLConverterCID,        NS_HTMLFORMATCONVERTER_CID);
@@ -120,64 +121,152 @@ SelectionCopyHelper(nsISelection *aSel, 
   rv = docEncoder->GetContextParameters(&bIsPlainTextContext,
                                         &bIsMathMLContext);
   if (NS_FAILED(rv))
     return rv;
 
   bool bIsHTMLCopy = !bIsPlainTextContext;
 
   nsAutoString buffer, parents, info, textBuffer, plaintextBuffer;
+  nsAutoString mathmlBuffer, texBuffer;
 
   rv = docEncoder->EncodeToString(textBuffer);
   if (NS_FAILED(rv)) 
     return rv;
 
   // If the selection was in a text input, in textarea or in pre, the encoder
   // already produced plain text. Otherwise,the encoder produced HTML. In that
   // case, we need to create an additional plain text serialization and an
   // addition HTML serialization that encodes context.
+
+  // In a MathML context, we still create these HTML serializations but we also
+  // try to export the flavors described in the MathML REC at
+  // http://www.w3.org/TR/MathML/chapter6.html#world-int-transfers. More
+  // precisely, we try to adhere to the "Recommended Behaviors when
+  // Transferring" and take the following approach:
+  //
+  // - We don't distinguish between presentation and content MathML. We
+  //   always export a generic MathML flavor (APPLICATION_MATHML_XML) containing
+  //   the source code of the selected MathML fragment.
+  //
+  // - When this MathML fragment contains only a single <semantics> element we
+  //   try to export additional flavors described by this element. For
+  //   simplicity we only consider <annotation> elements and don't bother with
+  //   the annotation key. Currently we only export the TeX flavor
+  //   (APPLICATION_TEX) which seems the most important use case.
+  //
+  // - Finally, we export a plain text flavor with the MathML source code as
+  //   proposed in the MathML REC. This is not the same as the HTML case where
+  //   the plain text flavor is the concatenation of the text nodes selected
+  //   (perhaps visually formatted with spaces and indentations). This sounds
+  //   reasonable as a naive concatenation of the text nodes selected in a
+  //   formula is not really useful in general.
+  // 
   if (bIsHTMLCopy) {
 
-    // First, create the plain text serialization
-    mimeType.AssignLiteral("text/plain");
+    if (!bIsMathMLContext) {
+      // First, create the plain text serialization
+      mimeType.AssignLiteral("text/plain");
 
-    flags =
-      nsIDocumentEncoder::OutputSelectionOnly |
-      nsIDocumentEncoder::OutputAbsoluteLinks |
-      nsIDocumentEncoder::SkipInvisibleContent |
-      nsIDocumentEncoder::OutputDropInvisibleBreak |
-      (aFlags & nsIDocumentEncoder::OutputNoScriptContent);
+      flags =
+        nsIDocumentEncoder::OutputSelectionOnly |
+        nsIDocumentEncoder::OutputAbsoluteLinks |
+        nsIDocumentEncoder::SkipInvisibleContent |
+        nsIDocumentEncoder::OutputDropInvisibleBreak |
+        (aFlags & nsIDocumentEncoder::OutputNoScriptContent);
 
-    rv = docEncoder->Init(domDoc, mimeType, flags);
-    if (NS_FAILED(rv))
-      return rv;
+      rv = docEncoder->Init(domDoc, mimeType, flags);
+      if (NS_FAILED(rv))
+        return rv;
 
-    rv = docEncoder->SetSelection(aSel);
-    if (NS_FAILED(rv))
-      return rv;
+      rv = docEncoder->SetSelection(aSel);
+      if (NS_FAILED(rv))
+        return rv;
 
-    rv = docEncoder->EncodeToString(plaintextBuffer);
-    if (NS_FAILED(rv))
-      return rv;
+      rv = docEncoder->EncodeToString(plaintextBuffer);
+      if (NS_FAILED(rv))
+        return rv;
+    }
 
     // Now create the version that shows HTML context
 
     mimeType.AssignLiteral(kHTMLMime);
 
     flags = aFlags;
 
     rv = docEncoder->Init(domDoc, mimeType, flags);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = docEncoder->SetSelection(aSel);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // encode the selection as html with contextual info
     rv = docEncoder->EncodeToStringWithContext(parents, info, buffer);
     NS_ENSURE_SUCCESS(rv, rv);
+
+    if (bIsMathMLContext) {
+      // The MathML REC says:
+      //
+      // "When transferring MathML, an application MUST ensure the content of
+      // the data transfer is a well-formed XML instance of a MathML document
+      // type. Specifically: 
+      //
+      // 1) The instance MAY begin with an XML declaration
+      // 2) The instance MUST contain exactly one root math element.
+      // 3) The instance MUST declare the MathML namespace on the root math
+      // element.
+      // 4) The instance MAY use a schemaLocation attribute on the math element
+      // to indicate the location of the MathML schema that describes the MathML
+      // document type to which the instance conforms. The presence of the
+      // schemaLocation attribute does not require a consumer of the MathML
+      // instance to obtain or use the referenced schema.
+      // 5) The instance SHOULD use numeric character references (e.g. &#x03b1;)
+      // rather than character entity names (e.g. &alpha;) for greater
+      // interoperability.
+      // 6) The instance MUST specify the character encoding, if it uses an
+      // encoding other than UTF-8, either in the XML declaration, or by the
+      // use of a byte-order mark (BOM) for UTF-16-encoded data."
+      //
+      // See http://www.w3.org/TR/MathML/chapter6.html#world-int-transf-flavors
+      //
+      // 1) is optional but the examples in the REC use this XML declaration
+      // for the presentation MathML flavor while the REC recommends not to use
+      // it for the plain text flavor:
+      //
+      // "Since some older MathML processors expect MathML instances
+      // transferred as plain text to begin with a math element, the text
+      // version SHOULD generally omit the XML declaration"
+      //
+      // We will follow 2), 3) and ignore the optional 4). ConvertAndWrite in
+      // nsDocumentEncoder.cpp tries to generate either a unicode code point
+      // or a numeric character reference 5) holds too. Regarding 6), we use
+      // a BOM character and an explicit encoding="UTF-16".
+      //
+      plaintextBuffer.
+        AssignLiteral("<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n");
+      plaintextBuffer.Append(buffer);
+      plaintextBuffer.AppendLiteral("\n</math>");
+
+      PRUnichar bom = 0xFEFF;
+      mathmlBuffer.Assign(bom);
+      mathmlBuffer.
+        AppendLiteral("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\n");
+      mathmlBuffer.Append(plaintextBuffer);
+
+      rv = docEncoder->Init(domDoc, mimeType, flags);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = docEncoder->SetSelection(aSel);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = docEncoder->
+        EncodeMathMLAnnotationToString(NS_LITERAL_STRING(APPLICATION_TEX),
+                                       texBuffer);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
   }
   
   // Get the Clipboard
   nsCOMPtr<nsIClipboard> clipboard;
   if (doPutOnClipboard) {
     clipboard = do_GetService(kCClipboardCID, &rv);
     if (NS_FAILED(rv))
       return rv;
@@ -190,16 +279,29 @@ SelectionCopyHelper(nsISelection *aSel, 
       trans->Init(aDoc->GetLoadContext());
       if (bIsHTMLCopy) {
         // Set up a format converter so that clipboard flavor queries work.
         // This converter isn't really used for conversions.
         nsCOMPtr<nsIFormatConverter> htmlConverter =
           do_CreateInstance(kHTMLConverterCID);
         trans->SetConverter(htmlConverter);
 
+        if (bIsMathMLContext) {
+          if (!mathmlBuffer.IsEmpty()) {
+            // Add the MathML DataFlavor to the transferable
+            rv = AppendString(trans, mathmlBuffer, APPLICATION_MATHML_XML);
+            NS_ENSURE_SUCCESS(rv, rv);
+          }
+
+          if (!texBuffer.IsEmpty()) {
+            // Add the TeX DataFlavor to the transferable
+            rv = AppendString(trans, texBuffer, APPLICATION_TEX);
+          }
+        }
+
         if (!buffer.IsEmpty()) {
           // Add the html DataFlavor to the transferable
           rv = AppendString(trans, buffer, kHTMLMime);
           NS_ENSURE_SUCCESS(rv, rv);
         }
 
         // Add the htmlcontext DataFlavor to the transferable
         // Even if parents is empty string, this flavor should
diff --git a/content/base/src/nsDocumentEncoder.cpp b/content/base/src/nsDocumentEncoder.cpp
--- a/content/base/src/nsDocumentEncoder.cpp
+++ b/content/base/src/nsDocumentEncoder.cpp
@@ -1081,17 +1081,20 @@ nsDocumentEncoder::EncodeToString(nsAStr
       if (node != prevNode) {
         nsCOMPtr<nsINode> p;
         if (prevNode) {
           p = do_QueryInterface(prevNode);
           rv = SerializeNodeEnd(p, output);
           NS_ENSURE_SUCCESS(rv, rv);
         }
         nsCOMPtr<nsIContent> content = do_QueryInterface(node);
-        if (content && content->IsHTML(nsGkAtoms::tr)) {
+        if (content &&
+            (content->IsHTML(nsGkAtoms::tr) ||
+             content->IsMathML(nsGkAtoms::mtr_) ||
+             content->IsMathML(nsGkAtoms::mlabeledtr_))) {
           nsINode* n = content;
           if (!prevNode) {
             // Went from a non-<tr> to a <tr>
             mCommonAncestors.Clear();
             nsContentUtils::GetAncestors(n->GetParentNode(), mCommonAncestors);
             rv = SerializeRangeContextStart(mCommonAncestors, output);
             NS_ENSURE_SUCCESS(rv, rv);
             // Don't let SerializeRangeToString serialize the context again
@@ -1267,16 +1270,18 @@ public:
 
   NS_IMETHOD Init(nsIDOMDocument* aDocument, const nsAString& aMimeType, uint32_t aFlags);
 
   // overridden methods from nsDocumentEncoder
   NS_IMETHOD SetSelection(nsISelection* aSelection);
   NS_IMETHOD EncodeToStringWithContext(nsAString& aContextString,
                                        nsAString& aInfoString,
                                        nsAString& aEncodedString);
+  NS_IMETHOD EncodeMathMLAnnotationToString(const nsAString& aEncoding,
+                                            nsAString& aEncodedString);
   NS_IMETHOD GetContextParameters(bool* aIsPlainTextContext,
                                   bool* aIsMathMLContext);
 
 protected:
 
   enum Endpoint
   {
     kStart,
@@ -1522,16 +1527,81 @@ nsHTMLCopyEncoder::EncodeToStringWithCon
   infoString.AppendInt(mStartDepth);
   infoString.Append(PRUnichar(','));
   infoString.AppendInt(mEndDepth);
   aInfoString = infoString;
   
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsHTMLCopyEncoder::EncodeMathMLAnnotationToString(const nsAString& aEncoding,
+                                                  nsAString& aEncodedString)
+{
+  // Nothing to do if we are not in a MathML tree.
+  if (!mIsMathMLContext)
+    return NS_OK;
+
+  if (!mDocument || !mSelection)
+    return NS_ERROR_NOT_INITIALIZED;
+
+  nsCOMPtr<nsIDOMRange> range;
+  nsCOMPtr<nsIDOMNode> commonParent;
+  int32_t count = 0;
+
+  nsresult rv = mSelection->GetRangeCount(&count);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // if selection is uninitialized return
+  if (!count)
+    return NS_ERROR_FAILURE;
+  
+  // we'll just use the common parent of the first range.
+  // See the remark in nsHTMLCopyEncoder::SetSelection
+  rv = mSelection->GetRangeAt(0, getter_AddRefs(range));
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!range)
+    return NS_ERROR_NULL_POINTER;
+  range->GetCommonAncestorContainer(getter_AddRefs(commonParent));
+
+  nsCOMPtr<nsIContent> selContent(do_QueryInterface(commonParent));
+
+  // Try to find a <semantics> ancestor
+  for ( ; selContent; selContent = selContent->GetParent()) {
+    if (!selContent->IsMathML() ||
+        selContent->Tag() == nsGkAtoms::math) {
+      // No <semantics> found. Stop here.
+      return NS_OK;
+    }
+    if (selContent->Tag() == nsGkAtoms::semantics_) {
+      break;
+    }
+  }
+
+  if (!selContent) {
+    // No <semantics> found.
+    return NS_OK;
+  }
+
+  // Now look at the children of the <semantics> to see if there is an
+  // annotation with the desired encoding and serialize it.
+  for (selContent = selContent->GetFirstChild(); selContent;
+       selContent = selContent->GetNextSibling()) {
+    if (selContent->IsMathML(nsGkAtoms::annotation_)) {
+      nsAutoString value;
+      selContent->GetAttr(kNameSpaceID_None, nsGkAtoms::encoding, value);
+      if (value.Equals(aEncoding)) {
+        nsContentUtils::GetNodeTextContent(selContent, false, aEncodedString);
+        break;
+      }
+    }
+  }
+
+  return NS_OK;
+}
 
 bool
 nsHTMLCopyEncoder::IncludeInContext(nsINode *aNode)
 {
   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
 
   if (!content)
     return false;
@@ -1903,16 +1973,20 @@ bool
 nsHTMLCopyEncoder::IsRoot(nsIDOMNode* aNode)
 {
   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
   if (content)
   {
     if (mIsTextWidget) 
       return (IsTag(content, nsGkAtoms::div));
 
+    if (mIsMathMLContext)
+      return (IsTag(content, nsGkAtoms::math) ||
+              IsTag(content, nsGkAtoms::mtd_));
+
     return (IsTag(content, nsGkAtoms::body) ||
             IsTag(content, nsGkAtoms::td)   ||
             IsTag(content, nsGkAtoms::th));
   }
   return false;
 }
 
 bool
@@ -2025,23 +2099,34 @@ nsHTMLCopyEncoder::GetImmediateContextCo
 {
   int32_t i = aAncestorArray.Length(), j = 0;
   while (j < i) {
     nsINode *node = aAncestorArray.ElementAt(j);
     if (!node) {
       break;
     }
     nsCOMPtr<nsIContent> content(do_QueryInterface(node));
-    if (!content || !content->IsHTML() || (content->Tag() != nsGkAtoms::tr    &&
-                                           content->Tag() != nsGkAtoms::thead &&
-                                           content->Tag() != nsGkAtoms::tbody &&
-                                           content->Tag() != nsGkAtoms::tfoot &&
-                                           content->Tag() != nsGkAtoms::table)) {
+    if (!content) {
       break;
     }
+    if (mIsMathMLContext) {
+      if (!content->IsMathML() || (content->Tag() != nsGkAtoms::mtr_ &&
+                                   content->Tag() != nsGkAtoms::mlabeledtr_ &&
+                                   content->Tag() != nsGkAtoms::mtable_)) {
+        break;
+      }
+    } else {
+      if (!content->IsHTML() || (content->Tag() != nsGkAtoms::tr    &&
+                                 content->Tag() != nsGkAtoms::thead &&
+                                 content->Tag() != nsGkAtoms::tbody &&
+                                 content->Tag() != nsGkAtoms::tfoot &&
+                                 content->Tag() != nsGkAtoms::table)) {
+        break;
+      }
+    }
     ++j;
   }
   return j;
 }
 
 NS_IMETHODIMP
 nsHTMLCopyEncoder::GetContextParameters(bool* aIsPlainTextContext,
                                         bool* aIsMathMLContext)
diff --git a/netwerk/mime/nsMimeTypes.h b/netwerk/mime/nsMimeTypes.h
--- a/netwerk/mime/nsMimeTypes.h
+++ b/netwerk/mime/nsMimeTypes.h
@@ -64,16 +64,17 @@
 #define APPLICATION_JAVAARCHIVE             "application/java-archive"
 #define APPLICATION_MARIMBA                 "application/marimba"
 #define APPLICATION_XMARIMBA                "application/x-marimba"
 #define APPLICATION_XPINSTALL               "application/x-xpinstall"
 #define APPLICATION_XML                     "application/xml"
 #define APPLICATION_XHTML_XML               "application/xhtml+xml"
 #define APPLICATION_XSLT_XML                "application/xslt+xml"
 #define APPLICATION_MATHML_XML              "application/mathml+xml"
+#define APPLICATION_TEX                     "application/x-tex"
 #define APPLICATION_RDF_XML                 "application/rdf+xml"
 
 #define AUDIO_BASIC                         "audio/basic"
 #define AUDIO_OGG                           "audio/ogg"
 #define AUDIO_WAV                           "audio/x-wav"
 #define AUDIO_WEBM                          "audio/webm"
 #define AUDIO_MP3                           "audio/mpeg"
 
diff --git a/widget/windows/nsClipboard.cpp b/widget/windows/nsClipboard.cpp
--- a/widget/windows/nsClipboard.cpp
+++ b/widget/windows/nsClipboard.cpp
@@ -27,24 +27,29 @@
 #include "nsPrimitiveHelpers.h"
 #include "nsImageClipboard.h"
 #include "nsIWidget.h"
 #include "nsIComponentManager.h"
 #include "nsWidgetsCID.h"
 #include "nsCRT.h"
 #include "nsNetUtil.h"
 #include "nsEscape.h"
+#include "nsMimeTypes.h"
 
 #ifdef PR_LOGGING
 PRLogModuleInfo* gWin32ClipboardLog = nullptr;
 #endif
 
 // oddly, this isn't in the MSVC headers anywhere.
 UINT nsClipboard::CF_HTML = ::RegisterClipboardFormatW(L"HTML Format");
 
+// Some clipboard formats used to copy MathML formulas
+// See http://www.w3.org/TR/MathML3/chapter6.html
+UINT nsClipboard::CF_MATHML = ::RegisterClipboardFormatW(L"MathML");
+UINT nsClipboard::CF_TEX = ::RegisterClipboardFormatW(L"TeX");
 
 //-------------------------------------------------------------------------
 //
 // nsClipboard constructor
 //
 //-------------------------------------------------------------------------
 nsClipboard::nsClipboard() : nsBaseClipboard()
 {
@@ -79,16 +84,20 @@ UINT nsClipboard::GetFormat(const char* 
            strcmp(aMimeStr, kJPGImageMime) == 0 ||
            strcmp(aMimeStr, kPNGImageMime) == 0)
     format = CF_DIBV5;
   else if (strcmp(aMimeStr, kFileMime) == 0 ||
            strcmp(aMimeStr, kFilePromiseMime) == 0)
     format = CF_HDROP;
   else if (strcmp(aMimeStr, kNativeHTMLMime) == 0)
     format = CF_HTML;
+  else if (strcmp(aMimeStr, APPLICATION_MATHML_XML) == 0)
+    format = CF_MATHML;
+  else if (strcmp(aMimeStr, APPLICATION_TEX) == 0)
+    format = CF_TEX;
   else
     format = ::RegisterClipboardFormatW(NS_ConvertASCIItoUTF16(aMimeStr).get());
 
   return format;
 }
 
 //-------------------------------------------------------------------------
 nsresult nsClipboard::CreateNativeDataObject(nsITransferable * aTransferable, IDataObject ** aDataObj, nsIURI * uri)
diff --git a/widget/windows/nsClipboard.h b/widget/windows/nsClipboard.h
--- a/widget/windows/nsClipboard.h
+++ b/widget/windows/nsClipboard.h
@@ -42,16 +42,18 @@ public:
                                         nsIWidget       * aWindow,
                                         nsITransferable * aTransferable);
   static nsresult GetNativeDataOffClipboard(nsIWidget * aWindow, UINT aIndex, UINT aFormat, void ** aData, uint32_t * aLen);
   static nsresult GetNativeDataOffClipboard(IDataObject * aDataObject, UINT aIndex, UINT aFormat, const char * aMIMEImageFormat, void ** aData, uint32_t * aLen);
   static nsresult GetGlobalData(HGLOBAL aHGBL, void ** aData, uint32_t * aLen);
   static UINT     GetFormat(const char* aMimeStr);
 
   static UINT     CF_HTML;
+  static UINT     CF_MATHML;
+  static UINT     CF_TEX;
   
 protected:
   NS_IMETHOD SetNativeClipboardData ( int32_t aWhichClipboard );
   NS_IMETHOD GetNativeClipboardData ( nsITransferable * aTransferable, int32_t aWhichClipboard );
   
   static bool IsInternetShortcut ( const nsAString& inFileName ) ;
   static bool FindURLFromLocalFile ( IDataObject* inDataObject, UINT inIndex, void** outData, uint32_t* outDataLen ) ;
   static bool FindURLFromNativeURL ( IDataObject* inDataObject, UINT inIndex, void** outData, uint32_t* outDataLen ) ;
