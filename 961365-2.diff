# HG changeset patch
# Parent 7a74ea76955fa6a25168c3d481382abdef9d73ab
# User Frédéric Wang <fred.wang@free.fr>
Part 2 - Use MATH constants for radicals. r=karl, b=961365

diff --git a/layout/mathml/nsMathMLFrame.cpp b/layout/mathml/nsMathMLFrame.cpp
--- a/layout/mathml/nsMathMLFrame.cpp
+++ b/layout/mathml/nsMathMLFrame.cpp
@@ -352,8 +352,38 @@ nsMathMLFrame::DisplayBar(nsDisplayListB
                           nsIFrame* aFrame, const nsRect& aRect,
                           const nsDisplayListSet& aLists) {
   if (!aFrame->StyleVisibility()->IsVisible() || aRect.IsEmpty())
     return;
 
   aLists.Content()->AppendNewToTop(new (aBuilder)
     nsDisplayMathMLBar(aBuilder, aFrame, aRect));
 }
+
+void
+nsMathMLFrame::GetRadicalParameters(nsFontMetrics* aFontMetrics,
+                                    bool aDisplayStyle,
+                                    nscoord& aRadicalRuleThickness,
+                                    nscoord& aRadicalExtraAscender,
+                                    nscoord& aRadicalVerticalGap)
+{
+  // get the radical rulethickness
+  GetRuleThickness(aFontMetrics, aRadicalRuleThickness);
+  GetMathConstantEm(aFontMetrics, gfxFontEntry::RadicalRuleThickness,
+                    aRadicalRuleThickness);
+
+  // get the leading to be left at the top of the resulting frame
+  // This seems more reliable than using aFontMetrics->GetLeading() on
+  // suspicious fonts.
+  nscoord em;
+  GetEmHeight(aFontMetrics, em);
+  aRadicalExtraAscender = nscoord(0.2f * em);
+  GetMathConstantEm(aFontMetrics, gfxFontEntry::RadicalExtraAscender,
+                    aRadicalExtraAscender);
+
+  // get the clearance between rule and content
+  // Rule 11, App. G, TeXbook
+  aRadicalVerticalGap = aRadicalRuleThickness +
+    (aDisplayStyle ? aFontMetrics->XHeight() : aRadicalRuleThickness) / 4;
+  GetMathConstantEm(aFontMetrics, aDisplayStyle ?
+                    gfxFontEntry::RadicalDisplayStyleVerticalGap :
+                    gfxFontEntry::RadicalVerticalGap, aRadicalVerticalGap);
+}
diff --git a/layout/mathml/nsMathMLFrame.h b/layout/mathml/nsMathMLFrame.h
--- a/layout/mathml/nsMathMLFrame.h
+++ b/layout/mathml/nsMathMLFrame.h
@@ -181,16 +181,23 @@ public:
   {
     if (TryGetMathTable(aFontMetrics)) {
       aValue = aFontMetrics->GetThebesFontGroup()->GetFontAt(0)->
         GetFontEntry()->GetMathConstant(aConstant);
     }
   }
 
   static void
+  GetRadicalParameters(nsFontMetrics* aFontMetrics,
+                       bool aDisplayStyle,
+                       nscoord& aRadicalRuleThickness,
+                       nscoord& aRadicalExtraAscender,
+                       nscoord& aRadicalVerticalGap);
+
+  static void
   GetMathConstantEm(nsFontMetrics*             aFontMetrics,
                     gfxFontEntry::MathConstant aConstant,
                     nscoord&                   aValue)
   {
     if (TryGetMathTable(aFontMetrics)) {
       gfxFont* mathFont = aFontMetrics->GetThebesFontGroup()->GetFontAt(0);
       aValue = NSToCoordRound(mathFont->GetFontEntry()->
                               GetMathConstant(aConstant) *
diff --git a/layout/mathml/nsMathMLmencloseFrame.cpp b/layout/mathml/nsMathMLmencloseFrame.cpp
--- a/layout/mathml/nsMathMLmencloseFrame.cpp
+++ b/layout/mathml/nsMathMLmencloseFrame.cpp
@@ -207,17 +207,17 @@ nsMathMLmencloseFrame::BuildDisplayList(
   mencloseRect.x = mencloseRect.y = 0;
 
   if (IsToDraw(NOTATION_RADICAL)) {
     mMathMLChar[mRadicalCharIndex].Display(aBuilder, this, aLists, 0);
 
     nsRect rect;
     mMathMLChar[mRadicalCharIndex].GetRect(rect);
     rect.MoveBy(StyleVisibility()->mDirection ? -mContentWidth : rect.width, 0);
-    rect.SizeTo(mContentWidth, mRuleThickness);
+    rect.SizeTo(mContentWidth, mRadicalRuleThickness);
     DisplayBar(aBuilder, this, rect, aLists);
   }
 
   if (IsToDraw(NOTATION_PHASORANGLE)) {
     DisplayNotation(aBuilder, this, mencloseRect, aLists,
                 mRuleThickness, NOTATION_PHASORANGLE);
   }
 
@@ -324,59 +324,60 @@ nsMathMLmencloseFrame::PlaceInternal(nsR
     }
 
   nsBoundingMetrics bmBase = baseSize.mBoundingMetrics;
   nscoord dx_left = 0, dx_right = 0;
   nsBoundingMetrics bmLongdivChar, bmRadicalChar;
   nscoord radicalAscent = 0, radicalDescent = 0;
   nscoord longdivAscent = 0, longdivDescent = 0;
   nscoord psi = 0;
+  nscoord leading;
 
   ///////////////
   // Thickness of bars and font metrics
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   nscoord mEmHeight;
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
   GetRuleThickness(aRenderingContext, fm, mRuleThickness);
   GetEmHeight(fm, mEmHeight);
+  if (mRuleThickness < onePixel)
+    mRuleThickness = onePixel;
 
   char16_t one = '1';
   nsBoundingMetrics bmOne = aRenderingContext.GetBoundingMetrics(&one, 1);
 
   ///////////////
   // General rules: the menclose element takes the size of the enclosed content.
   // We add a padding when needed.
 
   // determine padding & psi
   nscoord padding = 3 * mRuleThickness;
   nscoord delta = padding % onePixel;
   if (delta)
     padding += onePixel - delta; // round up
 
   if (IsToDraw(NOTATION_LONGDIV) || IsToDraw(NOTATION_RADICAL)) {
-      nscoord phi;
-      // Rule 11, App. G, TeXbook
-      // psi = clearance between rule and content
-      if (StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK)
-        phi = fm->XHeight();
-      else
-        phi = mRuleThickness;
-      psi = mRuleThickness + phi / 4;
+    GetRadicalParameters(fm, StyleFont()->mMathDisplay ==
+                         NS_MATHML_DISPLAYSTYLE_BLOCK,
+                         mRadicalRuleThickness, leading, psi);
 
-      delta = psi % onePixel;
-      if (delta)
-        psi += onePixel - delta; // round up
-    }
+    // make sure that the rule appears on on screen
+    if (mRadicalRuleThickness < onePixel)
+      mRadicalRuleThickness = onePixel;
 
-  if (mRuleThickness < onePixel)
-    mRuleThickness = onePixel;
- 
+    // adjust clearance psi to get an exact number of pixels -- this
+    // gives a nicer & uniform look on stacked radicals (bug 130282)
+    //    delta = psi % onePixel;
+    if (delta)
+      psi += onePixel - delta; // round up
+  }
+
   // Set horizontal parameters
   if (IsToDraw(NOTATION_ROUNDEDBOX) ||
       IsToDraw(NOTATION_TOP) ||
       IsToDraw(NOTATION_LEFT) ||
       IsToDraw(NOTATION_BOTTOM) ||
       IsToDraw(NOTATION_CIRCLE))
     dx_left = padding;
 
@@ -516,32 +517,32 @@ nsMathMLmencloseFrame::PlaceInternal(nsR
         GetMaxWidth(PresContext(), aRenderingContext);
       
       // Update horizontal parameters
       *dx_leading = std::max(*dx_leading, radical_width);
     } else {
       // Stretch the radical symbol to the appropriate height if it is not
       // big enough.
       nsBoundingMetrics contSize = bmBase;
-      contSize.ascent = mRuleThickness;
+      contSize.ascent = mRadicalRuleThickness;
       contSize.descent = bmBase.ascent + bmBase.descent + psi;
 
-      // height(radical) should be >= height(base) + psi + mRuleThickness
+      // height(radical) should be >= height(base) + psi + mRadicalRuleThickness
       mMathMLChar[mRadicalCharIndex].Stretch(PresContext(), aRenderingContext,
                                              NS_STRETCH_DIRECTION_VERTICAL,
                                              contSize, bmRadicalChar,
                                              NS_STRETCH_LARGER,
                                              StyleVisibility()->mDirection);
       mMathMLChar[mRadicalCharIndex].GetBoundingMetrics(bmRadicalChar);
 
       // Update horizontal parameters
       *dx_leading = std::max(*dx_leading, bmRadicalChar.width);
 
       // Update vertical parameters
-      radicalAscent = bmBase.ascent + psi + mRuleThickness;
+      radicalAscent = bmBase.ascent + psi + mRadicalRuleThickness;
       radicalDescent = std::max(bmBase.descent,
                               (bmRadicalChar.ascent + bmRadicalChar.descent -
                                radicalAscent));
 
       mBoundingMetrics.ascent = std::max(mBoundingMetrics.ascent,
                                        radicalAscent);
       mBoundingMetrics.descent = std::max(mBoundingMetrics.descent,
                                         radicalDescent);
@@ -569,36 +570,32 @@ nsMathMLmencloseFrame::PlaceInternal(nsR
 
   aDesiredSize.SetBlockStartAscent(std::max(mBoundingMetrics.ascent,
                                             baseSize.BlockStartAscent()));
   aDesiredSize.Height() = aDesiredSize.BlockStartAscent() +
     std::max(mBoundingMetrics.descent,
              baseSize.Height() - baseSize.BlockStartAscent());
 
   if (IsToDraw(NOTATION_LONGDIV) || IsToDraw(NOTATION_RADICAL)) {
-    // get the leading to be left at the top of the resulting frame
-    // this seems more reliable than using fm->GetLeading() on suspicious
-    // fonts
-    nscoord leading = nscoord(0.2f * mEmHeight);
     nscoord desiredSizeAscent = aDesiredSize.BlockStartAscent();
     nscoord desiredSizeDescent = aDesiredSize.Height() -
                                  aDesiredSize.BlockStartAscent();
     
     if (IsToDraw(NOTATION_LONGDIV)) {
       desiredSizeAscent = std::max(desiredSizeAscent,
                                  longdivAscent + leading);
       desiredSizeDescent = std::max(desiredSizeDescent,
                                   longdivDescent + mRuleThickness);
     }
     
     if (IsToDraw(NOTATION_RADICAL)) {
       desiredSizeAscent = std::max(desiredSizeAscent,
                                  radicalAscent + leading);
       desiredSizeDescent = std::max(desiredSizeDescent,
-                                  radicalDescent + mRuleThickness);
+                                  radicalDescent + mRadicalRuleThickness);
     }
 
     aDesiredSize.SetBlockStartAscent(desiredSizeAscent);
     aDesiredSize.Height() = desiredSizeAscent + desiredSizeDescent;
   }
     
   if (IsToDraw(NOTATION_CIRCLE) ||
       IsToDraw(NOTATION_ROUNDEDBOX) ||
diff --git a/layout/mathml/nsMathMLmencloseFrame.h b/layout/mathml/nsMathMLmencloseFrame.h
--- a/layout/mathml/nsMathMLmencloseFrame.h
+++ b/layout/mathml/nsMathMLmencloseFrame.h
@@ -104,16 +104,17 @@ protected:
   // Description of the notations to draw
   uint32_t mNotationsToDraw;
   bool IsToDraw(nsMencloseNotation mask)
   {
     return mask & mNotationsToDraw;
   }
 
   nscoord mRuleThickness;
+  nscoord mRadicalRuleThickness;
   nsTArray<nsMathMLChar> mMathMLChar;
   int8_t mLongDivCharIndex, mRadicalCharIndex;
   nscoord mContentWidth;
   nsresult AllocateMathMLChar(nsMencloseNotation mask);
 
   // Display a frame of the specified type.
   // @param aType Type of frame to display
   void DisplayNotation(nsDisplayListBuilder* aBuilder,
diff --git a/layout/mathml/nsMathMLmrootFrame.cpp b/layout/mathml/nsMathMLmrootFrame.cpp
--- a/layout/mathml/nsMathMLmrootFrame.cpp
+++ b/layout/mathml/nsMathMLmrootFrame.cpp
@@ -4,28 +4,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMathMLmrootFrame.h"
 #include "nsPresContext.h"
 #include "nsRenderingContext.h"
 #include <algorithm>
 
 //
-// <msqrt> and <mroot> -- form a radical - implementation
+// <mroot> -- form a radical - implementation
 //
 
-//NOTE:
-//  The code assumes that TeX fonts are picked.
-//  There is no fall-back to draw the branches of the sqrt explicitly
-//  in the case where TeX fonts are not there. In general, there are no
-//  fall-back(s) in MathML when some (freely-downloadable) fonts are missing.
-//  Otherwise, this will add much work and unnecessary complexity to the core
-//  MathML  engine. Assuming that authors have the free fonts is part of the
-//  deal. We are not responsible for cases of misconfigurations out there.
-
 // additional style context to be used by our MathMLChar.
 #define NS_SQR_CHAR_STYLE_CONTEXT_INDEX   0
 
 static const char16_t kSqrChar = char16_t(0x221A);
 
 nsIFrame*
 NS_NewMathMLmrootFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
@@ -103,45 +94,62 @@ nsMathMLmrootFrame::BuildDisplayList(nsD
     mSqrChar.GetRect(rect);
     nsBoundingMetrics bm;
     mSqrChar.GetBoundingMetrics(bm);
     DisplayBoundingMetrics(aBuilder, this, rect.TopLeft(), bm, aLists);
 #endif
   }
 }
 
-static void
-GetRadicalXOffsets(nscoord aIndexWidth, nscoord aSqrWidth,
-                   nsFontMetrics* aFontMetrics,
-                   nscoord* aIndexOffset, nscoord* aSqrOffset)
+void
+nsMathMLmrootFrame::GetRadicalXOffsets(nscoord aIndexWidth, nscoord aSqrWidth,
+                                       nsFontMetrics* aFontMetrics,
+                                       nscoord* aIndexOffset,
+                                       nscoord* aSqrOffset)
 {
   // The index is tucked in closer to the radical while making sure
   // that the kern does not make the index and radical collide
   nscoord dxIndex, dxSqr;
   nscoord xHeight = aFontMetrics->XHeight();
   nscoord indexRadicalKern = NSToCoordRound(1.35f * xHeight);
+  bool hasMATHTable = TryGetMathTable(aFontMetrics);
+  if (hasMATHTable) {
+    GetMathConstantEm(aFontMetrics, gfxFontEntry::RadicalKernAfterDegree,
+                      indexRadicalKern);
+    indexRadicalKern = -indexRadicalKern;
+  }
   if (indexRadicalKern > aIndexWidth) {
     dxIndex = indexRadicalKern - aIndexWidth;
     dxSqr = 0;
   }
   else {
     dxIndex = 0;
     dxSqr = aIndexWidth - indexRadicalKern;
   }
-  // avoid collision by leaving a minimum space between index and radical
-  nscoord minimumClearance = aSqrWidth/2;
-  if (dxIndex + aIndexWidth + minimumClearance > dxSqr + aSqrWidth) {
-    if (aIndexWidth + minimumClearance < aSqrWidth) {
-      dxIndex = aSqrWidth - (aIndexWidth + minimumClearance);
-      dxSqr = 0;
+
+  if (!hasMATHTable) {
+    // avoid collision by leaving a minimum space between index and radical
+    nscoord minimumClearance = aSqrWidth/2;
+    if (dxIndex + aIndexWidth + minimumClearance > dxSqr + aSqrWidth) {
+      if (aIndexWidth + minimumClearance < aSqrWidth) {
+        dxIndex = aSqrWidth - (aIndexWidth + minimumClearance);
+        dxSqr = 0;
+      }
+      else {
+        dxIndex = 0;
+        dxSqr = (aIndexWidth + minimumClearance) - aSqrWidth;
+      }
     }
-    else {
-      dxIndex = 0;
-      dxSqr = (aIndexWidth + minimumClearance) - aSqrWidth;
-    }
+  } else {
+    // add some kern before the radical index
+    nscoord indexRadicalKernBefore = 0;
+    GetMathConstantEm(aFontMetrics, gfxFontEntry::RadicalKernBeforeDegree,
+                      indexRadicalKernBefore);
+    dxIndex += indexRadicalKernBefore;
+    dxSqr += indexRadicalKernBefore;
   }
 
   if (aIndexOffset)
     *aIndexOffset = dxIndex;
   if (aSqrOffset)
     *aSqrOffset = dxSqr;
 }
 
@@ -207,41 +215,24 @@ nsMathMLmrootFrame::Reflow(nsPresContext
 
   ////////////
   // Prepare the radical symbol and the overline bar
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   renderingContext.SetFont(fm);
 
-  // For radical glyphs from TeX fonts and some of the radical glyphs from
-  // Mathematica fonts, the thickness of the overline can be obtained from the
-  // ascent of the glyph.  Most fonts however have radical glyphs above the
-  // baseline so no assumption can be made about the meaning of the ascent.
-  nscoord ruleThickness, leading, em;
-  GetRuleThickness(renderingContext, fm, ruleThickness);
+  nscoord ruleThickness, leading, psi;
+  GetRadicalParameters(fm, StyleFont()->mMathDisplay ==
+                       NS_MATHML_DISPLAYSTYLE_BLOCK,
+                       ruleThickness, leading, psi);
 
+  // built-in: adjust clearance psi to emulate \mathstrut using '1' (TexBook, p.131)
   char16_t one = '1';
   nsBoundingMetrics bmOne = renderingContext.GetBoundingMetrics(&one, 1);
-
-  // get the leading to be left at the top of the resulting frame
-  // this seems more reliable than using fm->GetLeading() on suspicious fonts
-  GetEmHeight(fm, em);
-  leading = nscoord(0.2f * em); 
-
-  // Rule 11, App. G, TeXbook
-  // psi = clearance between rule and content
-  nscoord phi = 0, psi = 0;
-  if (StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK)
-    phi = fm->XHeight();
-  else
-    phi = ruleThickness;
-  psi = ruleThickness + phi/4;
-
-  // built-in: adjust clearance psi to emulate \mathstrut using '1' (TexBook, p.131)
   if (bmOne.ascent > bmBase.ascent)
     psi += bmOne.ascent - bmBase.ascent;
 
   // make sure that the rule appears on on screen
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
   if (ruleThickness < onePixel) {
     ruleThickness = onePixel;
   }
@@ -285,17 +276,21 @@ nsMathMLmrootFrame::Reflow(nsPresContext
              mBoundingMetrics.descent + ruleThickness);
   aDesiredSize.Width() = mBoundingMetrics.width;
 
   /////////////
   // Re-adjust the desired size to include the index.
   
   // the index is raised by some fraction of the height
   // of the radical, see \mroot macro in App. B, TexBook
-  nscoord raiseIndexDelta = NSToCoordRound(0.6f * (bmSqr.ascent + bmSqr.descent));
+  float raiseIndexPercent = 0.6f;
+  GetMathConstant(fm, gfxFontEntry::RadicalDegreeBottomRaisePercent,
+                  raiseIndexPercent);
+  nscoord raiseIndexDelta = NSToCoordRound(raiseIndexPercent *
+                                           (bmSqr.ascent + bmSqr.descent));
   nscoord indexRaisedAscent = mBoundingMetrics.ascent // top of radical 
     - (bmSqr.ascent + bmSqr.descent) // to bottom of radical
     + raiseIndexDelta + bmIndex.ascent + bmIndex.descent; // to top of raised index
 
   nscoord indexClearance = 0;
   if (mBoundingMetrics.ascent < indexRaisedAscent) {
     indexClearance = 
       indexRaisedAscent - mBoundingMetrics.ascent; // excess gap introduced by a tall index 
diff --git a/layout/mathml/nsMathMLmrootFrame.h b/layout/mathml/nsMathMLmrootFrame.h
--- a/layout/mathml/nsMathMLmrootFrame.h
+++ b/layout/mathml/nsMathMLmrootFrame.h
@@ -35,16 +35,22 @@ public:
   TransmitAutomaticData() MOZ_OVERRIDE;
 
   virtual void
   Reflow(nsPresContext*          aPresContext,
          nsHTMLReflowMetrics&     aDesiredSize,
          const nsHTMLReflowState& aReflowState,
          nsReflowStatus&          aStatus) MOZ_OVERRIDE;
 
+  void
+  GetRadicalXOffsets(nscoord aIndexWidth, nscoord aSqrWidth,
+                     nsFontMetrics* aFontMetrics,
+                     nscoord* aIndexOffset,
+                     nscoord* aSqrOffset);
+
   virtual void
   GetIntrinsicWidthMetrics(nsRenderingContext* aRenderingContext,
                            nsHTMLReflowMetrics& aDesiredSize) MOZ_OVERRIDE;
 
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
 
diff --git a/layout/mathml/nsMathMLmsqrtFrame.cpp b/layout/mathml/nsMathMLmsqrtFrame.cpp
--- a/layout/mathml/nsMathMLmsqrtFrame.cpp
+++ b/layout/mathml/nsMathMLmsqrtFrame.cpp
@@ -5,25 +5,16 @@
 
 #include "nsMathMLmsqrtFrame.h"
 #include "mozilla/gfx/2D.h"
 
 //
 // <msqrt> -- form a radical - implementation
 //
 
-//NOTE:
-//  The code assumes that TeX fonts are picked.
-//  There is no fall-back to draw the branches of the sqrt explicitly
-//  in the case where TeX fonts are not there. In general, there are no
-//  fall-back(s) in MathML when some (freely-downloadable) fonts are missing.
-//  Otherwise, this will add much work and unnecessary complexity to the core
-//  MathML  engine. Assuming that authors have the free fonts is part of the
-//  deal. We are not responsible for cases of misconfigurations out there.
-
 nsIFrame*
 NS_NewMathMLmsqrtFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsMathMLmsqrtFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmsqrtFrame)
 
