# HG changeset patch
# Parent c477e6a37eade0fb958b78638ad5e446779ef624
# User Frédéric Wang <fred.wang@free.fr>
Bug 945183 - Mirroring large/stretchy operators

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -31,16 +31,42 @@
 
 using namespace mozilla;
 
 //#define NOISY_SEARCH 1
 
 static const float kLargeOpFactor = float(M_SQRT2);
 static const float kIntegralFactor = 2.0;
 
+static gfxTextRun*
+MakeTextRunWithDirection(gfxFontGroup*   aFontGroup,
+                         const char16_t* aString,
+                         uint32_t        aLength,
+                         gfxContext*     aThebesContext,
+                         int32_t         aAppUnitsPerDevPixel,
+                         bool            aRTL)
+{
+  nsRefPtr<gfxFontGroup> newFontGroup;
+  if (aRTL) {
+    gfxFontStyle fontStyle = *aFontGroup->GetStyle();
+    gfxFontFeature settingRTLM;
+    settingRTLM.mTag = TRUETYPE_TAG('r','t','l','m');
+    settingRTLM.mValue = 1;
+    fontStyle.featureSettings.AppendElement(settingRTLM);
+    newFontGroup = aFontGroup->Copy(&fontStyle);
+  }
+  if (!newFontGroup) {
+    newFontGroup = aFontGroup;
+  }
+  return newFontGroup->
+    MakeTextRun(aString, aLength, aThebesContext,
+                aAppUnitsPerDevPixel,
+                aRTL ? gfxTextRunFactory::TEXT_IS_RTL : 0);
+}
+
 // -----------------------------------------------------------------------------
 static const nsGlyphCode kNullGlyph = {{{0, 0}}, 0};
 
 // -----------------------------------------------------------------------------
 // nsGlyphTable is a class that provides an interface for accessing glyphs
 // of stretchy chars. It acts like a table that stores the variants of bigger
 // sizes (if any) and the partial glyphs needed to build extensible symbols.
 //
@@ -59,30 +85,33 @@ public:
   virtual const nsAString&
   FontNameFor(const nsGlyphCode& aGlyphCode) const = 0;
 
   // Getters for the parts
   virtual nsGlyphCode ElementAt(gfxContext*   aThebesContext,
                                 int32_t       aAppUnitsPerDevPixel,
                                 gfxFontGroup* aFontGroup,
                                 char16_t      aChar,
+                                bool          aRTL,
                                 bool          aVertical,
                                 uint32_t      aPosition) = 0;
   virtual nsGlyphCode BigOf(gfxContext*   aThebesContext,
                             int32_t       aAppUnitsPerDevPixel,
                             gfxFontGroup* aFontGroup,
                             char16_t      aChar,
+                            bool          aRTL,
                             bool          aVertical,
                             uint32_t      aSize) = 0;
 
   // True if this table contains parts to render this char
   virtual bool HasPartsOf(gfxContext*   aThebesContext,
                           int32_t       aAppUnitsPerDevPixel,
                           gfxFontGroup* aFontGroup,
                           char16_t      aChar,
+                          bool          aRTL,
                           bool          aVertical) = 0;
 
   virtual gfxTextRun* MakeTextRun(gfxContext*        aThebesContext,
                                   int32_t            aAppUnitsPerDevPixel,
                                   gfxFontGroup*      aFontGroup,
                                   const nsGlyphCode& aGlyph) = 0;
 protected:
   nsGlyphTable() : mCharCache(0) {}
@@ -167,44 +196,47 @@ public:
                  "nsPropertiesTable can only access glyphs by code point");
     return mFontName[aGlyphCode.font];
   }
 
   virtual nsGlyphCode ElementAt(gfxContext*   aThebesContext,
                                 int32_t       aAppUnitsPerDevPixel,
                                 gfxFontGroup* aFontGroup,
                                 char16_t      aChar,
+                                bool          aRTL,
                                 bool          aVertical,
                                 uint32_t      aPosition) MOZ_OVERRIDE;
 
   virtual nsGlyphCode BigOf(gfxContext*   aThebesContext,
                             int32_t       aAppUnitsPerDevPixel,
                             gfxFontGroup* aFontGroup,
                             char16_t      aChar,
+                            bool          aRTL,
                             bool          aVertical,
                             uint32_t      aSize) MOZ_OVERRIDE
   {
     return ElementAt(aThebesContext, aAppUnitsPerDevPixel, aFontGroup,
-                     aChar, aVertical, 4 + aSize);
+                     aChar, aRTL, aVertical, 4 + aSize);
   }
 
   virtual bool HasPartsOf(gfxContext*   aThebesContext,
                           int32_t       aAppUnitsPerDevPixel,
                           gfxFontGroup* aFontGroup,
                           char16_t      aChar,
+                          bool          aRTL,
                           bool          aVertical) MOZ_OVERRIDE
   {
     return (ElementAt(aThebesContext, aAppUnitsPerDevPixel, aFontGroup,
-                      aChar, aVertical, 0).Exists() ||
+                      aChar, aRTL, aVertical, 0).Exists() ||
             ElementAt(aThebesContext, aAppUnitsPerDevPixel, aFontGroup,
-                      aChar, aVertical, 1).Exists() ||
+                      aChar, aRTL, aVertical, 1).Exists() ||
             ElementAt(aThebesContext, aAppUnitsPerDevPixel, aFontGroup,
-                      aChar, aVertical, 2).Exists() ||
+                      aChar, aRTL, aVertical, 2).Exists() ||
             ElementAt(aThebesContext, aAppUnitsPerDevPixel, aFontGroup,
-                      aChar, aVertical, 3).Exists());
+                      aChar, aRTL, aVertical, 3).Exists());
   }
 
   virtual gfxTextRun* MakeTextRun(gfxContext*        aThebesContext,
                                   int32_t            aAppUnitsPerDevPixel,
                                   gfxFontGroup*      aFontGroup,
                                   const nsGlyphCode& aGlyph) MOZ_OVERRIDE;
 private:
 
@@ -241,16 +273,17 @@ private:
 };
 
 /* virtual */
 nsGlyphCode
 nsPropertiesTable::ElementAt(gfxContext*   /* aThebesContext */,
                              int32_t       /* aAppUnitsPerDevPixel */,
                              gfxFontGroup* /* aFontGroup */,
                              char16_t      aChar,
+                             bool          /* aRTL */,
                              bool          /* aVertical */,
                              uint32_t      aPosition)
 {
   if (mState == NS_TABLE_STATE_ERROR) return kNullGlyph;
   // Load glyph properties if this is the first time we have been here
   if (mState == NS_TABLE_STATE_EMPTY) {
     nsresult rv = LoadProperties(mFontName[0], mGlyphProperties);
 #ifdef DEBUG
@@ -375,28 +408,31 @@ public:
   {
     MOZ_COUNT_DTOR(nsOpenTypeTable);
   }
 
   virtual nsGlyphCode ElementAt(gfxContext*   aThebesContext,
                                 int32_t       aAppUnitsPerDevPixel,
                                 gfxFontGroup* aFontGroup,
                                 char16_t      aChar,
+                                bool          aRTL,
                                 bool          aVertical,
                                 uint32_t      aPosition) MOZ_OVERRIDE;
   virtual nsGlyphCode BigOf(gfxContext*   aThebesContext,
                             int32_t       aAppUnitsPerDevPixel,
                             gfxFontGroup* aFontGroup,
                             char16_t      aChar,
+                            bool          aRTL,
                             bool          aVertical,
                             uint32_t      aSize) MOZ_OVERRIDE;
   virtual bool HasPartsOf(gfxContext*   aThebesContext,
                           int32_t       aAppUnitsPerDevPixel,
                           gfxFontGroup* aFontGroup,
                           char16_t      aChar,
+                          bool          aRTL,
                           bool          aVertical) MOZ_OVERRIDE;
 
   const nsAString&
   FontNameFor(const nsGlyphCode& aGlyphCode) const MOZ_OVERRIDE {
     NS_ASSERTION(aGlyphCode.IsGlyphID(),
                  "nsOpenTypeTable can only access glyphs by id");
     return mFontEntry->FamilyName();
   }
@@ -415,60 +451,66 @@ public:
       return nullptr;
     }
     return new nsOpenTypeTable(aFont->GetFontEntry());
   }
 
 private:
   nsRefPtr<gfxFontEntry> mFontEntry;
   uint32_t mGlyphID;
+  bool mRTLCache;
 
   explicit nsOpenTypeTable(gfxFontEntry* aFontEntry)
-    : mFontEntry(aFontEntry) {
+    : mFontEntry(aFontEntry)
+    , mRTLCache(false) {
     MOZ_COUNT_CTOR(nsOpenTypeTable);
   }
 
   void UpdateCache(gfxContext*   aThebesContext,
                    int32_t       aAppUnitsPerDevPixel,
                    gfxFontGroup* aFontGroup,
-                   char16_t      aChar);
+                   char16_t      aChar,
+                   bool          aRTL);
 };
 
 void
 nsOpenTypeTable::UpdateCache(gfxContext*   aThebesContext,
                              int32_t       aAppUnitsPerDevPixel,
                              gfxFontGroup* aFontGroup,
-                             char16_t      aChar)
+                             char16_t      aChar,
+                             bool          aRTL)
 {
-  if (mCharCache != aChar) {
+  if (mCharCache != aChar || mRTLCache != aRTL) {
     nsAutoPtr<gfxTextRun> textRun;
-    textRun = aFontGroup->
-      MakeTextRun(&aChar, 1, aThebesContext, aAppUnitsPerDevPixel, 0);
+    textRun = MakeTextRunWithDirection(aFontGroup, &aChar, 1, aThebesContext,
+                                       aAppUnitsPerDevPixel, aRTL);
     const gfxTextRun::CompressedGlyph& data = textRun->GetCharacterGlyphs()[0];
     if (data.IsSimpleGlyph()) {
       mGlyphID = data.GetSimpleGlyph();
     } else if (data.GetGlyphCount() == 1) {
       mGlyphID = textRun->GetDetailedGlyphs(0)->mGlyphID;
     } else {
       mGlyphID = 0;
     }
     mCharCache = aChar;
+    mRTLCache = aRTL;
   }
 }
 
 /* virtual */
 nsGlyphCode
 nsOpenTypeTable::ElementAt(gfxContext*   aThebesContext,
                            int32_t       aAppUnitsPerDevPixel,
                            gfxFontGroup* aFontGroup,
                            char16_t      aChar,
+                           bool          aRTL,
                            bool          aVertical,
                            uint32_t      aPosition)
 {
-  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar);
+  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar, aRTL);
 
   uint32_t parts[4];
   if (!mFontEntry->GetMathVariantsParts(mGlyphID, aVertical, parts)) {
     return kNullGlyph;
   }
 
   uint32_t glyphID = parts[aPosition];
   if (!glyphID) {
@@ -481,20 +523,21 @@ nsOpenTypeTable::ElementAt(gfxContext*  
 }
 
 /* virtual */
 nsGlyphCode
 nsOpenTypeTable::BigOf(gfxContext*   aThebesContext,
                        int32_t       aAppUnitsPerDevPixel,
                        gfxFontGroup* aFontGroup,
                        char16_t      aChar,
+                       bool          aRTL,
                        bool          aVertical,
                        uint32_t      aSize)
 {
-  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar);
+  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar, aRTL);
 
   uint32_t glyphID =
     mFontEntry->GetMathVariantsSize(mGlyphID, aVertical, aSize);
   if (!glyphID) {
     return kNullGlyph;
   }
 
   nsGlyphCode glyph;
@@ -504,19 +547,20 @@ nsOpenTypeTable::BigOf(gfxContext*   aTh
 }
 
 /* virtual */
 bool
 nsOpenTypeTable::HasPartsOf(gfxContext*   aThebesContext,
                             int32_t       aAppUnitsPerDevPixel,
                             gfxFontGroup* aFontGroup,
                             char16_t      aChar,
+                            bool          aRTL,
                             bool          aVertical)
 {
-  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar);
+  UpdateCache(aThebesContext, aAppUnitsPerDevPixel, aFontGroup, aChar, aRTL);
 
   uint32_t parts[4];
   if (!mFontEntry->GetMathVariantsParts(mGlyphID, aVertical, parts)) {
     return false;
   }
 
   return parts[0] || parts[1] || parts[2] || parts[3];
 }
@@ -1067,17 +1111,17 @@ StretchEnumContext::TryVariants(nsGlyphT
 
   // start at size = 1 (size = 0 is the char at its normal size)
   int32_t size = 1;
   nsGlyphCode ch;
   nscoord displayOperatorMinHeight = 0;
   if (largeopOnly) {
     NS_ASSERTION(isVertical, "Stretching should be in the vertical direction");
     ch = aGlyphTable->BigOf(mThebesContext, oneDevPixel, *aFontGroup, uchar,
-                            isVertical, 0);
+                            mChar->mRTL, isVertical, 0);
     if (ch.IsGlyphID()) {
       gfxFont* mathFont = aFontGroup->get()->GetFontAt(0);
       // For OpenType MATH fonts, we will rely on the DisplayOperatorMinHeight
       // to select the right size variant. Note that the value is sometimes too
       // small so we use kLargeOpFactor/kIntegralFactor as a minimum value.
       displayOperatorMinHeight =
         NSToCoordRound(mathFont->GetFontEntry()->
                        GetMathConstant(gfxFontEntry::DisplayOperatorMinHeight) *
@@ -1097,17 +1141,18 @@ StretchEnumContext::TryVariants(nsGlyphT
       }
     }
   }
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
   while ((ch = aGlyphTable->BigOf(mThebesContext, oneDevPixel, *aFontGroup,
-                                  uchar, isVertical, size)).Exists()) {
+                                  uchar, mChar->mRTL,
+                                  isVertical, size)).Exists()) {
 
     if (!mChar->SetFontFamily(mPresContext, aGlyphTable, ch, aFamily, font,
                               aFontGroup)) {
       // if largeopOnly is set, break now
       if (largeopOnly) break;
       ++size;
       continue;
     }
@@ -1206,22 +1251,23 @@ nsMathMLChar::StretchEnumContext::TryPar
   nsBoundingMetrics bmdata[4];
   nscoord sizedata[4];
 
   bool isVertical = (mDirection == NS_STRETCH_DIRECTION_VERTICAL);
   nscoord oneDevPixel = mPresContext->AppUnitsPerDevPixel();
   char16_t uchar = mChar->mData[0];
   bool maxWidth = (NS_STRETCH_MAXWIDTH & mStretchHint) != 0;
   if (!aGlyphTable->HasPartsOf(mThebesContext, oneDevPixel, *aFontGroup,
-                               uchar, isVertical))
+                               uchar, mChar->mRTL, isVertical))
     return false; // to next table
 
   for (int32_t i = 0; i < 4; i++) {
     nsGlyphCode ch = aGlyphTable->ElementAt(mThebesContext, oneDevPixel,
-                                            *aFontGroup, uchar, isVertical, i);
+                                            *aFontGroup, uchar, mChar->mRTL,
+                                            isVertical, i);
     chdata[i] = ch;
     if (ch.Exists()) {
       if (!mChar->SetFontFamily(mPresContext, aGlyphTable, ch, aFamily, font,
                                 aFontGroup))
         return false;
 
       textRun[i] = aGlyphTable->MakeTextRun(mThebesContext, oneDevPixel,
                                             *aFontGroup, ch);
@@ -1420,19 +1466,21 @@ nsMathMLChar::StretchInternal(nsPresCont
   aPresContext->DeviceContext()->
     GetMetricsFor(font,
                   mStyleContext->StyleFont()->mLanguage,
                   aPresContext->GetUserFontSet(),
                   aPresContext->GetTextPerfMetrics(),
                   *getter_AddRefs(fm));
   uint32_t len = uint32_t(mData.Length());
   nsAutoPtr<gfxTextRun> textRun;
-  textRun = fm->GetThebesFontGroup()->
-    MakeTextRun(static_cast<const char16_t*>(mData.get()), len, aThebesContext,
-                aPresContext->AppUnitsPerDevPixel(), 0);
+  textRun = MakeTextRunWithDirection(fm->GetThebesFontGroup(),
+                                     static_cast<const char16_t*>(mData.get()),
+                                     len, aThebesContext,
+                                     aPresContext->AppUnitsPerDevPixel(),
+                                     mRTL);
   aDesiredStretchSize = MeasureTextRun(aThebesContext, textRun);
   mGlyphs[0] = textRun;
 
   bool maxWidth = (NS_STRETCH_MAXWIDTH & aStretchHint) != 0;
   if (!maxWidth) {
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
 
@@ -1633,17 +1681,17 @@ nsMathMLChar::Stretch(nsPresContext*    
                       bool                     aRTL)
 {
   NS_ASSERTION(!(aStretchHint &
                  ~(NS_STRETCH_VARIABLE_MASK | NS_STRETCH_LARGEOP |
                    NS_STRETCH_INTEGRAL)),
                "Unexpected stretch flags");
 
   mDraw = DRAW_NORMAL;
-  mMirrored = aRTL && nsMathMLOperators::IsMirrorableOperator(mData);
+  mRTL = aRTL;
   mScaleY = mScaleX = 1.0;
   mDirection = aStretchDirection;
   nsresult rv =
     StretchInternal(aPresContext, aRenderingContext.ThebesContext(), mDirection,
                     aContainerSize, aDesiredStretchSize, aStretchHint);
 
   // Record the metrics
   mBoundingMetrics = aDesiredStretchSize;
@@ -1902,29 +1950,21 @@ nsMathMLChar::Display(nsDisplayListBuild
 }
 
 void
 nsMathMLChar::ApplyTransforms(gfxContext* aThebesContext,
                               int32_t aAppUnitsPerGfxUnit,
                               nsRect &r)
 {
   // apply the transforms
-  if (mMirrored) {
-    nsPoint pt = r.TopRight();
-    aThebesContext->
-      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
-                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
-    aThebesContext->Scale(-mScaleX, mScaleY);
-  } else {
-    nsPoint pt = r.TopLeft();
-    aThebesContext->
-      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
-                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
-    aThebesContext->Scale(mScaleX, mScaleY);
-  }
+  nsPoint pt = r.TopLeft();
+  aThebesContext->
+    Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
+                       NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
+  aThebesContext->Scale(mScaleX, mScaleY);
 
   // update the bounding rectangle.
   r.x = r.y = 0;
   r.width /= mScaleX;
   r.height /= mScaleY;
 }
 
 void
@@ -1958,17 +1998,18 @@ nsMathMLChar::PaintForeground(nsPresCont
 
   switch(mDraw)
   {
     case DRAW_NORMAL:
     case DRAW_VARIANT:
       // draw a single glyph (base size or size variant)
       // XXXfredw verify if mGlyphs[0] is non-null to workaround bug 973322.
       if (mGlyphs[0]) {
-        mGlyphs[0]->Draw(thebesContext, gfxPoint(0.0, mUnscaledAscent),
+        mGlyphs[0]->Draw(thebesContext,
+                         gfxPoint(mRTL ? r.width : 0.0, mUnscaledAscent),
                          DrawMode::GLYPH_FILL, 0, mGlyphs[0]->GetLength(),
                          nullptr, nullptr, nullptr);
       }
       break;
     case DRAW_PARTS: {
       // paint by parts
       if (NS_STRETCH_DIRECTION_VERTICAL == mDirection)
         PaintVertically(aPresContext, thebesContext, r);
diff --git a/layout/mathml/nsMathMLChar.h b/layout/mathml/nsMathMLChar.h
--- a/layout/mathml/nsMathMLChar.h
+++ b/layout/mathml/nsMathMLChar.h
@@ -86,17 +86,17 @@ class nsMathMLChar
 public:
   // constructor and destructor
   nsMathMLChar() {
     MOZ_COUNT_CTOR(nsMathMLChar);
     mStyleContext = nullptr;
     mUnscaledAscent = 0;
     mScaleX = mScaleY = 1.0;
     mDraw = DRAW_NORMAL;
-    mMirrored = false;
+    mRTL = false;
   }
 
   // not a virtual destructor: this class is not intended to be subclassed
   ~nsMathMLChar();
 
   void Display(nsDisplayListBuilder*   aBuilder,
                nsIFrame*               aForFrame,
                const nsDisplayListSet& aLists,
@@ -222,18 +222,17 @@ private:
   // - DRAW_VARIANT: we draw a larger size variant given by mGlyphs[0].
   // - DRAW_PARTS: we assemble several parts given by mGlyphs[0], ... mGlyphs[4]
   // XXXfredw: the MATH table can have any numbers of parts and extenders.
   enum DrawingMethod {
     DRAW_NORMAL, DRAW_VARIANT, DRAW_PARTS
   };
   DrawingMethod mDraw;
 
-  // mMirrored indicates whether the character is mirrored. 
-  bool               mMirrored;
+  bool mRTL;
 
   class StretchEnumContext;
   friend class StretchEnumContext;
 
   // helper methods
   bool
   SetFontFamily(nsPresContext*          aPresContext,
                 const nsGlyphTable*     aGlyphTable,
