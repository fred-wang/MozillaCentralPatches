# HG changeset patch
# Parent b1a5c59fca32b537af763206976c5e512b857da8
# User Frédéric Wang <fred.wang@free.fr>
Bug 945183 - Mirroring large/stretchy operators

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -371,17 +371,18 @@ nsPropertiesTable::ElementAt(gfxContext*
 // An instance of nsOpenTypeTable is associated to one gfxFontEntry that
 // corresponds to an Open Type font with a MATH table. All the glyphs come from
 // the same font and the calls to access size variants and parts are directly
 // forwarded to the gfx code.
 class nsOpenTypeTable MOZ_FINAL : public nsGlyphTable {
 public:
   explicit nsOpenTypeTable(gfxFontEntry* aFontEntry)
     : nsGlyphTable(),
-      mFontEntry(aFontEntry) {
+      mFontEntry(aFontEntry),
+      mRTLCache(false) {
     MOZ_COUNT_CTOR(nsOpenTypeTable);
   }
 
   ~nsOpenTypeTable() {
     MOZ_COUNT_DTOR(nsOpenTypeTable);
   }
 
   virtual nsGlyphCode BigOf(gfxContext* aThebesContext,
@@ -393,40 +394,41 @@ public:
 
   const gfxFontEntry* GetFontEntry() const {
     return mFontEntry;
   }
 
 private:
   nsRefPtr<gfxFontEntry> mFontEntry;
   uint32_t mGlyphID;
+  bool mRTLCache;
 
   void UpdateCache(gfxContext* aThebesContext, nsMathMLChar* aChar);
   virtual nsGlyphCode ElementAt(gfxContext* aThebesContext,
                                 nsMathMLChar* aChar,
                                 uint32_t aPosition) MOZ_OVERRIDE;
 };
 
 void
 nsOpenTypeTable::UpdateCache(gfxContext* aThebesContext, nsMathMLChar* aChar)
 {
   char16_t uchar = aChar->mData[0];
-  if (mCharCache != uchar) {
-    nsGlyphCode glyph =  {{{uchar, 0}}, 0};
+  if (mCharCache != uchar || mRTLCache != aChar->mRTL) {
     nsAutoPtr<gfxTextRun> textRun;
-    textRun = aChar->MakeTextRun(aThebesContext, glyph);
+    textRun = aChar->MakeTextRunWithDirection(aThebesContext);
     const gfxTextRun::CompressedGlyph data = textRun->GetCharacterGlyphs()[0];
     if (data.IsSimpleGlyph()) {
       mGlyphID = data.GetSimpleGlyph();
     } else if (data.GetGlyphCount() == 1) {
       mGlyphID = textRun->GetDetailedGlyphs(0)->mGlyphID;
     } else {
       mGlyphID = 0;
     }
     mCharCache = uchar;
+    mRTLCache = aChar->mRTL;
   }
 }
 
 /* virtual */
 const nsAString&
 nsOpenTypeTable::FontNameFor(const nsGlyphCode& aGlyphCode) const
 {
     NS_ASSERTION(aGlyphCode.IsGlyphID(),
@@ -1137,23 +1139,45 @@ public:
     }
     virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength,
                             Spacing* aSpacing) {
         NS_ERROR("This shouldn't be called because we never enable spacing");
     }
 };
 
 gfxTextRun*
+nsMathMLChar::MakeTextRunWithDirection(gfxContext* aThebesContext)
+{
+  nsRefPtr<gfxFontGroup> newFontGroup;
+  if (mRTL) {
+    gfxFontGroup* fontGroup = mFontMetrics->GetThebesFontGroup();
+    gfxFontStyle fontStyle = *fontGroup->GetStyle();
+    gfxFontFeature settingRTLM;
+    settingRTLM.mTag = TRUETYPE_TAG('r','t','l','m');
+    settingRTLM.mValue = 1;
+    fontStyle.featureSettings.AppendElement(settingRTLM);
+    newFontGroup = fontGroup->Copy(&fontStyle);
+  }
+  if (!newFontGroup) {
+    newFontGroup = mFontMetrics->GetThebesFontGroup();
+  }
+  return newFontGroup->
+    MakeTextRun(mData.get(), mData.Length(), aThebesContext,
+                mFontMetrics->AppUnitsPerDevPixel(),
+                mRTL ? gfxTextRunFactory::TEXT_IS_RTL : 0);
+}
+
+gfxTextRun*
 nsMathMLChar::MakeTextRun(gfxContext*        aThebesContext,
                           const nsGlyphCode& aGlyph)
 {
   if (!aGlyph.IsGlyphID()) {
-    return mFontMetrics->GetThebesFontGroup()->
-      MakeTextRun(aGlyph.code, aGlyph.Length(), aThebesContext,
-                  mFontMetrics->AppUnitsPerDevPixel(), 0);
+     return mFontMetrics->GetThebesFontGroup()->
+       MakeTextRun(aGlyph.code, aGlyph.Length(), aThebesContext,
+                   mFontMetrics->AppUnitsPerDevPixel(), 0);
   }
 
   gfxTextRunFactory::Parameters params = {
     aThebesContext, nullptr, nullptr, nullptr, 0,
     mFontMetrics->AppUnitsPerDevPixel()
   };
   gfxTextRun* textRun = gfxTextRun::Create(&params, 1, mFontMetrics->
                                            GetThebesFontGroup(), 0);
@@ -1931,17 +1955,17 @@ nsMathMLChar::Stretch(nsPresContext*    
                       bool                     aRTL)
 {
   NS_ASSERTION(!(aStretchHint &
                  ~(NS_STRETCH_VARIABLE_MASK | NS_STRETCH_LARGEOP |
                    NS_STRETCH_INTEGRAL)),
                "Unexpected stretch flags");
 
   mDraw = DRAW_NORMAL;
-  mMirrored = aRTL && nsMathMLOperators::IsMirrorableOperator(mData);
+  mRTL = aRTL;
   mScaleY = mScaleX = 1.0;
   mDirection = aStretchDirection;
   nsresult rv =
     StretchInternal(aPresContext, aRenderingContext.ThebesContext(), mDirection,
                     aContainerSize, aDesiredStretchSize, aStretchHint);
 
   aRenderingContext.SetFont(mFontMetrics);
 
@@ -2204,29 +2228,21 @@ nsMathMLChar::Display(nsDisplayListBuild
 }
 
 void
 nsMathMLChar::ApplyTransforms(gfxContext* aThebesContext,
                               int32_t aAppUnitsPerGfxUnit,
                               nsRect &r)
 {
   // apply the transforms
-  if (mMirrored) {
-    nsPoint pt = r.TopRight();
-    aThebesContext->
-      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
-                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
-    aThebesContext->Scale(-mScaleX, mScaleY);
-  } else {
-    nsPoint pt = r.TopLeft();
-    aThebesContext->
-      Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
-                         NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
-    aThebesContext->Scale(mScaleX, mScaleY);
-  }
+  nsPoint pt = r.TopLeft();
+  aThebesContext->
+    Translate(gfxPoint(NSAppUnitsToFloatPixels(pt.x, aAppUnitsPerGfxUnit),
+                       NSAppUnitsToFloatPixels(pt.y, aAppUnitsPerGfxUnit)));
+  aThebesContext->Scale(mScaleX, mScaleY);
 
   // update the bounding rectangle.
   r.x = r.y = 0;
   r.width /= mScaleX;
   r.height /= mScaleY;
 }
 
 void
@@ -2270,25 +2286,22 @@ nsMathMLChar::PaintForeground(nsPresCont
   nsRect r = mRect + aPt;
   ApplyTransforms(thebesContext, aPresContext->AppUnitsPerDevPixel(), r);
 
   switch(mDraw)
   {
     case DRAW_NORMAL:
       {
         // normal drawing if there is nothing special about this char...
-        uint32_t len = uint32_t(mData.Length());
         nsAutoPtr<gfxTextRun> textRun;
-        textRun = mFontMetrics->GetThebesFontGroup()->
-          MakeTextRun(mData.get(), len, thebesContext,
-                      mFontMetrics->AppUnitsPerDevPixel(), 0);
+        textRun = MakeTextRunWithDirection(thebesContext);
         StubPropertyProvider provider;
-        gfxPoint pt(0, mUnscaledAscent);
-        textRun->Draw(thebesContext, pt, DrawMode::GLYPH_FILL, 0, len,
-                      &provider, nullptr, nullptr);
+        gfxPoint pt(mRTL ? mRect.width : 0, mUnscaledAscent);
+        textRun->Draw(thebesContext, pt, DrawMode::GLYPH_FILL, 0,
+                      mData.Length(), &provider, nullptr, nullptr);
       }
       break;
     case DRAW_VARIANT:
       // if there is a glyph of appropriate size, paint that glyph
       DrawGlyph(thebesContext, mGlyphs[0], r.x, r.y + mUnscaledAscent);
       break;
     case DRAW_PARTS:
       // paint by parts
diff --git a/layout/mathml/nsMathMLChar.h b/layout/mathml/nsMathMLChar.h
--- a/layout/mathml/nsMathMLChar.h
+++ b/layout/mathml/nsMathMLChar.h
@@ -86,17 +86,17 @@ class nsMathMLChar
 public:
   // constructor and destructor
   nsMathMLChar() {
     MOZ_COUNT_CTOR(nsMathMLChar);
     mStyleContext = nullptr;
     mUnscaledAscent = 0;
     mScaleX = mScaleY = 1.0;
     mDraw = DRAW_NORMAL;
-    mMirrored = false;
+    mRTL = false;
   }
 
   // not a virtual destructor: this class is not intended to be subclassed
   ~nsMathMLChar();
 
   void Display(nsDisplayListBuilder*   aBuilder,
                nsIFrame*               aForFrame,
                const nsDisplayListSet& aLists,
@@ -228,31 +228,33 @@ private:
   // - DRAW_VARIANT: we draw a larger size variant given by mGlyphs[0].
   // - DRAW_PARTS: we assemble several parts given by mGlyphs[0], ... mGlyphs[4]
   // XXXfredw: the MATH table can have any numbers of parts and extenders.
   typedef enum {
     DRAW_NORMAL, DRAW_VARIANT, DRAW_PARTS
   } DrawingMethod;
   DrawingMethod mDraw;
 
-  // mMirrored indicates whether the character is mirrored. 
-  bool               mMirrored;
+  bool mRTL;
 
   class StretchEnumContext;
   friend class StretchEnumContext;
 
   // helper methods
   bool
   SetFontFamily(nsPresContext*      aPresContext,
                 const nsGlyphTable* aGlyphTable,
                 const nsGlyphCode&  aGlyphCode,
                 const nsAString&    aDefaultFamily,
                 nsFont&             aFont);
 
   gfxTextRun*
+  MakeTextRunWithDirection(gfxContext* aThebesContext);
+
+  gfxTextRun*
   MakeTextRun(gfxContext* aThebesContext, const nsGlyphCode& aGlyph);
 
   nsBoundingMetrics
   MeasureGlyph(gfxContext*        aThebesContext,
                const nsGlyphCode& aGlyphCode, bool aLargeOp);
 
   void
   DrawGlyph(gfxContext*         aThebesContext,
