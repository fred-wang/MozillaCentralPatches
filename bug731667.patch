diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5752,16 +5752,23 @@ nsBlockFrame::DeleteNextInFlowChild(nsPr
       nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
     }
 #endif
     DoRemoveFrame(aNextInFlow,
         aDeletingEmptyFrames ? FRAMES_ARE_EMPTY : 0);
   }
 }
 
+const nsStyleText*
+nsBlockFrame::InitializeStyleTextInLine()
+{
+  // Return the pointer to an unmodified style text
+  return GetStyleText();
+}
+
 ////////////////////////////////////////////////////////////////////////
 // Float support
 
 nsRect
 nsBlockFrame::AdjustFloatAvailableSpace(nsBlockReflowState& aState,
                                         const nsRect& aFloatAvailableSpace,
                                         nsIFrame* aFloatFrame)
 {
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -272,16 +272,23 @@ public:
                               nsIFrame*      aChild,
                               bool           aForceNormal = false);
 
   virtual void DeleteNextInFlowChild(nsPresContext* aPresContext,
                                      nsIFrame*      aNextInFlow,
                                      bool           aDeletingEmptyFrames);
 
   /**
+    * This method is used by the nsLineLayout class, and can be overriden so
+    * that children of the nsBlockFrame class can specify their own special
+    * modifications to their style text, and have it returned to the caller.
+    */
+  virtual const nsStyleText* InitializeStyleTextInLine();
+
+  /**
    * Determines whether the collapsed margin carried out of the last
    * line includes the margin-top of a line with clearance (in which
    * case we must avoid collapsing that margin with our bottom margin)
    */
   bool CheckForCollapsedBottomMarginFromClearanceLine();
 
   static nsresult GetCurrentLine(nsBlockReflowState *aState, nsLineBox **aOutCurrentLine);
 
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -67,17 +67,23 @@ nsLineLayout::nsLineLayout(nsPresContext
     mTextIndent(0)
 {
   NS_ASSERTION(aFloatManager || aOuterReflowState->frame->GetType() ==
                                   nsGkAtoms::letterFrame,
                "float manager should be present");
   MOZ_COUNT_CTOR(nsLineLayout);
 
   // Stash away some style data that we need
-  mStyleText = aOuterReflowState->frame->GetStyleText();
+  nsBlockFrame* blockFrame = do_QueryFrame(aOuterReflowState->frame);
+
+  if (blockFrame)
+    mStyleText = blockFrame->InitializeStyleTextInLine();
+  else
+    mStyleText = aOuterReflowState->frame->GetStyleText();
+
   mLineNumber = 0;
   mFlags = 0; // default all flags to false except those that follow here...
   mTotalPlacedFrames = 0;
   mTopEdge = 0;
   mTrimmableWidth = 0;
 
   mInflationMinFontSize =
     nsLayoutUtils::InflationMinFontSizeFor(aOuterReflowState->frame);
diff --git a/layout/mathml/mathml.css b/layout/mathml/mathml.css
--- a/layout/mathml/mathml.css
+++ b/layout/mathml/mathml.css
@@ -243,63 +243,16 @@ mtd {
 }
 
 /* Hide the label because mlabeledtr is not supported yet (bug 356870). This
    rule can be overriden by users. */
 mlabeledtr > mtd:first-child {
     display: none;
 }
 
-/***********************/
-/* -- mtd: columnalign */
-
-mtd[_moz-math-columnalign="left"],
-mtd[columnalign="left"] {
-  text-align: left;
-}
-mtd[_moz-math-columnalign="right"],
-mtd[columnalign="right"] {
-  text-align: right;
-}
-mtd[_moz-math-columnalign="center"],
-mtd[columnalign="center"] {
-  text-align: -moz-center;
-}
-
-/*************************/
-/* -- mtr, mtd: rowalign */
-
-mtr[_moz-math-rowalign="top"],
-mtr[rowalign="top"],
-mtd[rowalign="top"] {
-  vertical-align: top;
-}
-mtr[_moz-math-rowalign="bottom"],
-mtr[rowalign="bottom"],
-mtd[rowalign="bottom"] {
-  vertical-align: bottom;
-}
-mtr[_moz-math-rowalign="center"],
-mtr[rowalign="center"],
-mtd[rowalign="center"] {
-  vertical-align: middle;
-}
-mtr[_moz-math-rowalign="baseline"],
-mtr[rowalign="baseline"],
-mtd[rowalign="baseline"] {
-  vertical-align: baseline;
-}
-/* -- not yet supported --
-mtr[_moz-math-rowalign="axis"],
-mtr[rowalign="axis"],
-mtd[rowalign="axis"] {
-  vertical-align: mathline;
-}
-*/
-
 /**********************************************************************/
 /* rules to achieve the default spacing between cells. The back-end code
    will set the internal attributes depending on the cell's position.
    These rules are hard-coded, the comments indicate what would be
    desirable if the style data could be changed on the fly to pick
    the values that users may set with the attributes of <mtable> */
 mtd {
   padding-right: 0.4em;  /* half of columnspacing[colindex] */
@@ -333,42 +286,16 @@ mtable[frame="solid"] > mtr > mtd:first-
 mtable[frame="dashed"] > mtr > mtd:first-child {
   padding-left: 0.4em; /* framespacing.left */
 }
 mtable[frame="solid"] > mtr > mtd:last-child,
 mtable[frame="dashed"] > mtr > mtd:last-child {
   padding-right: 0.4em; /* framespacing.right */
 }
 
-/**********************************************************************/
-/* internal settings to support 'rowlines' and 'columnlines'. To
-   achieve the recommended behavior, the back-end code will avoid setting
-   unsuitable rules on the cells on the first row and the first column.
-   In general, however, authors can use the 'border' property of CSS to
-   achieve varying effects down to the level of the table cell. */
-mtr[_moz-math-rowline="none"] > mtd {
-  border-top: none;
-}
-mtr[_moz-math-rowline="solid"] > mtd {
-  border-top: solid thin;
-}
-mtr[_moz-math-rowline="dashed"] > mtd {
-  border-top: dashed thin;
-}
-mtd[_moz-math-columnline="none"] {
-  border-left: none;
-}
-mtd[_moz-math-columnline="solid"] {
-  border-left: solid thin;
-}
-mtd[_moz-math-columnline="dashed"] {
-  border-left: dashed thin;
-}
-
-
 /**************************************************************************/
 /* Style used for stretchy symbols *must* be normal to avoid misaligments */
 /* By leaving the font-family empty, the MathML engine will use the value
    provided by the mathfont-family property in the mathfont.properties file
    or the value of the user's pref("font.mathfont-family", "...").
 
    Authors can make elements on a document to be stretched with different
    fonts, e.g.,
diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -6,24 +6,27 @@
 #include "nsCOMPtr.h"
 #include "nsFrame.h"
 #include "nsBlockFrame.h"
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsStyleConsts.h"
 #include "nsINameSpaceManager.h"
 #include "nsRenderingContext.h"
+#include "nsCSSRendering.h"
 
 #include "nsTArray.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsTableOuterFrame.h"
 #include "nsTableFrame.h"
 #include "nsTableCellFrame.h"
 #include "celldata.h"
 
+#include "nsStyleConsts.h"
+
 #include "nsMathMLmtableFrame.h"
 
 using namespace mozilla;
 
 //
 // <mtable> -- table or matrix - implementation
 //
 
@@ -61,53 +64,203 @@ SplitString(nsString&             aStrin
   }
 }
 
 struct nsValueList
 {
   nsString             mData;
   nsTArray<PRUnichar*> mArray;
 
-  nsValueList(nsString& aData) {
+  nsValueList(const nsString& aData) {
     mData.Assign(aData);
     SplitString(mData, mArray);
   }
 };
 
+// Functions that parse string attributes into PRInt8 style values are in this
+// format.
+typedef PRInt8 (*ParseFunction) (const nsString&);
+
+static nsTArray<PRInt8>* ExtractStyleValues(const nsString aString,
+                                            ParseFunction aParser)
+{
+    nsString stringCopy(aString);
+
+    // We use all of this code because we must split the string up by
+    // space-delimited pieces. Each piece is then converted and appended to the
+    // style array.
+    nsTArray<PRInt8>* styleArray = new nsTArray<PRInt8>();
+
+    static const PRUnichar kNullCh = PRUnichar('\0');
+
+    stringCopy.Append(kNullCh);  // put an extra null at the end
+
+    PRUnichar* start = stringCopy.BeginWriting();
+    PRUnichar* end   = start;
+
+    while (kNullCh != *start) {
+      while ((kNullCh != *start) && nsCRT::IsAsciiSpace(*start)) {  // skip leading space
+        start++;
+      }
+      end = start;
+
+      while ((kNullCh != *end) && (false == nsCRT::IsAsciiSpace(*end))) { // look for space or end
+        end++;
+      }
+      *end = kNullCh; // end string here
+
+      if (start < end) {
+        nsString stringPiece(start);
+        PRInt8 styleValue = aParser(stringPiece); // Parse the value
+        styleArray->AppendElement(styleValue);
+      }
+
+      start = ++end;
+    }
+    return styleArray;
+}
+
+static 
+PRInt8 ParseRowAlignItem(const nsString& aString)
+{
+  if (aString.EqualsLiteral("top")) {
+    return NS_STYLE_VERTICAL_ALIGN_TOP;
+  }
+  if (aString.EqualsLiteral("bottom")) {
+    return NS_STYLE_VERTICAL_ALIGN_BOTTOM;
+  }
+  if (aString.EqualsLiteral("center")) {
+    return NS_STYLE_VERTICAL_ALIGN_MIDDLE;
+  }
+  // TODO Bug 768817: Implement "axis" rowalign for <mtable> cells.
+  //if (aString.EqualsLiteral("axis")) {
+  //  return NS_STYLE_VERTICAL_ALIGN_AXIS;
+  //}
+
+  // default value
+  return NS_STYLE_VERTICAL_ALIGN_BASELINE;
+}
+
+static 
+nsTArray<PRInt8>* ParseRowAlignItemList(const nsString& aString)
+{
+  nsTArray<PRInt8>* alignmentValues = ExtractStyleValues(aString, 
+                                                         ParseRowAlignItem);
+  return alignmentValues;
+}
+
+static 
+PRInt8 ParseColumnAlignItem(const nsString& aString)
+{
+  if (aString.EqualsLiteral("left")) {
+    return NS_STYLE_TEXT_ALIGN_LEFT;
+  }
+  if (aString.EqualsLiteral("right")) {
+    return NS_STYLE_TEXT_ALIGN_RIGHT;
+  }
+
+  // default value
+  return NS_STYLE_TEXT_ALIGN_CENTER;
+}
+
+static 
+nsTArray<PRInt8>* ParseColumnAlignItemList(const nsString& aString)
+{
+  nsTArray<PRInt8>* alignmentValues = ExtractStyleValues(aString,
+                                        ParseColumnAlignItem);
+  return alignmentValues;
+}
+
+static 
+PRInt8 ParseLinesItem(const nsString& aString)
+{
+  if (aString.EqualsLiteral("solid")) {
+    return NS_STYLE_BORDER_STYLE_SOLID;
+  }
+  if (aString.EqualsLiteral("dashed")) {
+    return NS_STYLE_BORDER_STYLE_DASHED;
+  }
+
+  // default value
+  return NS_STYLE_BORDER_STYLE_NONE;
+}
+
+static 
+nsTArray<PRInt8>* ParseLinesItemList(const nsString& aString)
+{
+ nsTArray<PRInt8>* lineList = ExtractStyleValues(aString,
+                                ParseLinesItem);
+  return lineList;
+}
+
 // Each rowalign='top bottom' or columnalign='left right center' (from
 // <mtable> or <mtr>) is split once (lazily) into a nsValueList which is
 // stored in the property table. Row/Cell frames query the property table
 // to see what values apply to them.
 
 // XXX See bug 69409 - MathML attributes are not mapped to style.
 
 static void
 DestroyValueList(void* aPropertyValue)
 {
   delete static_cast<nsValueList*>(aPropertyValue);
 }
 
-NS_DECLARE_FRAME_PROPERTY(RowAlignProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(RowLinesProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(ColumnAlignProperty, DestroyValueList)
-NS_DECLARE_FRAME_PROPERTY(ColumnLinesProperty, DestroyValueList)
+static void
+DestroyStylePropertyList(void* aPropertyValue)
+{
+  delete static_cast<nsTArray<PRInt8>*>(aPropertyValue);
+}
+
+NS_DECLARE_FRAME_PROPERTY(RowAlignProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(RowLinesProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(ColumnAlignProperty, DestroyStylePropertyList)
+NS_DECLARE_FRAME_PROPERTY(ColumnLinesProperty, DestroyStylePropertyList)
 
 static const FramePropertyDescriptor*
 AttributeToProperty(nsIAtom* aAttribute)
 {
   if (aAttribute == nsGkAtoms::rowalign_)
     return RowAlignProperty();
   if (aAttribute == nsGkAtoms::rowlines_)
     return RowLinesProperty();
   if (aAttribute == nsGkAtoms::columnalign_)
     return ColumnAlignProperty();
   NS_ASSERTION(aAttribute == nsGkAtoms::columnlines_, "Invalid attribute");
   return ColumnLinesProperty();
 }
 
+/* This method looks for a proprety that applies to a cell, but it looks
+ * recursively because some cell properties can come from the cell, a row,
+ * a table, etc. This function searches through the heirarchy for a property
+ * and returns its value. The function stops searching after checking a <mtable>
+ * frame.
+ */
+static void* 
+FindCellProperty(const nsIFrame* aCellFrame, 
+                 const FramePropertyDescriptor* aFrameProperty)
+{
+  const nsIFrame* currentFrame = aCellFrame;
+  void* propertyData = nsnull;
+
+  while(currentFrame) {
+    FrameProperties props = currentFrame->Properties();
+    propertyData = props.Get(aFrameProperty);
+    bool frameIsTable = 
+         (currentFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_TABLE);
+
+    if (propertyData || frameIsTable)      
+      currentFrame = nsnull; // A null frame pointer exits the loop
+    else
+      currentFrame = currentFrame->GetParent(); // Go to the parent frame
+  }
+
+  return propertyData;
+}
+
 static PRUnichar*
 GetValueAt(nsIFrame*                      aTableOrRowFrame,
            const FramePropertyDescriptor* aProperty,
            nsIAtom*                       aAttribute,
            PRInt32                        aRowOrColIndex)
 {
   FrameProperties props = aTableOrRowFrame->Properties();
   nsValueList* valueList = static_cast<nsValueList*>(props.Get(aProperty));
@@ -124,16 +277,80 @@ GetValueAt(nsIFrame*                    
     props.Set(aProperty, valueList);
   }
   PRInt32 count = valueList->mArray.Length();
   return (aRowOrColIndex < count)
          ? valueList->mArray[aRowOrColIndex]
          : valueList->mArray[count-1];
 }
 
+/**
+ * A variant of the nsDisplayBorder contains special code to render a border
+ * around a nsMathMLmtdFrame based on the rowline and columnline properties
+ * set on the cell frame.
+ */
+class nsDisplaymtdBorder : public nsDisplayBorder {
+public:
+  nsDisplaymtdBorder(nsDisplayListBuilder* aBuilder, nsMathMLmtdFrame* aFrame) 
+    : nsDisplayBorder(aBuilder, aFrame)
+  {
+  }
+
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx)
+  {
+    PRInt32 rowIndex;
+    PRInt32 columnIndex;
+    static_cast<nsTableCellFrame*>(mFrame)->GetCellIndexes(rowIndex, columnIndex);
+
+    nsStyleBorder styleBorder(mFrame->PresContext());
+    nscoord borderWidth = (mFrame->PresContext()->GetBorderWidthTable())
+                            [NS_STYLE_BORDER_WIDTH_THIN];
+
+    nsTArray<PRInt8>* rowLinesList = 
+      static_cast<nsTArray<PRInt8>*>(FindCellProperty(mFrame, RowLinesProperty()));
+
+    nsTArray<PRInt8>* columnLinesList =
+      static_cast<nsTArray<PRInt8>*>(FindCellProperty(mFrame, ColumnLinesProperty()));
+
+    // We don't place a row line on top of the first row
+    if (rowIndex > 0 && rowLinesList) {
+      PRUint32 listLength = rowLinesList->Length();
+      if (rowIndex < listLength) {
+        styleBorder.SetBorderStyle(NS_SIDE_TOP,
+                      rowLinesList->ElementAt(rowIndex - 1));
+      } else {
+        styleBorder.SetBorderStyle(NS_SIDE_TOP,
+                      rowLinesList->ElementAt(listLength - 1));
+      }
+      styleBorder.SetBorderWidth(NS_SIDE_TOP, borderWidth);
+    }
+
+    // We don't place a column line on the left of the first column.
+    if (columnIndex > 0 && columnLinesList) {
+      PRUint32 listLength = columnLinesList->Length();
+      if (columnIndex < listLength) {
+        styleBorder.SetBorderStyle(NS_SIDE_LEFT, 
+                      columnLinesList->ElementAt(columnIndex - 1));
+      } else {
+        styleBorder.SetBorderStyle(NS_SIDE_LEFT,
+                      columnLinesList->ElementAt(listLength - 1));
+      }
+      styleBorder.SetBorderWidth(NS_SIDE_LEFT, borderWidth);
+    }
+
+    nsPoint offset = ToReferenceFrame();
+    nsCSSRendering::PaintBorderWithStyleBorder(mFrame->PresContext(), *aCtx, 
+                                               mFrame, mVisibleRect,
+                                               nsRect(offset, mFrame->GetSize()),
+                                               styleBorder,
+                                               mFrame->GetStyleContext(),
+                                               mFrame->GetSkipSides());
+  }
+};
+
 #ifdef DEBUG
 static bool
 IsTable(PRUint8 aDisplay)
 {
   if ((aDisplay == NS_STYLE_DISPLAY_TABLE) ||
       (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE))
     return true;
   return false;
@@ -152,97 +369,171 @@ IsTable(PRUint8 aDisplay)
 // rowalign, rowlines, XXX need rowspacing too
 static void
 MapRowAttributesIntoCSS(nsIFrame* aTableFrame,
                         nsIFrame* aRowFrame)
 {
   DEBUG_VERIFY_THAT_FRAME_IS_TABLE(aTableFrame);
   DEBUG_VERIFY_THAT_FRAME_IS(aRowFrame, TABLE_ROW);
   PRInt32 rowIndex = ((nsTableRowFrame*)aRowFrame)->GetRowIndex();
+  nsAutoString tableAttr, rowAttr, cellAttr;
+
+  // TODO Bug 768819: Also parse row attributes on <mstyle>/<mtable> frames.
+
+  // Table rowalign parsing
+  nsIContent* tableContent = aTableFrame->GetContent();
+
+  nsMathMLFrame::GetAttribute(tableContent, nsnull, nsGkAtoms::rowalign_,
+                                tableAttr);
+
+  if (!tableAttr.IsEmpty()) {
+    const PRUnichar whitespace = ' ';
+    
+    // Remove leading and trailing whitespace to ensure that spaces are found
+    // only within the string.
+    tableAttr.CompressWhitespace(true, true);
+
+    // If we have a single-valued attribute.
+    nsTArray<PRInt8>* alignmentList = ExtractStyleValues(tableAttr,
+                                        ParseRowAlignItem);
+    FrameProperties props = aTableFrame->Properties();
+    props.Set(RowAlignProperty(), alignmentList);      
+  }
+
+  // Row rowalign parsing
   nsIContent* rowContent = aRowFrame->GetContent();
-  PRUnichar* attr;
 
-  // see if the rowalign attribute is not already set
-  if (!rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::rowalign_) &&
-      !rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowalign_)) {
-    // see if the rowalign attribute was specified on the table
-    attr = GetValueAt(aTableFrame, RowAlignProperty(),
-                      nsGkAtoms::rowalign_, rowIndex);
-    if (attr) {
-      // set our special _moz attribute on the row without notifying a reflow
-      rowContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowalign_,
-                          nsDependentString(attr), false);
+  nsMathMLFrame::GetAttribute(rowContent, nsnull, nsGkAtoms::rowalign_,
+                              rowAttr);
+
+  if (!rowAttr.IsEmpty()) {
+    nsTArray<PRInt8>* alignmentList = ExtractStyleValues(rowAttr,
+                                        ParseRowAlignItem);
+    FrameProperties props = aRowFrame->Properties();
+    props.Set(RowAlignProperty(), alignmentList);
+  }
+
+  // Cell rowalign parsing
+  nsIFrame* cellFrame = aRowFrame->GetFirstPrincipalChild();
+
+  while (cellFrame) {
+
+    nsIContent* cellContent = cellFrame->GetContent();
+
+    nsMathMLFrame::GetAttribute(cellContent, nsnull, nsGkAtoms::rowalign_,
+                                cellAttr);
+
+    if (!cellAttr.IsEmpty()) {
+      nsTArray<PRInt8>* alignmentList = ExtractStyleValues(cellAttr,
+                                          ParseRowAlignItem);
+      FrameProperties props = cellFrame->Properties();
+      props.Set(RowAlignProperty(), alignmentList);
     }
+
+    // Move to the next cell
+    cellFrame = cellFrame->GetNextSibling();
   }
 
   // if we are not on the first row, see if |rowlines| was specified on the table.
   // Note that we pass 'rowIndex-1' because the CSS rule in mathml.css is associated
   // to 'border-top', and it is as if we draw the line on behalf of the previous cell.
   // This way of doing so allows us to handle selective lines, [row]\hline[row][row]',
   // and cases of spanning cells without further complications.
-  if (rowIndex > 0 &&
-      !rowContent->HasAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowline_)) {
-    attr = GetValueAt(aTableFrame, RowLinesProperty(),
-                      nsGkAtoms::rowlines_, rowIndex-1);
-    if (attr) {
-      // set our special _moz attribute on the row without notifying a reflow
-      rowContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_rowline_,
-                          nsDependentString(attr), false);
+  if (rowIndex > 0) {
+    nsMathMLFrame::GetAttribute(tableContent, nsnull, nsGkAtoms::rowlines_,
+                                tableAttr);
+
+    if (!tableAttr.IsEmpty()) {
+      nsTArray<PRInt8>* lineList = ExtractStyleValues(tableAttr,
+                                    ParseLinesItem);
+
+      if (lineList) {
+        FrameProperties props = aRowFrame->Properties();
+        props.Set(RowLinesProperty(), lineList);
+      }
     }
   }
 }
 
 // map attributes that depend on the index of the column:
 // columnalign, columnlines, XXX need columnwidth and columnspacing too
 static void
 MapColAttributesIntoCSS(nsIFrame* aTableFrame,
                         nsIFrame* aRowFrame,
                         nsIFrame* aCellFrame)
 {
   DEBUG_VERIFY_THAT_FRAME_IS_TABLE(aTableFrame);
   DEBUG_VERIFY_THAT_FRAME_IS(aRowFrame, TABLE_ROW);
   DEBUG_VERIFY_THAT_FRAME_IS(aCellFrame, TABLE_CELL);
   PRInt32 rowIndex, colIndex;
   ((nsTableCellFrame*)aCellFrame)->GetCellIndexes(rowIndex, colIndex);
+  nsAutoString tableAttr, rowAttr, cellAttr;
+
+  // TODO Bug 768819: Also parse column attributes on <mstyle>/<mtable> frames.
+
+  // Table columnalign parsing
+  nsIContent* tableContent = aTableFrame->GetContent();
+
+  nsMathMLFrame::GetAttribute(tableContent, nsnull, nsGkAtoms::columnalign_,
+                                tableAttr);
+  if (!tableAttr.IsEmpty()) {
+    const PRUnichar whitespace = ' ';
+    
+    // Remove leading and trailing whitespace to ensure that spaces are found
+    // only within the string.
+    tableAttr.CompressWhitespace(true, true);
+    
+    nsTArray<PRInt8>* alignmentList = ExtractStyleValues(tableAttr,
+                                        ParseColumnAlignItem);
+    FrameProperties props = aTableFrame->Properties();
+    props.Set(ColumnAlignProperty(), alignmentList);
+  }
+
+   // Row columnalign parsing
+  nsIContent* rowContent = aRowFrame->GetContent();
+
+  nsMathMLFrame::GetAttribute(rowContent, nsnull, nsGkAtoms::columnalign_,
+                              rowAttr);
+
+  if (!rowAttr.IsEmpty()) {
+    nsTArray<PRInt8>* alignmentList = ExtractStyleValues(rowAttr,
+                                        ParseColumnAlignItem);
+    FrameProperties props = aRowFrame->Properties();
+    props.Set(ColumnAlignProperty(), alignmentList);
+  }
+
+  // Cell columnalign parsing
   nsIContent* cellContent = aCellFrame->GetContent();
-  PRUnichar* attr;
 
-  // see if the columnalign attribute is not already set
-  if (!cellContent->HasAttr(kNameSpaceID_None, nsGkAtoms::columnalign_) &&
-      !cellContent->HasAttr(kNameSpaceID_None,
-                            nsGkAtoms::_moz_math_columnalign_)) {
-    // see if the columnalign attribute was specified on the row
-    attr = GetValueAt(aRowFrame, ColumnAlignProperty(),
-                      nsGkAtoms::columnalign_, colIndex);
-    if (!attr) {
-      // see if the columnalign attribute was specified on the table
-      attr = GetValueAt(aTableFrame, ColumnAlignProperty(),
-                        nsGkAtoms::columnalign_, colIndex);
-    }
-    if (attr) {
-      // set our special _moz attribute without notifying a reflow
-      cellContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnalign_,
-                           nsDependentString(attr), false);
-    }
+  nsMathMLFrame::GetAttribute(cellContent, nsnull, nsGkAtoms::columnalign_,
+                              cellAttr);
+
+  if (!cellAttr.IsEmpty()) {
+    nsTArray<PRInt8>* alignmentList = ExtractStyleValues(cellAttr,
+                                        ParseColumnAlignItem);
+    FrameProperties props = aCellFrame->Properties();
+    props.Set(ColumnAlignProperty(), alignmentList);
   }
 
   // if we are not on the first column, see if |columnlines| was specified on
   // the table. Note that we pass 'colIndex-1' because the CSS rule in mathml.css
   // is associated to 'border-left', and it is as if we draw the line on behalf
   // of the previous cell. This way of doing so allows us to handle selective lines,
   // e.g., 'r|cl', and cases of spanning cells without further complications.
-  if (colIndex > 0 &&
-      !cellContent->HasAttr(kNameSpaceID_None,
-                            nsGkAtoms::_moz_math_columnline_)) {
-    attr = GetValueAt(aTableFrame, ColumnLinesProperty(),
-                      nsGkAtoms::columnlines_, colIndex-1);
-    if (attr) {
-      // set our special _moz attribute without notifying a reflow
-      cellContent->SetAttr(kNameSpaceID_None, nsGkAtoms::_moz_math_columnline_,
-                           nsDependentString(attr), false);
+  if (colIndex > 0) {
+    nsMathMLFrame::GetAttribute(tableContent, nsnull, nsGkAtoms::columnlines_,
+                                tableAttr);
+
+    if (!tableAttr.IsEmpty()) {
+      nsTArray<PRInt8>* lineList = ExtractStyleValues(tableAttr,
+                                    ParseLinesItem);
+      if (lineList) {
+        FrameProperties props = aRowFrame->Properties();
+        props.Set(ColumnLinesProperty(), lineList);
+      }
     }
   }
 }
 
 // map all attribues within a table -- requires the indices of rows and cells.
 // so it can only happen after they are made ready by the table base class.
 static void
 MapAllAttributesIntoCSS(nsIFrame* aTableFrame)
@@ -830,16 +1121,51 @@ nsMathMLmtdFrame::AttributeChanged(PRInt
     if (aAttribute == nsGkAtoms::columnspan_)
       aAttribute = nsGkAtoms::colspan;
     return nsTableCellFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
   }
 
   return NS_OK;
 }
 
+PRUint8 
+nsMathMLmtdFrame::GetVerticalAlign() const
+{
+  // Make baseline alignment the default in case no alignment was
+  // specified.
+  PRUint8 alignment = NS_STYLE_VERTICAL_ALIGN_BASELINE;
+
+  nsTArray<PRInt8>* alignmentList = static_cast<nsTArray<PRInt8>*>(
+                                    FindCellProperty(this, RowAlignProperty()));
+
+  if (alignmentList) {
+    PRInt32 rowIndex;
+    GetRowIndex(rowIndex);
+
+    // Cast the length to unsigned to prevent warnings
+    if (rowIndex < (PRInt32)alignmentList->Length())
+      alignment = alignmentList->ElementAt(rowIndex);
+    else
+      alignment = alignmentList->ElementAt(alignmentList->Length() - 1);
+  }
+
+  return alignment;
+}
+
+nsresult
+nsMathMLmtdFrame::ProcessBorders(nsTableFrame* aFrame,
+                                 nsDisplayListBuilder* aBuilder,
+                                 const nsDisplayListSet& aLists)
+{
+  nsresult rv;
+  rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
+                                    nsDisplaymtdBorder(aBuilder, this));
+
+  return rv;
+}
 // --------
 // implementation of nsMathMLmtdInnerFrame
 
 NS_QUERYFRAME_HEAD(nsMathMLmtdInnerFrame)
   NS_QUERYFRAME_ENTRY(nsIMathMLFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrame)
 
 nsIFrame*
@@ -862,8 +1188,34 @@ nsMathMLmtdInnerFrame::Reflow(nsPresCont
 {
   // Let the base class do the reflow
   nsresult rv = nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
 
   // more about <maligngroup/> and <malignmark/> later
   // ...
   return rv;
 }
+
+const nsStyleText* nsMathMLmtdInnerFrame::InitializeStyleTextInLine()
+{
+  nsStyleText* styleText = const_cast<nsStyleText*>(GetStyleText());
+
+  // Set the default alignment in case nothing was specified
+  PRUint8 alignment = NS_STYLE_TEXT_ALIGN_CENTER;
+
+  nsTArray<PRInt8>* alignmentList = static_cast<nsTArray<PRInt8>*>(
+                                 FindCellProperty(this, ColumnAlignProperty()));
+
+  if (alignmentList) {
+    nsMathMLmtdFrame* cellFrame = do_QueryFrame(GetParent());
+    PRInt32 columnIndex;
+    cellFrame->GetColIndex(columnIndex);
+
+    // Cast the length to unsigned to prevent warnings.
+    if (columnIndex < (PRInt32)alignmentList->Length())
+      alignment = alignmentList->ElementAt(columnIndex);
+    else
+      alignment = alignmentList->ElementAt(alignmentList->Length() - 1);
+  }
+
+  styleText->mTextAlign = alignment;
+  return const_cast<nsStyleText*>(styleText);
+}
diff --git a/layout/mathml/nsMathMLmtableFrame.h b/layout/mathml/nsMathMLmtableFrame.h
--- a/layout/mathml/nsMathMLmtableFrame.h
+++ b/layout/mathml/nsMathMLmtableFrame.h
@@ -43,17 +43,17 @@ public:
   Reflow(nsPresContext*          aPresContext,
          nsHTMLReflowMetrics&     aDesiredSize,
          const nsHTMLReflowState& aReflowState,
          nsReflowStatus&          aStatus);
 
   NS_IMETHOD
   AttributeChanged(PRInt32  aNameSpaceID,
                    nsIAtom* aAttribute,
-                   PRInt32  aModType);
+                   PRInt32  aModType);  
 
   virtual bool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsTableOuterFrame::IsFrameOfType(aFlags & ~(nsIFrame::eMathML));
   }
 
 protected:
   nsMathMLmtableOuterFrame(nsStyleContext* aContext) : nsTableOuterFrame(aContext) {}
@@ -200,16 +200,20 @@ public:
 
   // overloaded nsTableCellFrame methods
 
   NS_IMETHOD
   AttributeChanged(PRInt32  aNameSpaceID,
                    nsIAtom* aAttribute,
                    PRInt32  aModType);
 
+  virtual PRUint8 GetVerticalAlign() const;
+  virtual nsresult ProcessBorders(nsTableFrame* aFrame,
+                                  nsDisplayListBuilder* aBuilder,
+                                  const nsDisplayListSet& aLists);
   virtual PRInt32 GetRowSpan();
   virtual PRInt32 GetColSpan();
   virtual bool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsTableCellFrame::IsFrameOfType(aFlags & ~(nsIFrame::eMathML));
   }
 
 protected:
@@ -247,16 +251,18 @@ public:
          nsReflowStatus&          aStatus);
 
   virtual bool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsBlockFrame::IsFrameOfType(aFlags &
       ~(nsIFrame::eMathML | nsIFrame::eExcludesIgnorableWhitespace));
   }
 
+  virtual const nsStyleText* InitializeStyleTextInLine();
+
 protected:
   nsMathMLmtdInnerFrame(nsStyleContext* aContext) : nsBlockFrame(aContext) {}
   virtual ~nsMathMLmtdInnerFrame();
 
   virtual int GetSkipSides() const { return 0; }
 };  // class nsMathMLmtdInnerFrame
 
 #endif /* nsMathMLmtableFrame_h___ */
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -348,16 +348,35 @@ nsTableCellFrame::PaintCellBackground(ns
                                       PRUint32 aFlags)
 {
   if (!GetStyleVisibility()->IsVisible())
     return;
 
   PaintBackground(aRenderingContext, aDirtyRect, aPt, aFlags);
 }
 
+nsresult
+nsTableCellFrame::ProcessBorders(nsTableFrame* aFrame,
+                                 nsDisplayListBuilder* aBuilder,
+                                 const nsDisplayListSet& aLists)
+{
+  nsresult rv = NS_OK;
+  PRInt32 emptyCellStyle = GetContentEmpty() && !aFrame->IsBorderCollapse() ?
+                                GetStyleTableBorder()->mEmptyCells
+                                : NS_STYLE_TABLE_EMPTY_CELLS_SHOW;
+  const nsStyleBorder* borderStyle = GetStyleBorder();
+  if (!aFrame->IsBorderCollapse() && borderStyle->HasBorder() &&
+      emptyCellStyle == NS_STYLE_TABLE_EMPTY_CELLS_SHOW) {
+    rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
+                                      nsDisplayBorder(aBuilder, this));
+  }
+
+  return rv;
+}
+
 class nsDisplayTableCellBackground : public nsDisplayTableItem {
 public:
   nsDisplayTableCellBackground(nsDisplayListBuilder* aBuilder,
                                nsTableCellFrame* aFrame) :
     nsDisplayTableItem(aBuilder, aFrame) {
     MOZ_COUNT_CTOR(nsDisplayTableCellBackground);
   }
 #ifdef NS_BUILD_REFCNT_LOGGING
@@ -449,24 +468,20 @@ nsTableCellFrame::BuildDisplayList(nsDis
       }
     
       // display inset box-shadows if we need to.
       if (hasBoxShadow) {
         nsresult rv = aLists.BorderBackground()->AppendNewToTop(
             new (aBuilder) nsDisplayBoxShadowInner(aBuilder, this));
         NS_ENSURE_SUCCESS(rv, rv);
       }
-    
+
       // display borders if we need to
-      if (!tableFrame->IsBorderCollapse() && borderStyle->HasBorder() &&
-          emptyCellStyle == NS_STYLE_TABLE_EMPTY_CELLS_SHOW) {
-        nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
-            nsDisplayBorder(aBuilder, this));
-        NS_ENSURE_SUCCESS(rv, rv);
-      }
+      nsresult rv = ProcessBorders(tableFrame, aBuilder, aLists);
+      NS_ENSURE_SUCCESS(rv, rv);
     
       // and display the selection border if we need to
       if (IsSelected()) {
         nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
             nsDisplayGeneric(aBuilder, this, ::PaintTableCellSelection,
                              "TableCellSelection",
                              nsDisplayItem::TYPE_TABLE_CELL_SELECTION));
         NS_ENSURE_SUCCESS(rv, rv);
diff --git a/layout/tables/nsTableCellFrame.h b/layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h
+++ b/layout/tables/nsTableCellFrame.h
@@ -95,16 +95,20 @@ public:
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
   void PaintCellBackground(nsRenderingContext& aRenderingContext,
                            const nsRect& aDirtyRect, nsPoint aPt,
                            PRUint32 aFlags);
 
+  virtual nsresult ProcessBorders(nsTableFrame* aFrame, 
+                                  nsDisplayListBuilder* aBuilder,
+                                  const nsDisplayListSet& aLists);
+
   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext);
   virtual IntrinsicWidthOffsetData
     IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext);
 
   NS_IMETHOD Reflow(nsPresContext*      aPresContext,
                     nsHTMLReflowMetrics& aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
@@ -123,17 +127,17 @@ public:
 
   void VerticallyAlignChild(nscoord aMaxAscent);
 
   /*
    * Get the value of vertical-align adjusted for CSS 2's rules for a
    * table cell, which means the result is always
    * NS_STYLE_VERTICAL_ALIGN_{TOP,MIDDLE,BOTTOM,BASELINE}.
    */
-  PRUint8 GetVerticalAlign() const;
+  virtual PRUint8 GetVerticalAlign() const;
 
   bool HasVerticalAlignBaseline() const {
     return GetVerticalAlign() == NS_STYLE_VERTICAL_ALIGN_BASELINE;
   }
 
   bool CellHasVisibleContent(nscoord       height,
                                nsTableFrame* tableFrame,
                                nsIFrame*     kidFrame);
