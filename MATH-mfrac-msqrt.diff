# HG changeset patch
# Parent ba8872bcb4176255bffe240d9d4645d986aab48d
# User Frédéric Wang <fred.wang@free.fr>
Bug 961365 - Use Open Type MATH constants for mfrac and msqrt/mroot. r=karl

diff --git a/layout/mathml/nsMathMLFrame.h b/layout/mathml/nsMathMLFrame.h
--- a/layout/mathml/nsMathMLFrame.h
+++ b/layout/mathml/nsMathMLFrame.h
@@ -9,16 +9,18 @@
 #include "mozilla/Attributes.h"
 #include "nsFontMetrics.h"
 #include "nsMathMLOperators.h"
 #include "nsIMathMLFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsBoundingMetrics.h"
 #include "nsIFrame.h"
 
+#include "gfxMathTable.h"
+
 class nsMathMLChar;
 class nsCSSValue;
 class nsDisplayListSet;
 
 // Concrete base class with default methods that derived MathML frames can override
 class nsMathMLFrame : public nsIMathMLFrame {
 public:
 
@@ -155,16 +157,47 @@ public:
     if (aFrame->IsFrameOfType(nsIFrame::eMathML)) {
       nsIMathMLFrame* mathMLFrame = do_QueryFrame(aFrame);
       if (mathMLFrame)
         return mathMLFrame->GetMathMLFrameType();
     }
     return eMathMLFrameType_UNKNOWN;
   }
 
+  static bool
+  TryGetMathTable(nsFontMetrics* aFontMetrics)
+  {
+    gfxFont* mathFont = aFontMetrics->GetThebesFontGroup()->GetFontAt(0);
+    return mathFont->GetFontEntry()->TryGetMathTable(mathFont);
+  }
+
+  virtual bool
+  GetMathConstantPercent(nsFontMetrics*             aFontMetrics,
+                         gfxFontEntry::MathConstant aConstant,
+                         float&                     aValue)
+  {
+    if (!TryGetMathTable(aFontMetrics))
+      return false;
+    aValue = aFontMetrics->GetThebesFontGroup()->GetFontAt(0)->GetFontEntry()->
+      GetMathConstant(aConstant) / 100.0;
+    return true;
+  }
+
+  virtual bool
+  GetMathConstantEm(nsFontMetrics*             aFontMetrics,
+                    gfxFontEntry::MathConstant aConstant,
+                    nscoord&                   aValue)
+  {
+    if (!TryGetMathTable(aFontMetrics))
+      return false;
+    aValue = aFontMetrics->GetThebesFontGroup()->GetFontAt(0)->GetFontEntry()->
+      GetMathConstant(aConstant) * aFontMetrics->EmHeight();
+    return true;
+  }
+
   // estimate of the italic correction
   static void
   GetItalicCorrection(nsBoundingMetrics& aBoundingMetrics,
                       nscoord&           aItalicCorrection)
   {
     aItalicCorrection = aBoundingMetrics.rightBearing - aBoundingMetrics.width;
     if (0 > aItalicCorrection) {
       aItalicCorrection = 0;
diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -214,32 +214,37 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
   nsPresContext* presContext = PresContext();
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   aRenderingContext.SetFont(fm);
 
   nscoord defaultRuleThickness, axisHeight;
-  GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
+  if (!GetMathConstantEm(fm, gfxFontEntry::FractionRuleThickness,
+                         defaultRuleThickness)) {
+    GetRuleThickness(aRenderingContext, fm, defaultRuleThickness);
+  }
   GetAxisHeight(aRenderingContext, fm, axisHeight);
 
   nsEmbellishData coreData;
   GetEmbellishDataFrom(mEmbellishData.coreFrame, coreData);
 
   // see if the linethickness attribute is there 
   nsAutoString value;
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::linethickness_, value);
   mLineThickness = CalcLineThickness(presContext, mStyleContext, value,
                                      onePixel, defaultRuleThickness);
 
   // bevelled attribute
   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::bevelled_, value);
   mIsBevelled = value.EqualsLiteral("true");
 
+  bool displayStyle = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK;
+
   if (!mIsBevelled) {
     mLineRect.height = mLineThickness;
     
     // by default, leave at least one-pixel padding at either end, or use
     // lspace & rspace that may come from <mo> if we are an embellished
     // container (we fetch values from the core since they may use units that
     // depend on style data, and style changes could have occurred in the
     // core since our last visit there)
@@ -264,64 +269,72 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
       numShift = numShift1;
       denShift = denShift1;
     }
     else {
       numShift = (0 < mLineRect.height) ? numShift2 : numShift3;
       denShift = denShift2;
     }
 
-    nscoord minClearance = 0;
-    nscoord actualClearance = 0;
-
     nscoord actualRuleThickness =  mLineThickness;
 
     if (0 == actualRuleThickness) {
       // Rule 15c, App. G, TeXbook
 
       // min clearance between numerator and denominator
-      minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
+      nscoord minClearance = displayStyle ?
         7 * defaultRuleThickness : 3 * defaultRuleThickness;
-      actualClearance =
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::StackDisplayStyleGapMin :
+                        gfxFontEntry::StackGapMin, minClearance);
+      nscoord actualClearance =
         (numShift - bmNum.descent) - (bmDen.ascent - denShift);
       // actualClearance should be >= minClearance
       if (actualClearance < minClearance) {
         nscoord halfGap = (minClearance - actualClearance)/2;
         numShift += halfGap;
         denShift += halfGap;
       }
     }
     else {
     // Rule 15d, App. G, TeXbook
 
     // min clearance between numerator or denominator and middle of bar
 
     // TeX has a different interpretation of the thickness.
     // Try $a \above10pt b$ to see. Here is what TeX does:
-    // minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK
-    // ? 3 * actualRuleThickness : actualRuleThickness;
+    // minClearance = displayStyle ?
+    //   3 * actualRuleThickness : actualRuleThickness;
  
     // we slightly depart from TeX here. We use the defaultRuleThickness instead
     // of the value coming from the linethickness attribute, i.e., we recover what
     // TeX does if the user hasn't set linethickness. But when the linethickness
     // is set, we avoid the wide gap problem.
-     minClearance = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK ?
-      3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      nscoord minClearanceNum = displayStyle ?
+        3 * defaultRuleThickness : defaultRuleThickness + onePixel;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionNumDisplayStyleGapMin :
+                        gfxFontEntry::FractionNumeratorGapMin, minClearanceNum);
+      nscoord minClearanceDen = minClearanceNum;
+      GetMathConstantEm(fm, displayStyle ?
+                        gfxFontEntry::FractionDenomDisplayStyleGapMin :
+                        gfxFontEntry::FractionDenominatorGapMin,
+                        minClearanceDen);
 
-      // adjust numShift to maintain minClearance if needed
-      actualClearance =
+      // adjust numShift to maintain minClearanceNum if needed
+      nscoord actualClearanceNum =
         (numShift - bmNum.descent) - (axisHeight + actualRuleThickness/2);
-      if (actualClearance < minClearance) {
-        numShift += (minClearance - actualClearance);
+      if (actualClearanceNum < minClearanceNum) {
+        numShift += (minClearanceNum - actualClearanceNum);
       }
-      // adjust denShift to maintain minClearance if needed
-      actualClearance =
+      // adjust denShift to maintain minClearanceDen if needed
+      nscoord actualClearanceDen =
         (axisHeight - actualRuleThickness/2) - (bmDen.ascent - denShift);
-      if (actualClearance < minClearance) {
-        denShift += (minClearance - actualClearance);
+      if (actualClearanceDen < minClearanceDen) {
+        denShift += (minClearanceDen - actualClearanceDen);
       }
     }
 
     //////////////////
     // Place Children
 
     // XXX Need revisiting the width. TeX uses the exact width
     // e.g. in $$\huge\frac{\displaystyle\int}{i}$$
diff --git a/layout/mathml/nsMathMLmrootFrame.cpp b/layout/mathml/nsMathMLmrootFrame.cpp
--- a/layout/mathml/nsMathMLmrootFrame.cpp
+++ b/layout/mathml/nsMathMLmrootFrame.cpp
@@ -213,43 +213,50 @@ nsMathMLmrootFrame::Reflow(nsPresContext
 
   ////////////
   // Prepare the radical symbol and the overline bar
 
   nsRefPtr<nsFontMetrics> fm;
   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
   renderingContext.SetFont(fm);
 
-  // For radical glyphs from TeX fonts and some of the radical glyphs from
-  // Mathematica fonts, the thickness of the overline can be obtained from the
-  // ascent of the glyph.  Most fonts however have radical glyphs above the
-  // baseline so no assumption can be made about the meaning of the ascent.
   nscoord ruleThickness, leading, em;
-  GetRuleThickness(renderingContext, fm, ruleThickness);
-
-  char16_t one = '1';
-  nsBoundingMetrics bmOne = renderingContext.GetBoundingMetrics(&one, 1);
+  if (!GetMathConstantEm(fm, gfxFontEntry::RadicalRuleThickness,
+                         ruleThickness)) {
+    // For radical glyphs from TeX fonts and some of the radical glyphs from
+    // Mathematica fonts, the thickness of the overline can be obtained from the
+    // ascent of the glyph.  Most fonts however have radical glyphs above the
+    // baseline so no assumption can be made about the meaning of the ascent.
+    GetRuleThickness(renderingContext, fm, ruleThickness);
+  }
 
   // get the leading to be left at the top of the resulting frame
-  // this seems more reliable than using fm->GetLeading() on suspicious fonts
-  GetEmHeight(fm, em);
-  leading = nscoord(0.2f * em); 
+  if (!GetMathConstantEm(fm, gfxFontEntry::RadicalExtraAscender,
+                         leading)) {
+    // this seems more reliable than using fm->GetLeading() on suspicious fonts
+    GetEmHeight(fm, em);
+    leading = nscoord(0.2f * em);
+  }
 
-  // Rule 11, App. G, TeXbook
   // psi = clearance between rule and content
-  nscoord phi = 0, psi = 0;
-  if (StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK)
-    phi = fm->XHeight();
-  else
-    phi = ruleThickness;
-  psi = ruleThickness + phi/4;
+  bool displayStyle = StyleFont()->mMathDisplay == NS_MATHML_DISPLAYSTYLE_BLOCK;
+  nscoord psi = 0;
+  if (!GetMathConstantEm(fm, displayStyle ?
+                         gfxFontEntry::RadicalDisplayStyleVerticalGap :
+                         gfxFontEntry::RadicalVerticalGap, psi)) {
+    // Rule 11, App. G, TeXbook
+    nscoord phi = displayStyle ? fm->XHeight() : ruleThickness;
+    psi = ruleThickness + phi/4;
 
-  // built-in: adjust clearance psi to emulate \mathstrut using '1' (TexBook, p.131)
-  if (bmOne.ascent > bmBase.ascent)
-    psi += bmOne.ascent - bmBase.ascent;
+    // built-in: adjust clearance psi to emulate \mathstrut using '1' (TexBook, p.131)
+    char16_t one = '1';
+    nsBoundingMetrics bmOne = renderingContext.GetBoundingMetrics(&one, 1);
+    if (bmOne.ascent > bmBase.ascent)
+      psi += bmOne.ascent - bmBase.ascent;
+  }
 
   // make sure that the rule appears on on screen
   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
   if (ruleThickness < onePixel) {
     ruleThickness = onePixel;
   }
 
   // adjust clearance psi to get an exact number of pixels -- this
@@ -291,17 +298,21 @@ nsMathMLmrootFrame::Reflow(nsPresContext
            mBoundingMetrics.descent + ruleThickness);
   aDesiredSize.Width() = mBoundingMetrics.width;
 
   /////////////
   // Re-adjust the desired size to include the index.
   
   // the index is raised by some fraction of the height
   // of the radical, see \mroot macro in App. B, TexBook
-  nscoord raiseIndexDelta = NSToCoordRound(0.6f * (bmSqr.ascent + bmSqr.descent));
+  float raisePercent = 0.6f;
+  GetMathConstantPercent(fm, gfxFontEntry::RadicalDegreeBottomRaisePercent,
+                         raisePercent);
+  nscoord raiseIndexDelta = NSToCoordRound(raisePercent *
+                                           (bmSqr.ascent + bmSqr.descent));
   nscoord indexRaisedAscent = mBoundingMetrics.ascent // top of radical 
     - (bmSqr.ascent + bmSqr.descent) // to bottom of radical
     + raiseIndexDelta + bmIndex.ascent + bmIndex.descent; // to top of raised index
 
   nscoord indexClearance = 0;
   if (mBoundingMetrics.ascent < indexRaisedAscent) {
     indexClearance = 
       indexRaisedAscent - mBoundingMetrics.ascent; // excess gap introduced by a tall index 
