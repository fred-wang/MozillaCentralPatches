# HG changeset patch
# Parent 3893d7c23471f3668b17f6def90cb974fc63666f
# User Frédéric Wang <fred.wang@free.fr>
Uninitialised value in nsMathMLChar (bug 605605)

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -1151,27 +1151,29 @@ class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
                      nsIRenderingContext& aRenderingContext,
                      nsStretchDirection   aStretchDirection,
                      nscoord              aTargetSize,
                      PRUint32             aStretchHint,
                      nsBoundingMetrics&   aStretchedMetrics,
-                     const nsAString&     aFamilies)
+                     const nsAString&     aFamilies,
+                     PRBool&              aGlyphFound)
     : mChar(aChar),
       mPresContext(aPresContext),
       mRenderingContext(aRenderingContext),
       mDirection(aStretchDirection),
       mTargetSize(aTargetSize),
       mStretchHint(aStretchHint),
       mBoundingMetrics(aStretchedMetrics),
       mFamilies(aFamilies),
       mTryVariants(PR_TRUE),
-      mTryParts(PR_TRUE) {}
+      mTryParts(PR_TRUE),
+      mGlyphFound(aGlyphFound) {}
 
   static PRBool
   EnumCallback(const nsString& aFamily, PRBool aGeneric, void *aData);
 
 private:
   static PRBool
   ResolverCallback (const nsAString& aFamily, void *aData);
 
@@ -1190,16 +1192,17 @@ private:
 
 public:
   PRPackedBool mTryVariants;
   PRPackedBool mTryParts;
 
 private:
   nsAutoTArray<nsGlyphTable*,16> mTablesTried;
   nsGlyphTable* mGlyphTable; // for this callback
+  PRBool&       mGlyphFound;
 };
 
 
 // 2. See if there are any glyphs of the appropriate size.
 // Returns PR_TRUE if the size is OK, PR_FALSE to keep searching.
 // Always updates the char if a better match is found.
 PRBool
 nsMathMLChar::StretchEnumContext::TryVariants(nsGlyphTable*    aGlyphTable,
@@ -1245,16 +1248,17 @@ nsMathMLChar::StretchEnumContext::TryVar
     nsresult rv = mRenderingContext.GetBoundingMetrics(&ch.code, 1, bm);
     if (NS_SUCCEEDED(rv)) {
       nscoord charSize =
         isVertical ? bm.ascent + bm.descent
                    : bm.rightBearing - bm.leftBearing;
 
       if (largeopOnly ||
           IsSizeBetter(charSize, bestSize, mTargetSize, mStretchHint)) {
+        mGlyphFound = PR_TRUE;
         if (maxWidth) {
           // IsSizeBetter() checked that charSize < maxsize;
           // Leave ascent, descent, and bestsize as these contain maxsize.
           if (mBoundingMetrics.width < bm.width)
             mBoundingMetrics.width = bm.width;
           if (mBoundingMetrics.leftBearing > bm.leftBearing)
             mBoundingMetrics.leftBearing = bm.leftBearing;
           if (mBoundingMetrics.rightBearing < bm.rightBearing)
@@ -1315,16 +1319,17 @@ nsMathMLChar::StretchEnumContext::TryPar
            NS_LossyConvertUTF16toASCII(fontName).get(),
            NS_SUCCEEDED(rv)? "OK" : "Rejected");
 #endif
     if (NS_FAILED(rv))
       return PR_FALSE; // to next table
 
     // all went well, painting will be delegated from now on to children
     mChar->mGlyph = kNullGlyph; // this will tell paint to build by parts
+    mGlyphFound = PR_TRUE;
     mChar->mGlyphTable = aGlyphTable;
     mBoundingMetrics = compositeSize;
     return PR_TRUE; // no more searching
   }
 
   // See if the parts of this table fit in the desired space //////////////////
 
   // Use our stretchy style context now that stretching is in progress
@@ -1442,16 +1447,17 @@ nsMathMLChar::StretchEnumContext::TryPar
       if (descent < bm.descent) descent = bm.descent;
     }
     mBoundingMetrics.width = computedSize;
     mBoundingMetrics.ascent = ascent;
     mBoundingMetrics.descent = descent;
     mBoundingMetrics.leftBearing = 0;
     mBoundingMetrics.rightBearing = computedSize;
   }
+  mGlyphFound = PR_TRUE;
   if (maxWidth)
     return PR_FALSE; // Continue to check other sizes
 
   // reset
   mChar->mGlyph = kNullGlyph; // this will tell paint to build by parts
   mChar->mGlyphTable = aGlyphTable;
   mChar->mFamily = aFamily;
 
@@ -1560,17 +1566,16 @@ nsMathMLChar::StretchInternal(nsPresCont
                                          aDesiredStretchSize);
   if (NS_FAILED(rv)) {
     NS_WARNING("GetBoundingMetrics failed");
     mDirection = NS_STRETCH_DIRECTION_UNSUPPORTED;
     return rv;
   }
 
   if (!maxWidth) {
-    mScaleY = mScaleX = 1.0;
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
 
   ////////////////////////////////////////////////////////////////////////////////////
   // 1. Check the common situations where stretching is not actually needed
   ////////////////////////////////////////////////////////////////////////////////////
 
   // quick return if there is nothing special about this char
@@ -1650,45 +1655,46 @@ nsMathMLChar::StretchInternal(nsPresCont
          IsSizeOK(aPresContext, charSize, targetSize, aStretchHint)))
       done = PR_TRUE;
   }
 
   ////////////////////////////////////////////////////////////////////////////////////
   // 2/3. Search for a glyph or set of part glyphs of appropriate size
   ////////////////////////////////////////////////////////////////////////////////////
 
+  PRBool glyphFound = PR_FALSE;
   nsAutoString cssFamilies;
 
   if (!done) {
     font = mStyleContext->GetStyleFont()->mFont;
     cssFamilies = font.name;
   }
 
   // See if there are preferred fonts for the variants of this char
   if (!done && GetFontExtensionPref(prefBranch, mData[0], eExtension_variants,
                                     families)) {
     font.name = families;
 
     StretchEnumContext enumData(this, aPresContext, aRenderingContext,
                                 aStretchDirection, targetSize, aStretchHint,
-                                aDesiredStretchSize, font.name);
+                                aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryParts = PR_FALSE;
 
     done = !font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   // See if there are preferred fonts for the parts of this char
   if (!done && !largeopOnly
       && GetFontExtensionPref(prefBranch, mData[0], eExtension_parts,
                               families)) {
     font.name = families;
 
     StretchEnumContext enumData(this, aPresContext, aRenderingContext,
                                 aStretchDirection, targetSize, aStretchHint,
-                                aDesiredStretchSize, font.name);
+                                aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryVariants = PR_FALSE;
 
     done = !font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   if (!done) { // normal case
     // Use the css font-family but add preferred fallback fonts.
     font.name = cssFamilies;
@@ -1699,86 +1705,94 @@ nsMathMLChar::StretchInternal(nsPresCont
     }
 
 #ifdef NOISY_SEARCH
     printf("Searching in "%s" for a glyph of appropriate size for: 0x%04X:%c\n",
            font.name, mData[0], mData[0]&0x00FF);
 #endif
     StretchEnumContext enumData(this, aPresContext, aRenderingContext,
                                 aStretchDirection, targetSize, aStretchHint,
-                                aDesiredStretchSize, font.name);
+                                aDesiredStretchSize, font.name, glyphFound);
     enumData.mTryParts = !largeopOnly;
 
     font.EnumerateFamilies(StretchEnumContext::EnumCallback, &enumData);
   }
 
   if (!maxWidth) {
     // Now, we know how we are going to draw the char. Update the member
     // variables accordingly.
-    mDrawNormal = (mGlyph.font == -1);
+    mDrawNormal = !glyphFound;
     mUnscaledAscent = aDesiredStretchSize.ascent;
   }
     
   // stretchy character
   if (stretchy) {
     if (isVertical) {
       float scale =
         float(aContainerSize.ascent + aContainerSize.descent) /
         (aDesiredStretchSize.ascent + aDesiredStretchSize.descent);
       if (!largeop || scale > 1.0) {
         // make the character match the desired height.
-        mScaleY *= scale;
+        if (!maxWidth) {
+          mScaleY *= scale;
+        }
         aDesiredStretchSize.ascent *= scale;
         aDesiredStretchSize.descent *= scale;
       }
     } else {
       float scale =
         float(aContainerSize.rightBearing - aContainerSize.leftBearing) /
         (aDesiredStretchSize.rightBearing - aDesiredStretchSize.leftBearing);
       if (!largeop || scale > 1.0) {
         // make the character match the desired width.
-        mScaleX *= scale;
+        if (!maxWidth) {
+          mScaleX *= scale;
+        }
         aDesiredStretchSize.leftBearing *= scale;
         aDesiredStretchSize.rightBearing *= scale;
         aDesiredStretchSize.width *= scale;
       }
     }
   }
 
   // We do not have a char variant for this largeop in display mode, so we
   // apply a scale transform to the base char.
-  if (mGlyph.font == -1 && largeop) {
+  if (!glyphFound && largeop) {
     float scale;
     float largeopFactor = M_SQRT2;
 
     // increase the width if it is not largeopFactor times larger
     // than the initial one.
     if ((aDesiredStretchSize.rightBearing - aDesiredStretchSize.leftBearing) <
         largeopFactor * (initialSize.rightBearing - initialSize.leftBearing)) {
       scale = (largeopFactor *
                (initialSize.rightBearing - initialSize.leftBearing)) /
         (aDesiredStretchSize.rightBearing - aDesiredStretchSize.leftBearing);
-      mScaleX *= scale;
+      if (!maxWidth) {
+        mScaleX *= scale;
+      }
       aDesiredStretchSize.leftBearing *= scale;
       aDesiredStretchSize.rightBearing *= scale;
       aDesiredStretchSize.width *= scale;
     }
 
     // increase the height if it is not largeopFactor times larger
     // than the initial one.
     if (NS_STRETCH_INTEGRAL & aStretchHint) {
       // integrals are drawn taller
       largeopFactor = 2.0;
     }
     if ((aDesiredStretchSize.ascent + aDesiredStretchSize.descent) <
         largeopFactor * (initialSize.ascent + initialSize.descent)) {
       scale = (largeopFactor *
                (initialSize.ascent + initialSize.descent)) /
         (aDesiredStretchSize.ascent + aDesiredStretchSize.descent);
-      mScaleY *= scale;
+      if (!maxWidth) {
+        mScaleY *= scale;
+      }
       aDesiredStretchSize.ascent *= scale;
       aDesiredStretchSize.descent *= scale;
     }
   }
 
   return NS_OK;
 }
 
@@ -1790,19 +1804,18 @@ nsMathMLChar::Stretch(nsPresContext*    
                       nsBoundingMetrics&       aDesiredStretchSize,
                       PRUint32                 aStretchHint)
 {
   NS_ASSERTION(!(aStretchHint &
                  ~(NS_STRETCH_VARIABLE_MASK | NS_STRETCH_LARGEOP |
                    NS_STRETCH_INTEGRAL)),
                "Unexpected stretch flags");
 
-  // This will be updated if a better match than the base character is found
-  mGlyph.font = -1;
-
+  mDrawNormal = PR_TRUE;
+  mScaleY = mScaleX = 1.0;
   mDirection = aStretchDirection;
   nsresult rv =
     StretchInternal(aPresContext, aRenderingContext, mDirection,
                     aContainerSize, aDesiredStretchSize, aStretchHint);
 
   // Record the metrics
   mBoundingMetrics = aDesiredStretchSize;
 
