# HG changeset patch
# Parent 403364a10e5bec53d1cff4c2e6853304bcb818b1
# User Frédéric Wang <fred.wang@free.fr>
Refactor implementation of displaystyle - part 3: changes to MathML frames. b=838506, r=karlt

diff --git a/layout/mathml/nsMathMLmencloseFrame.cpp b/layout/mathml/nsMathMLmencloseFrame.cpp
--- a/layout/mathml/nsMathMLmencloseFrame.cpp
+++ b/layout/mathml/nsMathMLmencloseFrame.cpp
@@ -346,17 +346,17 @@ nsMathMLmencloseFrame::PlaceInternal(nsR
   nscoord delta = padding % onePixel;
   if (delta)
     padding += onePixel - delta; // round up
 
   if (IsToDraw(NOTATION_LONGDIV) || IsToDraw(NOTATION_RADICAL)) {
       nscoord phi;
       // Rule 11, App. G, TeXbook
       // psi = clearance between rule and content
-      if (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags))
+      if (StyleFont()->mDisplayStyle)
         phi = fm->XHeight();
       else
         phi = mRuleThickness;
       psi = mRuleThickness + phi / 4;
 
       delta = psi % onePixel;
       if (delta)
         psi += onePixel - delta; // round up
diff --git a/layout/mathml/nsMathMLmfracFrame.cpp b/layout/mathml/nsMathMLmfracFrame.cpp
--- a/layout/mathml/nsMathMLmfracFrame.cpp
+++ b/layout/mathml/nsMathMLmfracFrame.cpp
@@ -41,28 +41,18 @@ nsMathMLmfracFrame::GetMathMLFrameType()
 {
   // frac is "inner" in TeXBook, Appendix G, rule 15e. See also page 170.
   return eMathMLFrameType_Inner;
 }
 
 NS_IMETHODIMP
 nsMathMLmfracFrame::TransmitAutomaticData()
 {
-  // 1. The REC says:
-  //    The <mfrac> element sets displaystyle to "false", or if it was already
-  //    false increments scriptlevel by 1, within numerator and denominator.
-  // 2. The TeXbook (Ch 17. p.141) says the numerator inherits the compression
-  //    while the denominator is compressed
-  bool increment = !NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags);
-  SetIncrementScriptLevel(0, increment);
-  SetIncrementScriptLevel(1, increment);
-
-  UpdatePresentationDataFromChildAt(0, -1,
-    ~NS_MATHML_DISPLAYSTYLE,
-     NS_MATHML_DISPLAYSTYLE);
+  // The TeXbook (Ch 17. p.141) says the numerator inherits the compression
+  //  while the denominator is compressed
   UpdatePresentationDataFromChildAt(1,  1,
      NS_MATHML_COMPRESSED,
      NS_MATHML_COMPRESSED);
 
   // if our numerator is an embellished operator, let its state bubble to us
   GetEmbellishDataFrom(mFrames.FirstChild(), mEmbellishData);
   if (NS_MATHML_IS_EMBELLISH_OPERATOR(mEmbellishData.flags)) {
     // even when embellished, we need to record that <mfrac> won't fire
@@ -247,17 +237,17 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
     nscoord denShift = 0;
 
     // Rule 15b, App. G, TeXbook
     nscoord numShift1, numShift2, numShift3;
     nscoord denShift1, denShift2;
 
     GetNumeratorShifts(fm, numShift1, numShift2, numShift3);
     GetDenominatorShifts(fm, denShift1, denShift2);
-    if (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) {
+    if (StyleFont()->mDisplayStyle) {
       // C > T
       numShift = numShift1;
       denShift = denShift1;
     }
     else {
       numShift = (0 < mLineRect.height) ? numShift2 : numShift3;
       denShift = denShift2;
     }
@@ -266,17 +256,17 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
     nscoord actualClearance = 0;
 
     nscoord actualRuleThickness =  mLineThickness;
 
     if (0 == actualRuleThickness) {
       // Rule 15c, App. G, TeXbook
 
       // min clearance between numerator and denominator
-      minClearance = (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) ?
+      minClearance = StyleFont()->mDisplayStyle ?
         7 * defaultRuleThickness : 3 * defaultRuleThickness;
       actualClearance =
         (numShift - bmNum.descent) - (bmDen.ascent - denShift);
       // actualClearance should be >= minClearance
       if (actualClearance < minClearance) {
         nscoord halfGap = (minClearance - actualClearance)/2;
         numShift += halfGap;
         denShift += halfGap;
@@ -284,24 +274,24 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
     }
     else {
     // Rule 15d, App. G, TeXbook
 
     // min clearance between numerator or denominator and middle of bar
 
     // TeX has a different interpretation of the thickness.
     // Try $a \above10pt b$ to see. Here is what TeX does:
-//     minClearance = (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) ?
-//      3 * actualRuleThickness : actualRuleThickness;
+    // minClearance = StyleFont()->mDisplayStyle ?
+    //  3 * actualRuleThickness : actualRuleThickness;
  
     // we slightly depart from TeX here. We use the defaultRuleThickness instead
     // of the value coming from the linethickness attribute, i.e., we recover what
     // TeX does if the user hasn't set linethickness. But when the linethickness
     // is set, we avoid the wide gap problem.
-     minClearance = (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) ?
+     minClearance = StyleFont()->mDisplayStyle ?
       3 * defaultRuleThickness : defaultRuleThickness + onePixel;
 
       // adjust numShift to maintain minClearance if needed
       actualClearance =
         (numShift - bmNum.descent) - (axisHeight + actualRuleThickness/2);
       if (actualClearance < minClearance) {
         numShift += (minClearance - actualClearance);
       }
@@ -409,17 +399,17 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
     // top of the denominator (and the reverse for the bottoms)
     delta = std::max(bmDen.ascent - bmNum.ascent,
                    bmNum.descent - bmDen.descent) / 2;
     if (delta > 0) {
       numShift += delta;
       denShift += delta;
     }
 
-    if (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) {
+    if (StyleFont()->mDisplayStyle) {
       delta = std::min(bmDen.ascent + bmDen.descent,
                      bmNum.ascent + bmNum.descent) / 2;
       numShift += delta;
       denShift += delta;
     } else {
       nscoord xHeight = fm->XHeight();
       numShift += xHeight / 2;
       denShift += xHeight / 4;
@@ -494,41 +484,16 @@ nsMathMLmfracFrame::PlaceInternal(nsRend
       FinishReflowChild(frameDen, presContext, nullptr, sizeDen, dx, dy, 0);
     }
 
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsMathMLmfracFrame::UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                                      int32_t         aLastIndex,
-                                                      uint32_t        aFlagsValues,
-                                                      uint32_t        aFlagsToUpdate)
-{
-  // The REC says "The <mfrac> element sets displaystyle to "false" within
-  // numerator and denominator"
-#if 0
-  // At one point I thought that it meant that the displaystyle state of
-  // the numerator and denominator cannot be modified by an ancestor, i.e.,
-  // to change the displaystyle, one has to use displaystyle="true" with mstyle:
-  // <mfrac> <mstyle>numerator</mstyle> <mstyle>denominator</mstyle> </mfrac>
-
-  // Commenting out for now until it is clear what the intention really is.
-  // See also the variants for <mover>, <munder>, <munderover>
-
-  aFlagsToUpdate &= ~NS_MATHML_DISPLAYSTYLE;
-  aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-#endif
-  return nsMathMLContainerFrame::
-    UpdatePresentationDataFromChildAt(aFirstIndex, aLastIndex,
-                                      aFlagsValues, aFlagsToUpdate);
-}
-
 class nsDisplayMathMLSlash : public nsDisplayItem {
 public:
   nsDisplayMathMLSlash(nsDisplayListBuilder* aBuilder,
                        nsIFrame* aFrame, const nsRect& aRect,
                        nscoord aThickness, bool aRTL)
     : nsDisplayItem(aBuilder, aFrame), mRect(aRect), mThickness(aThickness),
       mRTL(aRTL) {
     MOZ_COUNT_CTOR(nsDisplayMathMLSlash);
diff --git a/layout/mathml/nsMathMLmfracFrame.h b/layout/mathml/nsMathMLmfracFrame.h
--- a/layout/mathml/nsMathMLmfracFrame.h
+++ b/layout/mathml/nsMathMLmfracFrame.h
@@ -68,22 +68,16 @@ public:
 
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
 
   NS_IMETHOD
   TransmitAutomaticData() MOZ_OVERRIDE;
 
-  NS_IMETHOD
-  UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                    int32_t         aLastIndex,
-                                    uint32_t        aFlagsValues,
-                                    uint32_t        aFlagsToUpdate) MOZ_OVERRIDE;
-
   // override the base method so that we can deal with the fraction line
   virtual nscoord
   FixInterFrameSpacing(nsHTMLReflowMetrics& aDesiredSize) MOZ_OVERRIDE;
 
   // helper to translate the thickness attribute into a usable form
   static nscoord 
   CalcLineThickness(nsPresContext*  aPresContext,
                     nsStyleContext*  aStyleContext,
diff --git a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
--- a/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
+++ b/layout/mathml/nsMathMLmmultiscriptsFrame.cpp
@@ -30,22 +30,16 @@ nsMathMLmmultiscriptsFrame::~nsMathMLmmu
 
 NS_IMETHODIMP
 nsMathMLmmultiscriptsFrame::TransmitAutomaticData()
 {
   // if our base is an embellished operator, let its state bubble to us
   mPresentationData.baseFrame = mFrames.FirstChild();
   GetEmbellishDataFrom(mPresentationData.baseFrame, mEmbellishData);
 
-  // The REC says:
-  // The script element increments scriptlevel by 1, and sets
-  // displaystyle to "false", within each of its arguments except base
-  UpdatePresentationDataFromChildAt(1, -1,
-    ~NS_MATHML_DISPLAYSTYLE, NS_MATHML_DISPLAYSTYLE);
-
   // The TeXbook (Ch 17. p.141) says the superscript inherits the compression
   // while the subscript is compressed. So here we collect subscripts and set
   // the compression flag in them.
 
   if (mContent->Tag() == nsGkAtoms::msup_)
     return NS_OK;
 
   int32_t count = 0;
@@ -232,18 +226,17 @@ nsMathMLmmultiscriptsFrame::PlaceMultiSc
   // Set supScriptShift{1,2,3} default from font
   GetSupScriptShifts (fm, supScriptShift1, supScriptShift2, supScriptShift3);
 
   // get sup script shift depending on current script level and display style
   // Rule 18c, App. G, TeXbook
   nsPresentationData presentationData;
   aFrame->GetPresentationData(presentationData);
   nscoord supScriptShift;
-  if ( font->mScriptLevel == 0 &&
-       NS_MATHML_IS_DISPLAYSTYLE(presentationData.flags) &&
+  if (font->mScriptLevel == 0 && font->mDisplayStyle &&
       !NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style D in TeXbook
     supScriptShift = supScriptShift1;
   } else if (NS_MATHML_IS_COMPRESSED(presentationData.flags)) {
     // Style C' in TeXbook = D',T',S',SS'
     supScriptShift = supScriptShift3;
   } else {
     // everything else = T,S,SS
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -557,29 +557,28 @@ nsMathMLmoFrame::ProcessOperatorData()
         mFlags |= NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE;
       }
     }
   }
 }
 
 static uint32_t
 GetStretchHint(nsOperatorFlags aFlags, nsPresentationData aPresentationData,
-               bool aIsVertical)
+               bool aIsVertical, bool aIsDisplayStyle)
 {
   uint32_t stretchHint = NS_STRETCH_NONE;
   // See if it is okay to stretch,
   // starting from what the Operator Dictionary said
   if (NS_MATHML_OPERATOR_IS_MUTABLE(aFlags)) {
     // set the largeop or largeopOnly flags to suitably cover all the
     // 8 possible cases depending on whether displaystyle, largeop,
     // stretchy are true or false (see bug 69325).
     // . largeopOnly is taken if largeop=true and stretchy=false
     // . largeop is taken if largeop=true and stretchy=true
-    if (NS_MATHML_IS_DISPLAYSTYLE(aPresentationData.flags) &&
-        NS_MATHML_OPERATOR_IS_LARGEOP(aFlags)) {
+    if (aIsDisplayStyle && NS_MATHML_OPERATOR_IS_LARGEOP(aFlags)) {
       stretchHint = NS_STRETCH_LARGEOP; // (largeopOnly, not mask!)
       if (NS_MATHML_OPERATOR_IS_INTEGRAL(aFlags)) {
         stretchHint |= NS_STRETCH_INTEGRAL;
       }
       if (NS_MATHML_OPERATOR_IS_STRETCHY(aFlags)) {
         stretchHint |= NS_STRETCH_NEARER | NS_STRETCH_LARGER;
       }
     }
@@ -639,17 +638,18 @@ nsMathMLmoFrame::Stretch(nsRenderingCont
 
   if (((aStretchDirection == NS_STRETCH_DIRECTION_VERTICAL) ||
        (aStretchDirection == NS_STRETCH_DIRECTION_DEFAULT))  &&
       (mEmbellishData.direction == NS_STRETCH_DIRECTION_VERTICAL)) {
     isVertical = true;
   }
 
   uint32_t stretchHint =
-    GetStretchHint(mFlags, mPresentationData, isVertical);
+    GetStretchHint(mFlags, mPresentationData, isVertical,
+                   StyleFont()->mDisplayStyle);
 
   if (useMathMLChar) {
     nsBoundingMetrics initialSize = aDesiredStretchSize.mBoundingMetrics;
 
     if (stretchHint != NS_STRETCH_NONE) {
 
       container = aContainerSize;
 
@@ -1000,17 +1000,18 @@ nsMathMLmoFrame::MarkIntrinsicWidthsDirt
   nsMathMLContainerFrame::MarkIntrinsicWidthsDirty();
 }
 
 /* virtual */ void
 nsMathMLmoFrame::GetIntrinsicWidthMetrics(nsRenderingContext *aRenderingContext, nsHTMLReflowMetrics& aDesiredSize)
 {
   ProcessOperatorData();
   if (UseMathMLChar()) {
-    uint32_t stretchHint = GetStretchHint(mFlags, mPresentationData, true);
+    uint32_t stretchHint = GetStretchHint(mFlags, mPresentationData, true,
+                                          StyleFont()->mDisplayStyle);
     aDesiredSize.width = mMathMLChar.
       GetMaxWidth(PresContext(), *aRenderingContext,
                   stretchHint, mMaxSize,
                   NS_MATHML_OPERATOR_MAXSIZE_IS_ABSOLUTE(mFlags));
   }
   else {
     nsMathMLTokenFrame::GetIntrinsicWidthMetrics(aRenderingContext,
                                                  aDesiredSize);
diff --git a/layout/mathml/nsMathMLmrootFrame.cpp b/layout/mathml/nsMathMLmrootFrame.cpp
--- a/layout/mathml/nsMathMLmrootFrame.cpp
+++ b/layout/mathml/nsMathMLmrootFrame.cpp
@@ -65,18 +65,18 @@ nsMathMLmrootFrame::Init(nsIContent*    
 NS_IMETHODIMP
 nsMathMLmrootFrame::TransmitAutomaticData()
 {
   // 1. The REC says:
   //    The <mroot> element increments scriptlevel by 2, and sets displaystyle to
   //    "false", within index, but leaves both attributes unchanged within base.
   // 2. The TeXbook (Ch 17. p.141) says \sqrt is compressed
   UpdatePresentationDataFromChildAt(1, 1,
-    ~NS_MATHML_DISPLAYSTYLE | NS_MATHML_COMPRESSED,
-     NS_MATHML_DISPLAYSTYLE | NS_MATHML_COMPRESSED);
+                                    NS_MATHML_COMPRESSED,
+                                    NS_MATHML_COMPRESSED);
   UpdatePresentationDataFromChildAt(0, 0,
      NS_MATHML_COMPRESSED, NS_MATHML_COMPRESSED);
 
   return NS_OK;
 }
 
 void
 nsMathMLmrootFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
@@ -227,17 +227,17 @@ nsMathMLmrootFrame::Reflow(nsPresContext
   // get the leading to be left at the top of the resulting frame
   // this seems more reliable than using fm->GetLeading() on suspicious fonts
   GetEmHeight(fm, em);
   leading = nscoord(0.2f * em); 
 
   // Rule 11, App. G, TeXbook
   // psi = clearance between rule and content
   nscoord phi = 0, psi = 0;
-  if (NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags))
+  if (StyleFont()->mDisplayStyle)
     phi = fm->XHeight();
   else
     phi = ruleThickness;
   psi = ruleThickness + phi/4;
 
   // built-in: adjust clearance psi to emulate \mathstrut using '1' (TexBook, p.131)
   if (bmOne.ascent > bmBase.ascent)
     psi += bmOne.ascent - bmBase.ascent;
diff --git a/layout/mathml/nsMathMLmstyleFrame.cpp b/layout/mathml/nsMathMLmstyleFrame.cpp
--- a/layout/mathml/nsMathMLmstyleFrame.cpp
+++ b/layout/mathml/nsMathMLmstyleFrame.cpp
@@ -17,73 +17,35 @@ NS_NewMathMLmstyleFrame(nsIPresShell* aP
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmstyleFrame)
 
 nsMathMLmstyleFrame::~nsMathMLmstyleFrame()
 {
 }
 
-// mstyle needs special care for its scriptlevel and displaystyle attributes
 NS_IMETHODIMP
 nsMathMLmstyleFrame::InheritAutomaticData(nsIFrame* aParent) 
 {
   // let the base class get the default from our parent
   nsMathMLContainerFrame::InheritAutomaticData(aParent);
 
   // sync with our current state
   mPresentationData.flags |= NS_MATHML_STRETCH_ALL_CHILDREN_VERTICALLY;
   mPresentationData.mstyle = this;
 
-  // see if the displaystyle attribute is there
-  nsMathMLFrame::FindAttrDisplaystyle(mContent, mPresentationData);
-
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMathMLmstyleFrame::TransmitAutomaticData()
 {
   return TransmitAutomaticDataForMrowLikeElement();
 }
 
-// displaystyle and scriptlevel are special in <mstyle>...
-// Since UpdatePresentation() and UpdatePresentationDataFromChildAt() can be called
-// by a parent, ensure that the explicit attributes of <mstyle> take precedence
-NS_IMETHODIMP
-nsMathMLmstyleFrame::UpdatePresentationData(uint32_t        aFlagsValues,
-                                            uint32_t        aWhichFlags)
-{
-  if (NS_MATHML_HAS_EXPLICIT_DISPLAYSTYLE(mPresentationData.flags)) {
-    // our current state takes precedence, disallow updating the displastyle
-    aWhichFlags &= ~NS_MATHML_DISPLAYSTYLE;
-    aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-  }
-
-  return nsMathMLContainerFrame::UpdatePresentationData(aFlagsValues, aWhichFlags);
-}
-
-NS_IMETHODIMP
-nsMathMLmstyleFrame::UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                                       int32_t         aLastIndex,
-                                                       uint32_t        aFlagsValues,
-                                                       uint32_t        aWhichFlags)
-{
-  if (NS_MATHML_HAS_EXPLICIT_DISPLAYSTYLE(mPresentationData.flags)) {
-    // our current state takes precedence, disallow updating the displastyle
-    aWhichFlags &= ~NS_MATHML_DISPLAYSTYLE;
-    aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-  }
-
-  // let the base class worry about the update
-  return
-    nsMathMLContainerFrame::UpdatePresentationDataFromChildAt(
-      aFirstIndex, aLastIndex, aFlagsValues, aWhichFlags); 
-}
-
 NS_IMETHODIMP
 nsMathMLmstyleFrame::AttributeChanged(int32_t         aNameSpaceID,
                                       nsIAtom*        aAttribute,
                                       int32_t         aModType)
 {
   // Other attributes can affect too many things, ask our parent to re-layout
   // its children so that we can pick up changes in our attributes & transmit
   // them in our subtree. However, our siblings will be re-laid too. We used
diff --git a/layout/mathml/nsMathMLmstyleFrame.h b/layout/mathml/nsMathMLmstyleFrame.h
--- a/layout/mathml/nsMathMLmstyleFrame.h
+++ b/layout/mathml/nsMathMLmstyleFrame.h
@@ -25,24 +25,14 @@ public:
                    int32_t         aModType) MOZ_OVERRIDE;
 
   NS_IMETHOD
   InheritAutomaticData(nsIFrame* aParent) MOZ_OVERRIDE;
 
   NS_IMETHOD
   TransmitAutomaticData() MOZ_OVERRIDE;
 
-  NS_IMETHOD
-  UpdatePresentationData(uint32_t        aFlagsValues,
-                         uint32_t        aFlagsToUpdate) MOZ_OVERRIDE;
-
-  NS_IMETHOD
-  UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                    int32_t         aLastIndex,
-                                    uint32_t        aFlagsValues,
-                                    uint32_t        aFlagsToUpdate) MOZ_OVERRIDE;
-
 protected:
   nsMathMLmstyleFrame(nsStyleContext* aContext) : nsMathMLContainerFrame(aContext) {}
   virtual ~nsMathMLmstyleFrame();
 };
 
 #endif /* nsMathMLmstyleFrame_h___ */
diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -416,76 +416,27 @@ NS_NewMathMLmtableOuterFrame (nsIPresShe
 
 NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmtableOuterFrame)
  
 nsMathMLmtableOuterFrame::~nsMathMLmtableOuterFrame()
 {
 }
 
 NS_IMETHODIMP
-nsMathMLmtableOuterFrame::InheritAutomaticData(nsIFrame* aParent)
-{
-  // XXX the REC says that by default, displaystyle=false in <mtable>
-
-  // let the base class inherit the displaystyle from our parent
-  nsMathMLFrame::InheritAutomaticData(aParent);
-
-  // see if the displaystyle attribute is there and let it override what we inherited
-  if (mContent->Tag() == nsGkAtoms::mtable_)
-    nsMathMLFrame::FindAttrDisplaystyle(mContent, mPresentationData);
-
-  return NS_OK;
-}
-
-// displaystyle is special in mtable...
-// Since UpdatePresentation() and UpdatePresentationDataFromChildAt() can be called
-// by a parent, ensure that the displaystyle attribute of mtable takes precedence
-NS_IMETHODIMP
-nsMathMLmtableOuterFrame::UpdatePresentationData(uint32_t aFlagsValues,
-                                                 uint32_t aWhichFlags)
-{
-  if (NS_MATHML_HAS_EXPLICIT_DISPLAYSTYLE(mPresentationData.flags)) {
-    // our current state takes precedence, disallow updating the displastyle
-    aWhichFlags &= ~NS_MATHML_DISPLAYSTYLE;
-    aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-  }
-
-  return nsMathMLFrame::UpdatePresentationData(aFlagsValues, aWhichFlags);
-}
-
-NS_IMETHODIMP
-nsMathMLmtableOuterFrame::UpdatePresentationDataFromChildAt(int32_t  aFirstIndex,
-                                                            int32_t  aLastIndex,
-                                                            uint32_t aFlagsValues,
-                                                            uint32_t aWhichFlags)
-{
-  if (NS_MATHML_HAS_EXPLICIT_DISPLAYSTYLE(mPresentationData.flags)) {
-    // our current state takes precedence, disallow updating the displastyle
-    aWhichFlags &= ~NS_MATHML_DISPLAYSTYLE;
-    aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-  }
-
-  nsMathMLContainerFrame::PropagatePresentationDataFromChildAt(this,
-    aFirstIndex, aLastIndex, aFlagsValues, aWhichFlags);
-
-  return NS_OK; 
-}
-
-NS_IMETHODIMP
 nsMathMLmtableOuterFrame::AttributeChanged(int32_t  aNameSpaceID,
                                            nsIAtom* aAttribute,
                                            int32_t  aModType)
 {
   // Attributes specific to <mtable>:
   // frame         : in mathml.css
   // framespacing  : not yet supported 
   // groupalign    : not yet supported
   // equalrows     : not yet supported 
   // equalcolumns  : not yet supported 
-  // displaystyle  : here 
+  // displaystyle  : here and in mathml.css
   // align         : in reflow 
   // rowalign      : here
   // rowlines      : here 
   // rowspacing    : not yet supported 
   // columnalign   : here 
   // columnlines   : here 
   // columnspacing : not yet supported 
 
diff --git a/layout/mathml/nsMathMLmtableFrame.h b/layout/mathml/nsMathMLmtableFrame.h
--- a/layout/mathml/nsMathMLmtableFrame.h
+++ b/layout/mathml/nsMathMLmtableFrame.h
@@ -21,31 +21,16 @@ class nsMathMLmtableOuterFrame : public 
                                  public nsMathMLFrame
 {
 public:
   friend nsIFrame* NS_NewMathMLmtableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
   NS_DECL_QUERYFRAME
   NS_DECL_FRAMEARENA_HELPERS
 
-  // Overloaded nsIMathMLFrame methods
-
-  NS_IMETHOD
-  InheritAutomaticData(nsIFrame* aParent) MOZ_OVERRIDE;
-
-  NS_IMETHOD
-  UpdatePresentationData(uint32_t aFlagsValues,
-                         uint32_t aWhichFlags) MOZ_OVERRIDE;
-
-  NS_IMETHOD
-  UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                    int32_t         aLastIndex,
-                                    uint32_t        aFlagsValues,
-                                    uint32_t        aWhichFlags) MOZ_OVERRIDE;
-
   // overloaded nsTableOuterFrame methods
 
   NS_IMETHOD
   Reflow(nsPresContext*          aPresContext,
          nsHTMLReflowMetrics&     aDesiredSize,
          const nsHTMLReflowState& aReflowState,
          nsReflowStatus&          aStatus) MOZ_OVERRIDE;
 
diff --git a/layout/mathml/nsMathMLmunderoverFrame.cpp b/layout/mathml/nsMathMLmunderoverFrame.cpp
--- a/layout/mathml/nsMathMLmunderoverFrame.cpp
+++ b/layout/mathml/nsMathMLmunderoverFrame.cpp
@@ -44,69 +44,27 @@ nsMathMLmunderoverFrame::AttributeChange
 }
 
 NS_IMETHODIMP
 nsMathMLmunderoverFrame::UpdatePresentationData(uint32_t        aFlagsValues,
                                                 uint32_t        aFlagsToUpdate)
 {
   nsMathMLContainerFrame::UpdatePresentationData(aFlagsValues, aFlagsToUpdate);
   // disable the stretch-all flag if we are going to act like a subscript-superscript pair
-  if ( NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
-      !NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) {
+  if (NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
+      !StyleFont()->mDisplayStyle) {
     mPresentationData.flags &= ~NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY;
   }
   else {
     mPresentationData.flags |= NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsMathMLmunderoverFrame::UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                                           int32_t         aLastIndex,
-                                                           uint32_t        aFlagsValues,
-                                                           uint32_t        aFlagsToUpdate)
-{
-  // munderover is special... The REC says:
-  // Within underscript, <munder> always sets displaystyle to "false", 
-  // but increments scriptlevel by 1 only when accentunder is "false".
-  // Within underscript, <munderover> always sets displaystyle to "false",
-  // but increments scriptlevel by 1 only when accentunder is "false". 
-  // This means that
-  // 1. don't allow displaystyle to change in the underscript & overscript
-  // 2a if the value of the accent is changed, we need to recompute the
-  //    scriptlevel of the underscript. The problem is that the accent
-  //    can change in the <mo> deep down the embellished hierarchy
-  // 2b if the value of the accent is changed, we need to recompute the
-  //    scriptlevel of the overscript. The problem is that the accent
-  //    can change in the <mo> deep down the embellished hierarchy
-
-  // Do #1 here, prevent displaystyle to be changed in the underscript & overscript
-  int32_t index = 0;
-  nsIFrame* childFrame = mFrames.FirstChild();
-  while (childFrame) {
-    if ((index >= aFirstIndex) &&
-        ((aLastIndex <= 0) || ((aLastIndex > 0) && (index <= aLastIndex)))) {
-      if (index > 0) {
-        // disable the flag
-        aFlagsToUpdate &= ~NS_MATHML_DISPLAYSTYLE;
-        aFlagsValues &= ~NS_MATHML_DISPLAYSTYLE;
-      }
-      PropagatePresentationDataFor(childFrame, aFlagsValues, aFlagsToUpdate);
-    }
-    index++;
-    childFrame = childFrame->GetNextSibling();
-  }
-  return NS_OK;
-
-  // For #2, changing the accent attribute will trigger a re-build of
-  // all automatic data in the embellished hierarchy
-}
-
-NS_IMETHODIMP
 nsMathMLmunderoverFrame::InheritAutomaticData(nsIFrame* aParent)
 {
   // let the base class get the default from our parent
   nsMathMLContainerFrame::InheritAutomaticData(aParent);
 
   mPresentationData.flags |= NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY;
 
   return NS_OK;
@@ -215,17 +173,17 @@ XXX The winner is the outermost setting 
       } else if (value.EqualsLiteral("false")) {
         mEmbellishData.flags &= ~NS_MATHML_EMBELLISH_ACCENTOVER;
       }
     }
   }
 
   bool subsupDisplay =
     NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
-    !NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags);
+    !StyleFont()->mDisplayStyle;
 
   // disable the stretch-all flag if we are going to act like a superscript
   if (subsupDisplay) {
     mPresentationData.flags &= ~NS_MATHML_STRETCH_ALL_CHILDREN_HORIZONTALLY;
   }
 
   // Now transmit any change that we want to our children so that they
   // can update their mPresentationData structs
@@ -248,61 +206,59 @@ XXX The winner is the outermost setting 
      cramped counterparts.
   */
   if (tag == nsGkAtoms::mover_ ||
       tag == nsGkAtoms::munderover_) {
     uint32_t compress = NS_MATHML_EMBELLISH_IS_ACCENTOVER(mEmbellishData.flags)
       ? NS_MATHML_COMPRESSED : 0;
     SetIncrementScriptLevel(tag == nsGkAtoms::mover_ ? 1 : 2,
                             !NS_MATHML_EMBELLISH_IS_ACCENTOVER(mEmbellishData.flags) || subsupDisplay);
-    PropagatePresentationDataFor(overscriptFrame,
-                                 ~NS_MATHML_DISPLAYSTYLE | compress,
-                                 NS_MATHML_DISPLAYSTYLE | compress);
+    PropagatePresentationDataFor(overscriptFrame, compress, compress);
   }
   /*
      The TeXBook treats 'under' like a subscript, so p.141 or Rule 13a 
      say it should be compressed
   */
   if (tag == nsGkAtoms::munder_ ||
       tag == nsGkAtoms::munderover_) {
     SetIncrementScriptLevel(1, !NS_MATHML_EMBELLISH_IS_ACCENTUNDER(mEmbellishData.flags) || subsupDisplay);
     PropagatePresentationDataFor(underscriptFrame,
-                                 ~NS_MATHML_DISPLAYSTYLE | NS_MATHML_COMPRESSED,
-                                 NS_MATHML_DISPLAYSTYLE | NS_MATHML_COMPRESSED);
+                                 NS_MATHML_COMPRESSED,
+                                 NS_MATHML_COMPRESSED);
   }
   return NS_OK;
 }
 
 /*
 The REC says:
 *  If the base is an operator with movablelimits="true" (or an embellished
    operator whose <mo> element core has movablelimits="true"), and
    displaystyle="false", then underscript and overscript are drawn in
    a subscript and superscript position, respectively. In this case, 
    the accent and accentunder attributes are ignored. This is often
    used for limits on symbols such as &sum;.
 
 i.e.,:
- if ( NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishDataflags) &&
-     !NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) {
+ if (NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishDataflags) &&
+     !StyleFont()->mDisplayStyle) {
   // place like subscript-superscript pair
  }
  else {
   // place like underscript-overscript pair
  }
 */
 
 /* virtual */ nsresult
 nsMathMLmunderoverFrame::Place(nsRenderingContext& aRenderingContext,
                                bool                 aPlaceOrigin,
                                nsHTMLReflowMetrics& aDesiredSize)
 {
   nsIAtom* tag = mContent->Tag();
-  if ( NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
-       !NS_MATHML_IS_DISPLAYSTYLE(mPresentationData.flags)) {
+  if (NS_MATHML_EMBELLISH_IS_MOVABLELIMITS(mEmbellishData.flags) &&
+      !StyleFont()->mDisplayStyle) {
     //place like sub sup or subsup
     nscoord scriptSpace = nsPresContext::CSSPointsToAppUnits(0.5f);
     if (tag == nsGkAtoms::munderover_) {
       return nsMathMLmmultiscriptsFrame::PlaceMultiScript(PresContext(),
                                                           aRenderingContext,
                                                           aPlaceOrigin,
                                                           aDesiredSize,
                                                           this, 0, 0,
diff --git a/layout/mathml/nsMathMLmunderoverFrame.h b/layout/mathml/nsMathMLmunderoverFrame.h
--- a/layout/mathml/nsMathMLmunderoverFrame.h
+++ b/layout/mathml/nsMathMLmunderoverFrame.h
@@ -30,22 +30,16 @@ public:
   NS_IMETHOD
   TransmitAutomaticData() MOZ_OVERRIDE;
 
   NS_IMETHOD
   UpdatePresentationData(uint32_t        aFlagsValues,
                          uint32_t        aFlagsToUpdate) MOZ_OVERRIDE;
 
   NS_IMETHOD
-  UpdatePresentationDataFromChildAt(int32_t         aFirstIndex,
-                                    int32_t         aLastIndex,
-                                    uint32_t        aFlagsValues,
-                                    uint32_t        aFlagsToUpdate) MOZ_OVERRIDE;
-
-  NS_IMETHOD
   AttributeChanged(int32_t         aNameSpaceID,
                    nsIAtom*        aAttribute,
                    int32_t         aModType) MOZ_OVERRIDE;
 
 protected:
   nsMathMLmunderoverFrame(nsStyleContext* aContext) : nsMathMLContainerFrame(aContext) {}
   virtual ~nsMathMLmunderoverFrame();
 };
