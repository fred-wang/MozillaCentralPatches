# HG changeset patch
# Parent e481991f20d6e6ea1f349362cd6a2a42b29c68cf
# User Frédéric Wang <fred.wang@free.fr>
Mirroring of operators for arabic math (Bug 208309)

diff --git a/layout/mathml/mathfont.properties b/layout/mathml/mathfont.properties
--- a/layout/mathml/mathfont.properties
+++ b/layout/mathml/mathfont.properties
@@ -121,18 +121,18 @@ mathvariant.monospace = A\ud835\ude70B\u
 
 operator.\u0021.postfix = lspace:1 rspace:0 # !
 operator.\u0021\u0021.postfix = lspace:1 rspace:0 # !!
 operator.\u0021\u003D.infix = lspace:4 rspace:4 # !=
 operator.\u0025.infix = lspace:3 rspace:3 # percent sign
 operator.\u0026.postfix = lspace:0 rspace:0 # &amp;
 operator.\u0026\u0026.infix = lspace:4 rspace:4 # &amp;&amp;
 operator.\u0027.postfix = lspace:0 rspace:0 accent # '
-operator.\u0028.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # (
-operator.\u0029.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # )
+operator.\u0028.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # (
+operator.\u0029.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # )
 operator.\u002A.infix = lspace:3 rspace:3 # *
 operator.\u002A\u002A.infix = lspace:1 rspace:1 # **
 operator.\u002A\u003D.infix = lspace:4 rspace:4 # *=
 operator.\u002B.infix = lspace:4 rspace:4 # +
 operator.\u002B.prefix = lspace:0 rspace:1 # +
 operator.\u002B\u002B.postfix = lspace:0 rspace:0 # ++
 operator.\u002B\u003D.infix = lspace:4 rspace:4 # +=
 operator.\u002C.infix = lspace:0 rspace:3 separator # ,
@@ -154,35 +154,35 @@ operator.\u003C.infix = lspace:5 rspace:
 operator.\u003C\u003D.infix = lspace:5 rspace:5 # &lt;=
 operator.\u003C\u003E.infix = lspace:1 rspace:1 # &lt;>
 operator.\u003D.infix = lspace:5 rspace:5 # =
 operator.\u003D\u003D.infix = lspace:4 rspace:4 # ==
 operator.\u003E.infix = lspace:5 rspace:5 # >
 operator.\u003E\u003D.infix = lspace:5 rspace:5 # >=
 operator.\u003F.infix = lspace:1 rspace:1 # ?
 operator.\u0040.infix = lspace:1 rspace:1 # @
-operator.\u005B.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # [
+operator.\u005B.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # [
 operator.\u005C.infix = lspace:0 rspace:0 # reverse solidus
-operator.\u005D.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # ]
+operator.\u005D.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # ]
 operator.\u005E.postfix = lspace:0 rspace:0 stretchy accent direction:horizontal # &Hat; circumflex accent
 operator.\u005E.infix = lspace:1 rspace:1 direction:horizontal # ^
 operator.\u005F.postfix = lspace:0 rspace:0 stretchy accent direction:horizontal # _ low line
 operator.\u005F.infix = lspace:2 rspace:2 stretchy direction:horizontal # _
 operator.\u0060.postfix = lspace:0 rspace:0 accent # &DiacriticalGrave;
-operator.\u007B.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # {
+operator.\u007B.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # {
 operator.\u007C.infix = lspace:2 rspace:2 stretchy fence symmetric direction:vertical # &VerticalLine; |
 operator.\u007C.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # |
 operator.\u007C.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # |
 operator.\u007C\u007C.infix = lspace:4 rspace:4 direction:vertical # ||
 operator.\u007C\u007C.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # multiple character operator: ||
 operator.\u007C\u007C.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # multiple character operator: ||
 operator.\u007C\u007C\u007C.infix = lspace:2 rspace:2 stretchy fence symmetric direction:vertical # multiple character operator: |||
 operator.\u007C\u007C\u007C.prefix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # multiple character operator: |||
 operator.\u007C\u007C\u007C.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # multiple character operator: |||
-operator.\u007D.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical # }
+operator.\u007D.postfix = lspace:0 rspace:0 stretchy fence symmetric direction:vertical mirrorable # }
 operator.\u007E.postfix = lspace:0 rspace:0 stretchy accent direction:horizontal # ~ tilde
 operator.\u00A8.postfix = lspace:0 rspace:0 accent # &DoubleDot;
 operator.\u00AC.prefix = lspace:2 rspace:1 # not sign
 operator.\u00AF.postfix = lspace:0 rspace:0 stretchy accent direction:horizontal # &OverBar;
 operator.\u00B0.postfix = lspace:0 rspace:0 # degree sign
 operator.\u00B1.infix = lspace:4 rspace:4 # &PlusMinus;
 operator.\u00B1.prefix = lspace:0 rspace:1 # &PlusMinus;
 operator.\u00B4.postfix = lspace:0 rspace:0 accent # &DiacriticalAcute;
@@ -342,51 +342,51 @@ operator.\u2208.infix = lspace:5 rspace:
 operator.\u2209.infix = lspace:5 rspace:5 # &NotElement;
 operator.\u220A.infix = lspace:5 rspace:5 # small element of
 operator.\u220B.infix = lspace:5 rspace:5 # &SuchThat; &ReverseElement;
 operator.\u220C.infix = lspace:5 rspace:5 # &NotReverseElement;
 operator.\u220D.infix = lspace:5 rspace:5 # small contains as member
 operator.\u220E.infix = lspace:3 rspace:3 # end of proof
 operator.\u220F.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical # &Product;
 operator.\u2210.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical # &Coproduct;
-operator.\u2211.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical # &Sum;
+operator.\u2211.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical mirrorable # &Sum;
 operator.\u2212.infix = lspace:4 rspace:4 # official Unicode minus sign
 operator.\u2212.prefix = lspace:0 rspace:1 # official Unicode minus sign
 operator.\u2213.infix = lspace:4 rspace:4 # &MinusPlus;
 operator.\u2213.prefix = lspace:0 rspace:1 # &MinusPlus;
 operator.\u2214.infix = lspace:4 rspace:4 # dot plus
 operator.\u2216.infix = lspace:3 rspace:3 stretchy direction:vertical # &Backslash;
 operator.\u2217.infix = lspace:4 rspace:4 # asterisk operator
 operator.\u2218.infix = lspace:4 rspace:4 # &SmallCircle;
 operator.\u2219.infix = lspace:4 rspace:4 # bullet operator
-operator.\u221A.prefix = lspace:1 rspace:1 stretchy direction:vertical # &Sqrt;
+operator.\u221A.prefix = lspace:1 rspace:1 stretchy direction:vertical mirrorable # &Sqrt;
 operator.\u221B.prefix = lspace:1 rspace:1 # cube root
 operator.\u221C.prefix = lspace:1 rspace:1 # fourth root
 operator.\u221D.infix = lspace:5 rspace:5 # &Proportional;
 operator.\u221F.infix = lspace:5 rspace:5 # right angle
 operator.\u2220.prefix = lspace:0 rspace:0 # angle
 operator.\u2221.prefix = lspace:0 rspace:0 # measured angle
 operator.\u2222.prefix = lspace:0 rspace:0 # spherical angle
 operator.\u2223.infix = lspace:5 rspace:5 stretchy direction:vertical # &VerticalBar;
 operator.\u2224.infix = lspace:5 rspace:5 # &NotVerticalBar;
 operator.\u2225.infix = lspace:5 rspace:5 stretchy direction:vertical # &DoubleVerticalBar;
 operator.\u2226.infix = lspace:5 rspace:5 # &NotDoubleVerticalBar;
 operator.\u2227.infix = lspace:4 rspace:4 # &wedge;
 operator.\u2228.infix = lspace:4 rspace:4 # &vee;
 operator.\u2229.infix = lspace:4 rspace:4 # &cap;
 operator.\u222A.infix = lspace:4 rspace:4 # &cup;
-operator.\u222B.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # &Integral;
-operator.\u222C.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # double integral
-operator.\u222D.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # triple integral
-operator.\u222E.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # &ContourIntegral;
-operator.\u222F.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # &DoubleContourIntegral;
-operator.\u2230.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # volume integral
-operator.\u2231.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # clockwise integral
-operator.\u2232.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # &ClockwiseContourIntegral;
-operator.\u2233.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # &CounterClockwiseContourIntegral;
+operator.\u222B.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # &Integral;
+operator.\u222C.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # double integral
+operator.\u222D.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # triple integral
+operator.\u222E.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # &ContourIntegral;
+operator.\u222F.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # &DoubleContourIntegral;
+operator.\u2230.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # volume integral
+operator.\u2231.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # clockwise integral
+operator.\u2232.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # &ClockwiseContourIntegral;
+operator.\u2233.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # &CounterClockwiseContourIntegral;
 operator.\u2234.infix = lspace:5 rspace:5 # &Therefore;
 operator.\u2235.infix = lspace:5 rspace:5 # &Because;
 operator.\u2236.infix = lspace:5 rspace:5 # ratio
 operator.\u2237.infix = lspace:5 rspace:5 # &Colon; &Proportion;
 operator.\u2238.infix = lspace:4 rspace:4 # dot minus
 operator.\u2239.infix = lspace:5 rspace:5 # excess
 operator.\u223A.infix = lspace:4 rspace:4 # geometric proportion
 operator.\u223B.infix = lspace:5 rspace:5 # homothetic
@@ -936,34 +936,34 @@ operator.\u2A02.prefix = lspace:1 rspace
 operator.\u2A03.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # n-ary union operator with dot
 operator.\u2A04.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical # &biguplus;
 operator.\u2A05.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # n-ary square intersection operator
 operator.\u2A06.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical # &bigsqcup;
 operator.\u2A07.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # two logical and operator
 operator.\u2A08.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # two logical or operator
 operator.\u2A09.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # n-ary times operator
 operator.\u2A0A.prefix = lspace:1 rspace:2 largeop movablelimits symmetric # modulo two sum
-operator.\u2A0B.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # summation with integral
-operator.\u2A0C.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral # quadruple integral operator
-operator.\u2A0D.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # finite part integral
-operator.\u2A0E.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with double stroke
-operator.\u2A0F.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral average with slash
-operator.\u2A10.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral # circulation function
-operator.\u2A11.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral # anticlockwise integration
-operator.\u2A12.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral # line integration with rectangular path around pole
-operator.\u2A13.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral # line integration with semicircular path around pole
-operator.\u2A14.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral # line integration not including the pole
-operator.\u2A15.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral around a point operator
-operator.\u2A16.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # quaternion integral operator
-operator.\u2A17.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with leftwards arrow with hook
-operator.\u2A18.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with times sign
-operator.\u2A19.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with intersection
-operator.\u2A1A.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with union
-operator.\u2A1B.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with overbar
-operator.\u2A1C.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral # integral with underbar
+operator.\u2A0B.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # summation with integral
+operator.\u2A0C.prefix = lspace:0 rspace:1 largeop symmetric direction:vertical integral mirrorable # quadruple integral operator
+operator.\u2A0D.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # finite part integral
+operator.\u2A0E.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with double stroke
+operator.\u2A0F.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral average with slash
+operator.\u2A10.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral mirrorable # circulation function
+operator.\u2A11.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral mirrorable # anticlockwise integration
+operator.\u2A12.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral mirrorable # line integration with rectangular path around pole
+operator.\u2A13.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral mirrorable # line integration with semicircular path around pole
+operator.\u2A14.prefix = lspace:1 rspace:2 largeop movablelimits symmetric direction:vertical integral mirrorable # line integration not including the pole
+operator.\u2A15.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral around a point operator
+operator.\u2A16.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # quaternion integral operator
+operator.\u2A17.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with leftwards arrow with hook
+operator.\u2A18.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with times sign
+operator.\u2A19.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with intersection
+operator.\u2A1A.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with union
+operator.\u2A1B.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with overbar
+operator.\u2A1C.prefix = lspace:1 rspace:2 largeop symmetric direction:vertical integral mirrorable # integral with underbar
 operator.\u2A1D.infix = lspace:3 rspace:3 # join
 operator.\u2A1E.infix = lspace:3 rspace:3 # large left triangle operator
 operator.\u2A1F.infix = lspace:3 rspace:3 # z notation schema composition
 operator.\u2A20.infix = lspace:3 rspace:3 # z notation schema piping
 operator.\u2A21.infix = lspace:3 rspace:3 # z notation schema projection
 operator.\u2A22.infix = lspace:4 rspace:4 # plus sign with small circle above
 operator.\u2A23.infix = lspace:4 rspace:4 # plus sign with circumflex accent above
 operator.\u2A24.infix = lspace:4 rspace:4 # plus sign with tilde above
diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -1810,24 +1810,28 @@ nsMathMLChar::StretchInternal(nsPresCont
 }
 
 nsresult
 nsMathMLChar::Stretch(nsPresContext*           aPresContext,
                       nsIRenderingContext&     aRenderingContext,
                       nsStretchDirection       aStretchDirection,
                       const nsBoundingMetrics& aContainerSize,
                       nsBoundingMetrics&       aDesiredStretchSize,
-                      PRUint32                 aStretchHint)
+                      PRUint32                 aStretchHint,
+                      PRBool                   aRTL)
 {
   NS_ASSERTION(!(aStretchHint &
                  ~(NS_STRETCH_VARIABLE_MASK | NS_STRETCH_LARGEOP |
                    NS_STRETCH_INTEGRAL)),
                "Unexpected stretch flags");
 
   mDrawNormal = PR_TRUE;
+  if (aRTL && nsMathMLOperators::IsMirrorableOperator(mData)) {
+    mMirrored = PR_TRUE;
+  }
   mScaleY = mScaleX = 1.0;
   mDirection = aStretchDirection;
   nsresult rv =
     StretchInternal(aPresContext, aRenderingContext, mDirection,
                     aContainerSize, aDesiredStretchSize, aStretchHint);
 
   // Record the metrics
   mBoundingMetrics = aDesiredStretchSize;
@@ -1908,20 +1912,21 @@ nsMathMLChar::ComposeChildren(nsPresCont
   }
   nscoord dx = 0, dy = 0;
   for (i = 0, child = mSibling; child; child = child->mSibling, i++) {
     // child chars should just inherit our values - which may change between calls...
     child->mData = mData;
     child->mDirection = mDirection;
     child->mStyleContext = mStyleContext;
     child->mGlyphTable = aGlyphTable; // the child is associated to this table
+    child->mMirrored = mMirrored;
     // there goes the Stretch() ...
     nsBoundingMetrics childSize;
     nsresult rv = child->Stretch(aPresContext, aRenderingContext, mDirection,
-                                 splitSize, childSize, aStretchHint);
+                                 splitSize, childSize, aStretchHint, mMirrored);
     // check if something went wrong or the child couldn't fit in the alloted space
     if (NS_FAILED(rv) || (NS_STRETCH_DIRECTION_UNSUPPORTED == child->mDirection)) {
       delete mSibling; // don't leave a dangling list behind ...
       mSibling = nsnull;
       return NS_ERROR_FAILURE;
     }
     child->SetRect(nsRect(dx, dy, childSize.width, childSize.ascent+childSize.descent));
     if (0 == i)
@@ -2137,18 +2142,23 @@ nsMathMLChar::Display(nsDisplayListBuild
         nsDisplayMathMLCharForeground(aBuilder, aForFrame, this,
                                       aSelectedRect && !aSelectedRect->IsEmpty()));
 }
 
 void
 nsMathMLChar::ApplyTransforms(nsIRenderingContext& aRenderingContext, nsRect &r)
 {
   // apply the transforms
-  aRenderingContext.Translate(r.x, r.y);
-  aRenderingContext.Scale(mScaleX, mScaleY);
+  if (mMirrored) {
+    aRenderingContext.Translate(r.x + r.width, r.y);
+    aRenderingContext.Scale(-mScaleX, mScaleY);
+  } else {
+    aRenderingContext.Translate(r.x, r.y);
+    aRenderingContext.Scale(mScaleX, mScaleY);
+  }
 
   // update the bounding rectangle.
   r.x = r.y = 0;
   r.width /= mScaleX;
   r.height /= mScaleY;
 }
 
 void
diff --git a/layout/mathml/nsMathMLChar.h b/layout/mathml/nsMathMLChar.h
--- a/layout/mathml/nsMathMLChar.h
+++ b/layout/mathml/nsMathMLChar.h
@@ -107,16 +107,17 @@ public:
   nsMathMLChar(nsMathMLChar* aParent = nsnull) {
     MOZ_COUNT_CTOR(nsMathMLChar);
     mStyleContext = nsnull;
     mSibling = nsnull;
     mParent = aParent;
     mUnscaledAscent = 0;
     mScaleX = mScaleY = 1.0;
     mDrawNormal = PR_TRUE;
+    mMirrored = PR_FALSE;
   }
 
   ~nsMathMLChar() { // not a virtual destructor: this class is not intended to be subclassed
     MOZ_COUNT_DTOR(nsMathMLChar);
     // there is only one style context owned by the "root" char
     // and it may be used by child chars as well
     if (!mParent && mStyleContext) { // only the "root" need to release it
       mStyleContext->Release();
@@ -141,17 +142,18 @@ public:
   // @param aContainerSize - IN - suggested size for the stretched char
   // @param aDesiredStretchSize - OUT - the size that the char wants
   nsresult
   Stretch(nsPresContext*           aPresContext,
           nsIRenderingContext&     aRenderingContext,
           nsStretchDirection       aStretchDirection,
           const nsBoundingMetrics& aContainerSize,
           nsBoundingMetrics&       aDesiredStretchSize,
-          PRUint32                 aStretchHint = NS_STRETCH_NORMAL);
+          PRUint32                 aStretchHint,
+          PRBool                   aRTL);
 
   void
   SetData(nsPresContext* aPresContext,
           nsString&       aData);
 
   void
   GetData(nsString& aData) {
     aData = mData;
@@ -253,16 +255,17 @@ private:
   // from the family in the nsStyleContext.
   nsString           mFamily;
   // mUnscaledAscent is the actual ascent of the char.
   nscoord            mUnscaledAscent;
   // mScaleX, mScaleY are the factors by which we scale the char.
   float              mScaleX, mScaleY;
   // mDrawNormal indicates whether we use special glyphs or not.
   PRPackedBool       mDrawNormal;
+  PRPackedBool       mMirrored;
 
   class StretchEnumContext;
   friend class StretchEnumContext;
 
   // helper methods
   nsresult
   StretchInternal(nsPresContext*           aPresContext,
                   nsIRenderingContext&     aRenderingContext,
diff --git a/layout/mathml/nsMathMLOperators.cpp b/layout/mathml/nsMathMLOperators.cpp
--- a/layout/mathml/nsMathMLOperators.cpp
+++ b/layout/mathml/nsMathMLOperators.cpp
@@ -112,16 +112,18 @@ SetBooleanProperty(OperatorData* aOperat
   else if (aName.EqualsLiteral("separator"))
     aOperatorData->mFlags |=  NS_MATHML_OPERATOR_SEPARATOR;
   else if (aName.EqualsLiteral("movablelimits"))
     aOperatorData->mFlags |= NS_MATHML_OPERATOR_MOVABLELIMITS;
   else if (aName.EqualsLiteral("symmetric"))
     aOperatorData->mFlags |= NS_MATHML_OPERATOR_SYMMETRIC;
   else if (aName.EqualsLiteral("integral"))
     aOperatorData->mFlags |= NS_MATHML_OPERATOR_INTEGRAL;
+  else if (aName.EqualsLiteral("mirrorable"))
+    aOperatorData->mFlags |= NS_MATHML_OPERATOR_MIRRORABLE;
 }
 
 static void
 SetProperty(OperatorData* aOperatorData,
             nsString      aName,
             nsString      aValue)
 {
   if (aName.IsEmpty() || aValue.IsEmpty())
@@ -510,16 +512,30 @@ nsMathMLOperators::IsMutableOperator(con
   nsOperatorFlags allFlags =
     flags[NS_MATHML_OPERATOR_FORM_INFIX] |
     flags[NS_MATHML_OPERATOR_FORM_POSTFIX] |
     flags[NS_MATHML_OPERATOR_FORM_PREFIX];
   return NS_MATHML_OPERATOR_IS_STRETCHY(allFlags) ||
          NS_MATHML_OPERATOR_IS_LARGEOP(allFlags);
 }
 
+/* static */ PRBool
+nsMathMLOperators::IsMirrorableOperator(const nsString& aOperator)
+{
+  // LookupOperator will search infix, postfix and prefix forms of aOperator and
+  // return the first form found. It is assumed that all these forms have same
+  // mirrorability.
+  nsOperatorFlags flags = 0;
+  float dummy;
+  nsMathMLOperators::LookupOperator(aOperator,
+                                    NS_MATHML_OPERATOR_FORM_INFIX,
+                                    &flags, &dummy, &dummy);
+  return NS_MATHML_OPERATOR_IS_MIRRORABLE(flags);
+}
+
 /* static */ nsStretchDirection
 nsMathMLOperators::GetStretchyDirection(const nsString& aOperator)
 {
   // LookupOperator will search infix, postfix and prefix forms of aOperator and
   // return the first form found. It is assumed that all these forms have same
   // direction.
   nsOperatorFlags flags = 0;
   float dummy;
diff --git a/layout/mathml/nsMathMLOperators.h b/layout/mathml/nsMathMLOperators.h
--- a/layout/mathml/nsMathMLOperators.h
+++ b/layout/mathml/nsMathMLOperators.h
@@ -76,22 +76,23 @@ enum {
   NS_MATHML_OPERATOR_STRETCHY           = 1<<4,
   NS_MATHML_OPERATOR_FENCE              = 1<<5,
   NS_MATHML_OPERATOR_ACCENT             = 1<<6,
   NS_MATHML_OPERATOR_LARGEOP            = 1<<7,
   NS_MATHML_OPERATOR_SEPARATOR          = 1<<8,
   NS_MATHML_OPERATOR_MOVABLELIMITS      = 1<<9,
   NS_MATHML_OPERATOR_SYMMETRIC          = 1<<10,
   NS_MATHML_OPERATOR_INTEGRAL           = 1<<11,
+  NS_MATHML_OPERATOR_MIRRORABLE         = 1<<12,
 
   // Additional bits not stored in the dictionary
-  NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE   = 1<<12,
-  NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE   = 1<<13,
-  NS_MATHML_OPERATOR_LEFTSPACE_ATTR     = 1<<14,
-  NS_MATHML_OPERATOR_RIGHTSPACE_ATTR    = 1<<15
+  NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE   = 1<<13,
+  NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE   = 1<<14,
+  NS_MATHML_OPERATOR_LEFTSPACE_ATTR     = 1<<15,
+  NS_MATHML_OPERATOR_RIGHTSPACE_ATTR    = 1<<16
 };
 
 #define NS_MATHML_OPERATOR_SIZE_INFINITY NS_IEEEPositiveInfinity()
 
 // Style invariant characters (chars have their own intrinsic predefined style)
 enum eMATHVARIANT {
   eMATHVARIANT_NONE = -1,
   eMATHVARIANT_normal = 0,
@@ -144,17 +145,18 @@ public:
                    float*                aLeftSpace,
                    float*                aRightSpace);
 
   // IsMutableOperator:
   // Return true if the operator exists and is stretchy or largeop
   static PRBool
   IsMutableOperator(const nsString& aOperator);
 
-  // Helper function used by the nsMathMLChar class.
+  // Helper functions used by the nsMathMLChar class.
+  static PRBool IsMirrorableOperator(const nsString& aOperator);
   static nsStretchDirection GetStretchyDirection(const nsString& aOperator);
 
   // Return the variant type of one Unicode Mathematical Alphanumeric Symbol
   // character (which may be represented by a surrogate pair), or return
   // eMATHVARIANT_NONE if aChar is not such a character.
   static eMATHVARIANT LookupInvariantChar(const nsAString& aChar);
 
   // Return the styled Mathematical Alphanumeric Symbol character
@@ -224,16 +226,19 @@ public:
   (NS_MATHML_OPERATOR_MOVABLELIMITS == ((_flags) & NS_MATHML_OPERATOR_MOVABLELIMITS))
 
 #define NS_MATHML_OPERATOR_IS_SYMMETRIC(_flags) \
   (NS_MATHML_OPERATOR_SYMMETRIC == ((_flags) & NS_MATHML_OPERATOR_SYMMETRIC))
 
 #define NS_MATHML_OPERATOR_IS_INTEGRAL(_flags) \
   (NS_MATHML_OPERATOR_INTEGRAL == ((_flags) & NS_MATHML_OPERATOR_INTEGRAL))
 
+#define NS_MATHML_OPERATOR_IS_MIRRORABLE(_flags) \
+  (NS_MATHML_OPERATOR_MIRRORABLE == ((_flags) & NS_MATHML_OPERATOR_MIRRORABLE))
+
 #define NS_MATHML_OPERATOR_MINSIZE_IS_ABSOLUTE(_flags) \
   (NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE == ((_flags) & NS_MATHML_OPERATOR_MINSIZE_ABSOLUTE))
 
 #define NS_MATHML_OPERATOR_MAXSIZE_IS_ABSOLUTE(_flags) \
   (NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE == ((_flags) & NS_MATHML_OPERATOR_MAXSIZE_ABSOLUTE))
 
 #define NS_MATHML_OPERATOR_HAS_LEFTSPACE_ATTR(_flags) \
   (NS_MATHML_OPERATOR_LEFTSPACE_ATTR == ((_flags) & NS_MATHML_OPERATOR_LEFTSPACE_ATTR))
diff --git a/layout/mathml/nsMathMLmencloseFrame.cpp b/layout/mathml/nsMathMLmencloseFrame.cpp
--- a/layout/mathml/nsMathMLmencloseFrame.cpp
+++ b/layout/mathml/nsMathMLmencloseFrame.cpp
@@ -499,17 +499,17 @@ nsMathMLmencloseFrame::PlaceInternal(nsI
       nsBoundingMetrics contSize = bmBase;
       contSize.ascent = mRuleThickness;
       contSize.descent = bmBase.ascent + bmBase.descent + psi;
 
       // height(longdiv) should be >= height(base) + psi + mRuleThickness
       mMathMLChar[mLongDivCharIndex].Stretch(PresContext(), aRenderingContext,
                                              NS_STRETCH_DIRECTION_VERTICAL,
                                              contSize, bmLongdivChar,
-                                             NS_STRETCH_LARGER);
+                                             NS_STRETCH_LARGER, PR_FALSE);
       mMathMLChar[mLongDivCharIndex].GetBoundingMetrics(bmLongdivChar);
 
       // Update horizontal parameters
       dx_left = NS_MAX(dx_left, bmLongdivChar.width);
 
       // Update vertical parameters
       longdivAscent = bmBase.ascent + psi + mRuleThickness;
       longdivDescent = NS_MAX(bmBase.descent,
@@ -541,17 +541,18 @@ nsMathMLmencloseFrame::PlaceInternal(nsI
       nsBoundingMetrics contSize = bmBase;
       contSize.ascent = mRuleThickness;
       contSize.descent = bmBase.ascent + bmBase.descent + psi;
 
       // height(radical) should be >= height(base) + psi + mRuleThickness
       mMathMLChar[mRadicalCharIndex].Stretch(PresContext(), aRenderingContext,
                                              NS_STRETCH_DIRECTION_VERTICAL,
                                              contSize, bmRadicalChar,
-                                             NS_STRETCH_LARGER);
+                                             NS_STRETCH_LARGER,
+                                             NS_MATHML_IS_RTL(mPresentationData.flags));
       mMathMLChar[mRadicalCharIndex].GetBoundingMetrics(bmRadicalChar);
 
       // Update horizontal parameters
       dx = NS_MAX(dx, bmRadicalChar.width);
 
       // Update vertical parameters
       radicalAscent = bmBase.ascent + psi + mRuleThickness;
       radicalDescent = NS_MAX(bmBase.descent,
diff --git a/layout/mathml/nsMathMLmfencedFrame.cpp b/layout/mathml/nsMathMLmfencedFrame.cpp
--- a/layout/mathml/nsMathMLmfencedFrame.cpp
+++ b/layout/mathml/nsMathMLmfencedFrame.cpp
@@ -353,29 +353,32 @@ nsMathMLmfencedFrame::Reflow(nsPresConte
     containerSize.ascent = delta + axisHeight;
     containerSize.descent = delta - axisHeight;
   }
 
   /////////////////
   // opening fence ...
   ReflowChar(aPresContext, *aReflowState.rendContext, mOpenChar,
              NS_MATHML_OPERATOR_FORM_PREFIX, font->mScriptLevel, 
-             axisHeight, leading, em, containerSize, ascent, descent);
+             axisHeight, leading, em, containerSize, ascent, descent,
+             NS_MATHML_IS_RTL(mPresentationData.flags));
   /////////////////
   // separators ...
   for (i = 0; i < mSeparatorsCount; i++) {
     ReflowChar(aPresContext, *aReflowState.rendContext, &mSeparatorsChar[i],
                NS_MATHML_OPERATOR_FORM_INFIX, font->mScriptLevel,
-               axisHeight, leading, em, containerSize, ascent, descent);
+               axisHeight, leading, em, containerSize, ascent, descent,
+               NS_MATHML_IS_RTL(mPresentationData.flags));
   }
   /////////////////
   // closing fence ...
   ReflowChar(aPresContext, *aReflowState.rendContext, mCloseChar,
              NS_MATHML_OPERATOR_FORM_POSTFIX, font->mScriptLevel,
-             axisHeight, leading, em, containerSize, ascent, descent);
+             axisHeight, leading, em, containerSize, ascent, descent,
+             NS_MATHML_IS_RTL(mPresentationData.flags));
 
   //////////////////
   // Adjust the origins of each child.
   // and update our bounding metrics
 
   i = 0;
   nscoord dx = 0;
   nsBoundingMetrics bm;
@@ -490,28 +493,30 @@ nsMathMLmfencedFrame::ReflowChar(nsPresC
                                  nsMathMLChar*        aMathMLChar,
                                  nsOperatorFlags      aForm,
                                  PRInt32              aScriptLevel,
                                  nscoord              axisHeight,
                                  nscoord              leading,
                                  nscoord              em,
                                  nsBoundingMetrics&   aContainerSize,
                                  nscoord&             aAscent,
-                                 nscoord&             aDescent)
+                                 nscoord&             aDescent,
+                                 PRBool               aRTL)
 {
   if (aMathMLChar && 0 < aMathMLChar->Length()) {
     nscoord leftSpace;
     nscoord rightSpace;
     GetCharSpacing(aMathMLChar, aForm, aScriptLevel, em, leftSpace, rightSpace);
 
     // stretch the char to the appropriate height if it is not big enough.
     nsBoundingMetrics charSize;
     nsresult res = aMathMLChar->Stretch(aPresContext, aRenderingContext,
                                         NS_STRETCH_DIRECTION_VERTICAL,
-                                        aContainerSize, charSize);
+                                        aContainerSize, charSize,
+                                        NS_STRETCH_NORMAL, aRTL);
 
     if (NS_STRETCH_DIRECTION_UNSUPPORTED != aMathMLChar->GetStretchDirection()) {
       // has changed... so center the char around the axis
       nscoord height = charSize.ascent + charSize.descent;
       charSize.ascent = height/2 + axisHeight;
       charSize.descent = height - charSize.ascent;
     }
     else {
diff --git a/layout/mathml/nsMathMLmfencedFrame.h b/layout/mathml/nsMathMLmfencedFrame.h
--- a/layout/mathml/nsMathMLmfencedFrame.h
+++ b/layout/mathml/nsMathMLmfencedFrame.h
@@ -100,17 +100,18 @@ public:
              nsMathMLChar*        aMathMLChar,
              nsOperatorFlags      aForm,
              PRInt32              aScriptLevel,
              nscoord              axisHeight,
              nscoord              leading,
              nscoord              em,
              nsBoundingMetrics&   aContainerSize,
              nscoord&             aAscent,
-             nscoord&             aDescent);
+             nscoord&             aDescent,
+             PRBool               aRTL);
 
   static void
   PlaceChar(nsMathMLChar*      aMathMLChar,
             nscoord            aDesiredSize,
             nsBoundingMetrics& bm,
             nscoord&           dx);
 
 protected:
diff --git a/layout/mathml/nsMathMLmoFrame.cpp b/layout/mathml/nsMathMLmoFrame.cpp
--- a/layout/mathml/nsMathMLmoFrame.cpp
+++ b/layout/mathml/nsMathMLmoFrame.cpp
@@ -765,17 +765,17 @@ nsMathMLmoFrame::Stretch(nsIRenderingCon
           container.descent = aContainerSize.descent;
           container.ascent = height - container.descent;
         }
       }
     }
 
     // let the MathMLChar stretch itself...
     nsresult res = mMathMLChar.Stretch(PresContext(), aRenderingContext,
-                                       aStretchDirection, container, charSize, stretchHint);
+                                       aStretchDirection, container, charSize, stretchHint, NS_MATHML_IS_RTL(mPresentationData.flags));
     if (NS_FAILED(res)) {
       // gracefully handle cases where stretching the char failed (i.e., GetBoundingMetrics failed)
       // clear our 'form' to behave as if the operator wasn't in the dictionary
       mFlags &= ~NS_MATHML_OPERATOR_FORM;
       useMathMLChar = PR_FALSE;
     }
   }
 
diff --git a/layout/mathml/nsMathMLmrootFrame.cpp b/layout/mathml/nsMathMLmrootFrame.cpp
--- a/layout/mathml/nsMathMLmrootFrame.cpp
+++ b/layout/mathml/nsMathMLmrootFrame.cpp
@@ -309,17 +309,18 @@ nsMathMLmrootFrame::Reflow(nsPresContext
   contSize.descent = bmBase.ascent + bmBase.descent + psi;
   contSize.ascent = ruleThickness;
 
   // height(radical) should be >= height(base) + psi + ruleThickness
   nsBoundingMetrics radicalSize;
   mSqrChar.Stretch(aPresContext, renderingContext,
                    NS_STRETCH_DIRECTION_VERTICAL, 
                    contSize, radicalSize,
-                   NS_STRETCH_LARGER);
+                   NS_STRETCH_LARGER,
+                   NS_MATHML_IS_RTL(mPresentationData.flags));
   // radicalSize have changed at this point, and should match with
   // the bounding metrics of the char
   mSqrChar.GetBoundingMetrics(bmSqr);
 
   // Update the desired size for the container (like msqrt, index is not yet included)
   // the baseline will be that of the base.
   mBoundingMetrics.ascent = bmBase.ascent + psi + ruleThickness;
   mBoundingMetrics.descent = 
