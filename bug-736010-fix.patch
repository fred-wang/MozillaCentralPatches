# HG changeset patch
# User Fran√ßois Wang <francoiswang@gmail.com>
# Date 1332776984 -7200
# Node ID 2fd76df6d482e54bc7d36cc2da43fe4f5c6a19f1
# Parent  f6d38b80417c935b9d73e3c2e61137970f7725f1
(downloaded-stretchy) Make downloaded fonts usable in nsMathMLChar

diff --git a/layout/mathml/nsMathMLChar.cpp b/layout/mathml/nsMathMLChar.cpp
--- a/layout/mathml/nsMathMLChar.cpp
+++ b/layout/mathml/nsMathMLChar.cpp
@@ -1036,35 +1036,45 @@ insert:
                      p_name - p_begin);
   }
   else { // whitespace or empty
     aFontName = aFallbackFamilies;
   }
 }
 
 // Update the font and rendering context if there is a family change
-static void
+static bool
 SetFontFamily(nsStyleContext*      aStyleContext,
               nsRenderingContext&  aRenderingContext,
               nsFont&              aFont,
               const nsGlyphTable*  aGlyphTable,
               const nsGlyphCode&   aGlyphCode,
               const nsAString&     aDefaultFamily)
 {
   const nsAString& family =
     aGlyphCode.font ? aGlyphTable->FontNameFor(aGlyphCode) : aDefaultFamily;
   if (! family.Equals(aFont.name)) {
-    aFont.name = family;
+    nsFont font = aFont;
+    font.name = family;
     nsRefPtr<nsFontMetrics> fm;
-    aRenderingContext.DeviceContext()->GetMetricsFor(aFont,
+    aRenderingContext.DeviceContext()->GetMetricsFor(font,
       aStyleContext->GetStyleFont()->mLanguage,
       aStyleContext->PresContext()->GetUserFontSet(),
       *getter_AddRefs(fm));
-    aRenderingContext.SetFont(fm);
+    // Set the font if it is an unicode table
+    // or if the same family name has been found
+    if (aGlyphTable == &gGlyphTableList->mUnicodeTable ||
+        fm->GetThebesFontGroup()->GetFontAt(0)->GetFontEntry()->
+        FamilyName() == family) {
+      aFont.name = family;
+      aRenderingContext.SetFont(fm);
+    } else
+        return false; // We did not set the font
   }
+  return true;
 }
 
 class nsMathMLChar::StretchEnumContext {
 public:
   StretchEnumContext(nsMathMLChar*        aChar,
                      nsPresContext*       aPresContext,
                      nsRenderingContext& aRenderingContext,
                      nsStretchDirection   aStretchDirection,
@@ -1084,19 +1094,16 @@ public:
       mTryVariants(true),
       mTryParts(true),
       mGlyphFound(aGlyphFound) {}
 
   static bool
   EnumCallback(const nsString& aFamily, bool aGeneric, void *aData);
 
 private:
-  static bool
-  ResolverCallback (const nsAString& aFamily, void *aData);
-
   bool TryVariants(nsGlyphTable* aGlyphTable, const nsAString& aFamily);
   bool TryParts(nsGlyphTable* aGlyphTable, const nsAString& aFamily);
 
   nsMathMLChar* mChar;
   nsPresContext* mPresContext;
   nsRenderingContext& mRenderingContext;
   const nsStretchDirection mDirection;
   const nscoord mTargetSize;
@@ -1145,17 +1152,22 @@ nsMathMLChar::StretchEnumContext::TryVar
 #ifdef NOISY_SEARCH
   printf("  searching in %s ...\n",
            NS_LossyConvertUTF16toASCII(aFamily).get());
 #endif
 
   nsGlyphCode ch;
   while ((ch = aGlyphTable->BigOf(mPresContext, mChar, size)).Exists()) {
 
-    SetFontFamily(sc, mRenderingContext, font, aGlyphTable, ch, aFamily);
+    if(!SetFontFamily(sc, mRenderingContext, font, aGlyphTable, ch, aFamily)) {
+      // if largeopOnly is set, break now
+      if (largeopOnly) break;
+      ++size;
+      continue;
+    }
 
     NS_ASSERTION(maxWidth || ch.code[0] != mChar->mGlyph.code[0] ||
                  ch.code[1] != mChar->mGlyph.code[1] ||
                  !font.name.Equals(mChar->mFamily),
                  "glyph table incorrectly set -- duplicate found");
 
     nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
                                                                 ch.Length());
@@ -1269,18 +1281,20 @@ nsMathMLChar::StretchEnumContext::TryPar
     if (!ch.Exists()) ch = glue;
     chdata[i] = ch;
     if (!ch.Exists()) {
       // Null glue indicates that a rule will be drawn, which can stretch to
       // fill any space.  Leave bounding metrics at 0.
       sizedata[i] = mTargetSize;
     }
     else {
-      SetFontFamily(mChar->mStyleContext, mRenderingContext,
-                    font, aGlyphTable, ch, aFamily);
+      if (!SetFontFamily(mChar->mStyleContext, mRenderingContext,
+                         font, aGlyphTable, ch, aFamily))
+        return false;
+
       nsBoundingMetrics bm = mRenderingContext.GetBoundingMetrics(ch.code,
                                                                   ch.Length());
 
       // TODO: For the generic Unicode table, ideally we should check that the
       // glyphs are actually found and that they each come from the same
       // font.
       bmdata[i] = bm;
       sizedata[i] = isVertical ? bm.ascent + bm.descent
@@ -1365,48 +1379,16 @@ nsMathMLChar::StretchEnumContext::TryPar
   // reset
   mChar->mGlyph = kNullGlyph; // this will tell paint to build by parts
   mChar->mGlyphTable = aGlyphTable;
   mChar->mFamily = aFamily;
 
   return IsSizeOK(mPresContext, computedSize, mTargetSize, mStretchHint);
 }
 
-// This is only called for glyph table corresponding to a family that exists.
-// See if the table has a glyph that matches the container
-bool
-nsMathMLChar::StretchEnumContext::ResolverCallback (const nsAString& aFamily,
-                                                    void *aData)
-{
-  StretchEnumContext* context = static_cast<StretchEnumContext*>(aData);
-  nsGlyphTable* glyphTable = context->mGlyphTable;
-
-  // Only try this table once.
-  context->mTablesTried.AppendElement(glyphTable);
-
-  // If the unicode table is being used, then search all font families.  If a
-  // special table is being used then the font in this family should have the
-  // specified glyphs.
-  const nsAString& family = glyphTable == &gGlyphTableList->mUnicodeTable ?
-    context->mFamilies : aFamily;
-
-  if(context->mTryVariants) {
-    bool isOK = context->TryVariants(glyphTable, family);
-    if (isOK)
-      return false; // no need to continue
-  }
-
-  if(context->mTryParts) {
-    bool isOK = context->TryParts(glyphTable, family);
-    if (isOK)
-      return false; // no need to continue
-  }
-  return true;
-}
-
 // This is called for each family, whether it exists or not
 bool
 nsMathMLChar::StretchEnumContext::EnumCallback(const nsString& aFamily,
                                                bool aGeneric, void *aData)
 {
   StretchEnumContext* context = static_cast<StretchEnumContext*>(aData);
 
   // See if there is a special table for the family, but always use the
@@ -1414,24 +1396,32 @@ nsMathMLChar::StretchEnumContext::EnumCa
   nsGlyphTable* glyphTable = aGeneric ?
     &gGlyphTableList->mUnicodeTable : gGlyphTableList->GetGlyphTableFor(aFamily);
 
   if (context->mTablesTried.Contains(glyphTable))
     return true; // already tried this one
 
   context->mGlyphTable = glyphTable;
 
-  if (aGeneric)
-    return ResolverCallback(aFamily, aData);
+  // Now see if the table has a glyph that matches the container
 
-  bool aborted;
-  gfxPlatform *pf = gfxPlatform::GetPlatform();
-  nsresult rv =
-    pf->ResolveFontName(aFamily, ResolverCallback, aData, aborted);
-  return NS_SUCCEEDED(rv) && !aborted; // true means continue
+  // Only try this table once.
+  context->mTablesTried.AppendElement(glyphTable);
+
+  // If the unicode table is being used, then search all font families.  If a
+  // special table is being used then the font in this family should have the
+  // specified glyphs.
+  const nsAString& family = glyphTable == &gGlyphTableList->mUnicodeTable ?
+    context->mFamilies : aFamily;
+
+  if((context->mTryVariants && context->TryVariants(glyphTable, family)) ||
+     (context->mTryParts && context->TryParts(glyphTable, family)))
+    return false; // no need to continue
+
+  return true; // true means continue
 }
 
 nsresult
 nsMathMLChar::StretchInternal(nsPresContext*           aPresContext,
                               nsRenderingContext&     aRenderingContext,
                               nsStretchDirection&      aStretchDirection,
                               const nsBoundingMetrics& aContainerSize,
                               nsBoundingMetrics&       aDesiredStretchSize,
