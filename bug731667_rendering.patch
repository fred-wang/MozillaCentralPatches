# User Quentin Headen <qheaden@phaseshiftsoftware.com>
Bug 731667 - Rewrite mtable implementation to avoid use of _moz-* attributes - implement rendering. r=karlt, r=bz

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5702,16 +5702,23 @@ nsBlockFrame::DeleteNextInFlowChild(nsPr
       nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
     }
 #endif
     DoRemoveFrame(aNextInFlow,
         aDeletingEmptyFrames ? FRAMES_ARE_EMPTY : 0);
   }
 }
 
+const nsStyleText*
+nsBlockFrame::StyleTextForLineLayout()
+{
+  // Return the pointer to an unmodified style text
+  return StyleText();
+}
+
 ////////////////////////////////////////////////////////////////////////
 // Float support
 
 nsRect
 nsBlockFrame::AdjustFloatAvailableSpace(nsBlockReflowState& aState,
                                         const nsRect& aFloatAvailableSpace,
                                         nsIFrame* aFloatFrame)
 {
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -310,16 +310,24 @@ public:
                               nsIFrame*      aChild,
                               bool           aForceNormal = false) MOZ_OVERRIDE;
 
   virtual void DeleteNextInFlowChild(nsPresContext* aPresContext,
                                      nsIFrame*      aNextInFlow,
                                      bool           aDeletingEmptyFrames) MOZ_OVERRIDE;
 
   /**
+    * This is a special method that allows a child class of nsBlockFrame to
+    * return a special, customized nsStyleText object to the nsLineLayout
+    * constructor. It is used when the nsBlockFrame child needs to specify its
+    * custom rendering style.
+    */
+  virtual const nsStyleText* StyleTextForLineLayout();
+
+  /**
    * Determines whether the collapsed margin carried out of the last
    * line includes the margin-top of a line with clearance (in which
    * case we must avoid collapsing that margin with our bottom margin)
    */
   bool CheckForCollapsedBottomMarginFromClearanceLine();
 
   static nsresult GetCurrentLine(nsBlockReflowState *aState, nsLineBox **aOutCurrentLine);
 
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -78,17 +78,22 @@ nsLineLayout::nsLineLayout(nsPresContext
 {
   MOZ_ASSERT(aOuterReflowState, "aOuterReflowState must not be null");
   NS_ASSERTION(aFloatManager || aOuterReflowState->frame->GetType() ==
                                   nsGkAtoms::letterFrame,
                "float manager should be present");
   MOZ_COUNT_CTOR(nsLineLayout);
 
   // Stash away some style data that we need
-  mStyleText = aOuterReflowState->frame->StyleText();
+  nsBlockFrame* blockFrame = do_QueryFrame(aOuterReflowState->frame);
+  if (blockFrame)
+    mStyleText = blockFrame->StyleTextForLineLayout();
+  else
+    mStyleText = aOuterReflowState->frame->StyleText();
+
   mLineNumber = 0;
   mTotalPlacedFrames = 0;
   mTopEdge = 0;
   mTrimmableWidth = 0;
 
   mInflationMinFontSize =
     nsLayoutUtils::InflationMinFontSizeFor(aOuterReflowState->frame);
 
@@ -197,17 +202,18 @@ nsLineLayout::BeginLineReflow(nscoord aX
     if (maxLineBoxWidth > 0 &&
         psd->mRightEdge - psd->mLeftEdge > maxLineBoxWidth) {
       psd->mRightEdge = psd->mLeftEdge + maxLineBoxWidth;
     }
   }
 
   mTopEdge = aY;
 
-  psd->mNoWrap = !mStyleText->WhiteSpaceCanWrap(LineContainerFrame());
+  psd->mNoWrap =
+    !mStyleText->WhiteSpaceCanWrapStyle() || LineContainerFrame()->IsSVGText();
   psd->mDirection = aDirection;
   psd->mChangedFrameDirection = false;
 
   // If this is the first line of a block then see if the text-indent
   // property amounts to anything.
 
   if (0 == mLineNumber && !HasPrevInFlow(mBlockReflowState->frame)) {
     const nsStyleCoord &textIndent = mStyleText->mTextIndent;
diff --git a/layout/mathml/nsMathMLmtableFrame.cpp b/layout/mathml/nsMathMLmtableFrame.cpp
--- a/layout/mathml/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/nsMathMLmtableFrame.cpp
@@ -4,16 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMathMLmtableFrame.h"
 #include "nsPresContext.h"
 #include "nsStyleContext.h"
 #include "nsStyleConsts.h"
 #include "nsINameSpaceManager.h"
 #include "nsRenderingContext.h"
+#include "nsCSSRendering.h"
 
 #include "nsTArray.h"
 #include "nsTableFrame.h"
 #include "celldata.h"
 
 #include "RestyleManager.h"
 #include <algorithm>
 
@@ -120,16 +121,86 @@ GetValueAt(nsIFrame*                    
     props.Set(aProperty, valueList);
   }
   int32_t count = valueList->mArray.Length();
   return (aRowOrColIndex < count)
          ? valueList->mArray[aRowOrColIndex]
          : valueList->mArray[count-1];
 }
 
+/*
+ * A variant of the nsDisplayBorder contains special code to render a border
+ * around a nsMathMLmtdFrame based on the rowline and columnline properties
+ * set on the cell frame.
+ */
+class nsDisplaymtdBorder : public nsDisplayBorder {
+public:
+  nsDisplaymtdBorder(nsDisplayListBuilder* aBuilder, nsMathMLmtdFrame* aFrame)
+    : nsDisplayBorder(aBuilder, aFrame)
+  {
+  }
+
+  virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx) MOZ_OVERRIDE
+  {
+    int32_t rowIndex;
+    int32_t columnIndex;
+    static_cast<nsTableCellFrame*>(mFrame)->
+      GetCellIndexes(rowIndex, columnIndex);
+
+    nsStyleBorder styleBorder = *mFrame->StyleBorder();
+    nscoord borderWidth =
+      mFrame->PresContext()->GetBorderWidthTable()[NS_STYLE_BORDER_WIDTH_THIN];
+
+    nsTArray<int8_t>* rowLinesList =
+      FindCellProperty(mFrame, RowLinesProperty());
+
+    nsTArray<int8_t>* columnLinesList =
+      FindCellProperty(mFrame, ColumnLinesProperty());
+
+    // We don't place a row line on top of the first row
+    if (rowIndex > 0 && rowLinesList) {
+      // If the row number is greater than the number of provided rowline
+      // values, we simply repeat the last value.
+      int32_t listLength = rowLinesList->Length();
+      if (rowIndex < listLength) {
+        styleBorder.SetBorderStyle(NS_SIDE_TOP,
+                      rowLinesList->ElementAt(rowIndex - 1));
+      } else {
+        styleBorder.SetBorderStyle(NS_SIDE_TOP,
+                      rowLinesList->ElementAt(listLength - 1));
+      }
+      styleBorder.SetBorderWidth(NS_SIDE_TOP, borderWidth);
+    }
+
+    // We don't place a column line on the left of the first column.
+    if (columnIndex > 0 && columnLinesList) {
+      // If the column number is greater than the number of provided columline
+      // values, we simply repeat the last value.
+      int32_t listLength = columnLinesList->Length();
+      if (columnIndex < listLength) {
+        styleBorder.SetBorderStyle(NS_SIDE_LEFT,
+                      columnLinesList->ElementAt(columnIndex - 1));
+      } else {
+        styleBorder.SetBorderStyle(NS_SIDE_LEFT,
+                      columnLinesList->ElementAt(listLength - 1));
+      }
+      styleBorder.SetBorderWidth(NS_SIDE_LEFT, borderWidth);
+    }
+
+    nsPoint offset = ToReferenceFrame();
+    nsCSSRendering::PaintBorderWithStyleBorder(mFrame->PresContext(), *aCtx,
+                                               mFrame, mVisibleRect,
+                                               nsRect(offset,
+                                                      mFrame->GetSize()),
+                                               styleBorder,
+                                               mFrame->StyleContext(),
+                                               mFrame->GetSkipSides());
+  }
+};
+
 #ifdef DEBUG
 static bool
 IsTable(uint8_t aDisplay)
 {
   if ((aDisplay == NS_STYLE_DISPLAY_TABLE) ||
       (aDisplay == NS_STYLE_DISPLAY_INLINE_TABLE))
     return true;
   return false;
@@ -825,40 +896,114 @@ nsMathMLmtdFrame::AttributeChanged(int32
     if (aAttribute == nsGkAtoms::columnspan_)
       aAttribute = nsGkAtoms::colspan;
     return nsTableCellFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
   }
 
   return NS_OK;
 }
 
+uint8_t
+nsMathMLmtdFrame::GetVerticalAlign() const
+{
+  // Set the default alignment in case no alignment was specified
+  uint8_t alignment = nsTableCellFrame::GetVerticalAlign();
+
+  nsTArray<int8_t>* alignmentList = FindCellProperty(this, RowAlignProperty());
+
+  if (alignmentList) {
+    int32_t rowIndex;
+    GetRowIndex(rowIndex);
+
+    // If the row number is greater than the number of provided rowalign values,
+    // we simply repeat the last value.
+    if (rowIndex < (int32_t)alignmentList->Length())
+      alignment = alignmentList->ElementAt(rowIndex);
+    else
+      alignment = alignmentList->ElementAt(alignmentList->Length() - 1);
+  }
+
+  return alignment;
+}
+
+nsresult
+nsMathMLmtdFrame::ProcessBorders(nsTableFrame* aFrame,
+                                 nsDisplayListBuilder* aBuilder,
+                                 const nsDisplayListSet& aLists)
+{
+  aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
+                                            nsDisplaymtdBorder(aBuilder, this));
+  return NS_OK;
+}
 // --------
 // implementation of nsMathMLmtdInnerFrame
 
 NS_QUERYFRAME_HEAD(nsMathMLmtdInnerFrame)
   NS_QUERYFRAME_ENTRY(nsIMathMLFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrame)
 
 nsIFrame*
 NS_NewMathMLmtdInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsMathMLmtdInnerFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsMathMLmtdInnerFrame)
 
+nsMathMLmtdInnerFrame::nsMathMLmtdInnerFrame(nsStyleContext* aContext)
+  : nsBlockFrame(aContext)
+{
+  // Make a copy of the parent nsStyleText for later modificaiton.
+  mUniqueStyleText = new (PresContext()) nsStyleText(*StyleText());
+}
+
 nsMathMLmtdInnerFrame::~nsMathMLmtdInnerFrame()
 {
+  mUniqueStyleText->Destroy(PresContext());
 }
 
 NS_IMETHODIMP
 nsMathMLmtdInnerFrame::Reflow(nsPresContext*          aPresContext,
                               nsHTMLReflowMetrics&     aDesiredSize,
                               const nsHTMLReflowState& aReflowState,
                               nsReflowStatus&          aStatus)
 {
   // Let the base class do the reflow
   nsresult rv = nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
 
   // more about <maligngroup/> and <malignmark/> later
   // ...
   return rv;
 }
+
+const
+nsStyleText* nsMathMLmtdInnerFrame::StyleTextForLineLayout()
+{
+  // Set the default alignment in case nothing was specified
+  uint8_t alignment = StyleText()->mTextAlign;
+
+  nsTArray<int8_t>* alignmentList =
+    FindCellProperty(this, ColumnAlignProperty());
+
+  if (alignmentList) {
+    nsMathMLmtdFrame* cellFrame = (nsMathMLmtdFrame*)GetParent();
+    int32_t columnIndex;
+    cellFrame->GetColIndex(columnIndex);
+
+    // If the column number is greater than the number of provided columalign
+    // values, we simply repeat the last value.
+    if (columnIndex < (int32_t)alignmentList->Length())
+      alignment = alignmentList->ElementAt(columnIndex);
+    else
+      alignment = alignmentList->ElementAt(alignmentList->Length() - 1);
+  }
+
+  mUniqueStyleText->mTextAlign = alignment;
+  return mUniqueStyleText;
+}
+
+/* virtual */ void
+nsMathMLmtdInnerFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
+{
+  nsBlockFrame::DidSetStyleContext(aOldStyleContext);
+  mUniqueStyleText->Destroy(PresContext());
+  mUniqueStyleText = new (PresContext()) nsStyleText(*StyleText());
+}
diff --git a/layout/mathml/nsMathMLmtableFrame.h b/layout/mathml/nsMathMLmtableFrame.h
--- a/layout/mathml/nsMathMLmtableFrame.h
+++ b/layout/mathml/nsMathMLmtableFrame.h
@@ -204,16 +204,21 @@ public:
 
   // overloaded nsTableCellFrame methods
 
   NS_IMETHOD
   AttributeChanged(int32_t  aNameSpaceID,
                    nsIAtom* aAttribute,
                    int32_t  aModType) MOZ_OVERRIDE;
 
+  virtual uint8_t GetVerticalAlign() const;
+  virtual nsresult ProcessBorders(nsTableFrame* aFrame,
+                                  nsDisplayListBuilder* aBuilder,
+                                  const nsDisplayListSet& aLists);
+
   virtual int32_t GetRowSpan() MOZ_OVERRIDE;
   virtual int32_t GetColSpan() MOZ_OVERRIDE;
   virtual bool IsFrameOfType(uint32_t aFlags) const MOZ_OVERRIDE
   {
     return nsTableCellFrame::IsFrameOfType(aFlags & ~(nsIFrame::eMathML));
   }
 
 protected:
@@ -251,14 +256,20 @@ public:
          nsReflowStatus&          aStatus) MOZ_OVERRIDE;
 
   virtual bool IsFrameOfType(uint32_t aFlags) const MOZ_OVERRIDE
   {
     return nsBlockFrame::IsFrameOfType(aFlags &
       ~(nsIFrame::eMathML | nsIFrame::eExcludesIgnorableWhitespace));
   }
 
+  virtual const nsStyleText* StyleTextForLineLayout();
+  virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext) MOZ_OVERRIDE;
+
 protected:
-  nsMathMLmtdInnerFrame(nsStyleContext* aContext) : nsBlockFrame(aContext) {}
+  nsMathMLmtdInnerFrame(nsStyleContext* aContext);
   virtual ~nsMathMLmtdInnerFrame();
+
+  nsStyleText* mUniqueStyleText;
+
 };  // class nsMathMLmtdInnerFrame
 
 #endif /* nsMathMLmtableFrame_h___ */
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -348,16 +348,34 @@ nsTableCellFrame::PaintCellBackground(ns
                                       uint32_t aFlags)
 {
   if (!StyleVisibility()->IsVisible())
     return;
 
   PaintBackground(aRenderingContext, aDirtyRect, aPt, aFlags);
 }
 
+nsresult
+nsTableCellFrame::ProcessBorders(nsTableFrame* aFrame,
+                                 nsDisplayListBuilder* aBuilder,
+                                 const nsDisplayListSet& aLists)
+{
+  const nsStyleBorder* borderStyle = StyleBorder();
+  if (aFrame->IsBorderCollapse() || !borderStyle->HasBorder())
+    return NS_OK;
+
+  if (!GetContentEmpty() ||
+      StyleTableBorder()->mEmptyCells == NS_STYLE_TABLE_EMPTY_CELLS_SHOW) {
+    aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
+                                              nsDisplayBorder(aBuilder, this));
+  }
+
+  return NS_OK;
+}
+
 class nsDisplayTableCellBackground : public nsDisplayTableItem {
 public:
   nsDisplayTableCellBackground(nsDisplayListBuilder* aBuilder,
                                nsTableCellFrame* aFrame) :
     nsDisplayTableItem(aBuilder, aFrame) {
     MOZ_COUNT_CTOR(nsDisplayTableCellBackground);
   }
 #ifdef NS_BUILD_REFCNT_LOGGING
@@ -481,21 +499,17 @@ nsTableCellFrame::BuildDisplayList(nsDis
     
       // display inset box-shadows if we need to.
       if (hasBoxShadow) {
         aLists.BorderBackground()->AppendNewToTop(
           new (aBuilder) nsDisplayBoxShadowInner(aBuilder, this));
       }
     
       // display borders if we need to
-      if (!tableFrame->IsBorderCollapse() && borderStyle->HasBorder() &&
-          emptyCellStyle == NS_STYLE_TABLE_EMPTY_CELLS_SHOW) {
-        aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
-          nsDisplayBorder(aBuilder, this));
-      }
+      ProcessBorders(tableFrame, aBuilder, aLists);
     
       // and display the selection border if we need to
       if (IsSelected()) {
         aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
           nsDisplayGeneric(aBuilder, this, ::PaintTableCellSelection,
                            "TableCellSelection",
                            nsDisplayItem::TYPE_TABLE_CELL_SELECTION));
       }
diff --git a/layout/tables/nsTableCellFrame.h b/layout/tables/nsTableCellFrame.h
--- a/layout/tables/nsTableCellFrame.h
+++ b/layout/tables/nsTableCellFrame.h
@@ -96,16 +96,21 @@ public:
   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
 
   void PaintCellBackground(nsRenderingContext& aRenderingContext,
                            const nsRect& aDirtyRect, nsPoint aPt,
                            uint32_t aFlags);
 
+ 
+  virtual nsresult ProcessBorders(nsTableFrame* aFrame,
+                                  nsDisplayListBuilder* aBuilder,
+                                  const nsDisplayListSet& aLists);
+
   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext) MOZ_OVERRIDE;
   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext) MOZ_OVERRIDE;
   virtual IntrinsicWidthOffsetData
     IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext) MOZ_OVERRIDE;
 
   NS_IMETHOD Reflow(nsPresContext*      aPresContext,
                     nsHTMLReflowMetrics& aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
@@ -124,17 +129,17 @@ public:
 
   void VerticallyAlignChild(nscoord aMaxAscent);
 
   /*
    * Get the value of vertical-align adjusted for CSS 2's rules for a
    * table cell, which means the result is always
    * NS_STYLE_VERTICAL_ALIGN_{TOP,MIDDLE,BOTTOM,BASELINE}.
    */
-  uint8_t GetVerticalAlign() const;
+  virtual uint8_t GetVerticalAlign() const;
 
   bool HasVerticalAlignBaseline() const {
     return GetVerticalAlign() == NS_STYLE_VERTICAL_ALIGN_BASELINE;
   }
 
   bool CellHasVisibleContent(nscoord       height,
                                nsTableFrame* tableFrame,
                                nsIFrame*     kidFrame);
